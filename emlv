#!/usr/bin/env python2
# -*- coding: utf-8 -*-

import os
import sys
import traceback
import locale
import gettext
from gemlv.sysutils import warnx
try:
	import better_exchook
except ImportError:
	pass
else:
	better_exchook.install()
import email
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email.mime.message import MIMEMessage
from gemlv.contenttypestring import ContentTypeString
import gemlv.email
import re
from tempfile import mkstemp
from tempfile import mkdtemp
from mimetypes import guess_extension
import magic
import argparse
import time
try:
	import setproctitle
except ImportError:
	warnx("No module named setproctitle. Degrading.")
	class setproctitle(object):
		@classmethod
		def setproctitle(self, *x, **kv):
			pass
import xdg.BaseDirectory
from gemlv.utils import AddressLine
from gemlv.utils import getaddresslines
from gemlv.utils import decode_mimetext
from gemlv.mimetext import MimeDecoded
from gemlv.mimetext import MimeEncoded
import gemlv.addressbook
from gemlv.constants import *
import gemlv.mime as mime
from gemlv.textutils import human_size
from gemlv.pythonutils import SubstractableList





def output_write(s):
	output.write(str(s))

def td_esc_cb(m):
	return repr(m.group(0)).replace('\'', '')

def td_esc(s):
	return re.sub(r'[\t\n\r]', td_esc_cb, s)

def print_mime_part_td_header():
	output_write("INDEX	MIME_TYPE	SIZE	FILENAME	DESCRIPTION\n")

def list_mime_parts(eml, input_file_index):
	for part_idx, eml in walk_mime_parts(eml, input_file_index):
		size = human_size(eml.size_decoded_approx)
		output_write('\t'.join([part_idx, eml.content_type, size, td_esc(eml.filename), td_esc(eml.header['Content-Description'].decoded)])+'\n')

def display_headers(eml, extra_headers=[]):
	headers = CommonUserInterestedHeaders
	headers.extend(SubstractableList(extra_headers) - CommonUserInterestedHeaders)
	for hname in headers:
		hval = eml.header[hname].decoded
		if hval:
			hval = hval.strip()
			hval = hval.replace('\n', '\n\t')
			output_write(hname+': '+hval+'\n')

def display(eml):
	if eml.is_multipart():
		output_write(eml.preamble+'\n'+eml.epilogue)
	else:
		# TODO consider get_content_readably()
		output_write(eml.payload_decoded)
	
	# TODO support filters

def load_email(filepath):
	return gemlv.email.Email(email.message_from_file(open(filepath, 'r')))

def walk_mime_parts(eml, idx):
	yield (idx, eml)
	for part_idx, part in enumerate(eml.parts):
		for x in walk_mime_parts(part, '%s.%d' % (idx, part_idx)):
			yield x




argparser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
argparser.description = """Display RFC-822 email file(s) headers, content, and attachments, list MIME parts, extract attachments from it.
Without -l or -x option, i.e. read-mode, display the first text/plain part as content."""
argp_mxgroup = argparser.add_mutually_exclusive_group()
argp_mxgroup.add_argument('--list', '-l', action='store_true', help="List all MIME parts in email files given in FILE.")
argp_mxgroup.add_argument('--extract', '-x', action='append', metavar='INDEX', help="Extract MIME part specified by INDEX to stdout. May be specified multiple times.")
argparser.add_argument('--html', action='store_true', help="Take the first text/html part as content, not text/plain. Option --body-filter is also recommended here.")
argparser.add_argument('--header', '-H', action='append', default=[], metavar='HEADER', help="Extra headers to show in read-mode.")
argparser.add_argument('--header-filter', '-fh', metavar='COMMAND', help="Filter the headers through this command.")
argparser.add_argument('--body-filter', '-fb', metavar='COMMAND', help="Filter the message body through this command.")
argparser.add_argument('--attachments-filter', '-fa', metavar='COMMAND', help="Filter the table of attachments through this command (in read-mode).")
argparser.add_argument('FILE', nargs='*', help="Process the given FILEs. Read STDIN if FILE is not given.")
option = argparser.parse_args(args=sys.argv[1:])


if not option.list and not option.extract:
	read_mode = True
else:
	read_mode = False

primary_content_type = 'text/plain'
if option.html:
	primary_content_type = 'text/html'

if not option.FILE:
	option.FILE.append('/dev/stdin')

if not option.list and not option.extract:
	# "read primary part" mode
	option.extract = []
	for input_file_index, filename in enumerate(option.FILE):
		option.extract.append('%d.primary' % input_file_index)

output = sys.stdout

if option.list:
	print_mime_part_td_header()
	for idx, filename in enumerate(option.FILE):
		eml = load_email(filename)
		list_mime_parts(eml, str(idx))

else:
	for idx in option.extract:
		indices = idx.split('.')
		input_file_index = int(indices[0])
		eml = load_email(option.FILE[input_file_index])
		part = eml
		
		if len(indices) == 2 and indices[1] == 'primary':
			mime_part_indices = []
			for part_idx, sub_part in walk_mime_parts(part, str(input_file_index)):
				if sub_part.content_type == primary_content_type:
					mime_part_indices = part_idx.split('.')[1:]
					break
		else:
			mime_part_indices = indices[1:]
		
		for part_idx in map(int, mime_part_indices):
			part = part.parts[part_idx]
		
		if read_mode:
			if option.header_filter:
				output = os.popen(option.header_filter, 'w')
			display_headers(eml, extra_headers=option.header)
			output_write("\n")
			output.flush()
			output = sys.stdout
		
		if option.body_filter:
			output = os.popen(option.body_filter, 'w')
		display(part)
		output.flush()
		output = sys.stdout
		
		if read_mode:
			output_write('\n')  # in case of body did not end with newline
			if option.attachments_filter:
				output = os.popen(option.attachments_filter, 'w')
			print_mime_part_td_header()
			list_mime_parts(eml, str(input_file_index))
			output.flush()
			output = sys.stdout

