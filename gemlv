#!/usr/bin/env python2
# -*- coding: utf-8 -*-

import os
import sys
import traceback
import signal
import select
import gtk
import gobject
import glib
import pango
import locale
import gettext
from gemlv.sysutils import warnx
import email
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email.mime.message import MIMEMessage
from gemlv.contenttypestring import ContentTypeString
import gemlv.email
import re
from tempfile import mkstemp
from tempfile import mkdtemp
from mimetypes import guess_extension
import magic
from gemlv.textutils import wildcardmatch
import argparse
try:
	import xattr
except ImportError:
	warnx("No module named xattr. Degrading extended attribute management.")
	xattr = None
import urlparse
import pwd
import threading
import time
import hashlib
import urllib2
import gnupg
try:
	import textwrap
except ImportError:
	warnx("No module named textwrap. Degrading.")
	class textwrap(object):
		@classmethod
		def wrap(self, text, width):
			return [text]
try:
	import setproctitle
except ImportError:
	warnx("No module named setproctitle. Degrading.")
	class setproctitle(object):
		@classmethod
		def setproctitle(self, *x, **kv):
			pass
try:
	import fuzzywuzzy.process
except ImportError:
	warnx("No module named fuzzywuzzy. Degrading address auto completer.")
	fuzzywuzzy = None
import uuid
import xdg.BaseDirectory
try:
	import pyexiv2
except ImportError:
	warnx("No module named pyexiv2. Degrading image auto rotation.")
	pyexiv2 = None
try:
	import sqlite3
except ImportError:
	warnx("No module named sqlite3. Degrading sender email address suggestion based on past correspondences.")
	sqlite3 = None
from gemlv.utils import AddressLine
from gemlv.utils import getaddresslines
from gemlv.utils import decode_mimetext
from gemlv.utils import get_gecos_name
from gemlv.mimetext import MimeDecoded
from gemlv.mimetext import MimeEncoded
from gemlv.textutils import list2text
from gemlv.textutils import human_size
from gemlv.textutils import shorturl
import gemlv.addressbook
from gemlv.sysutils import futimes
from gemlv.sysutils import recursive_rm
from gemlv.sysutils import set_blocking
from gemlv.sysutils import which
from gemlv.sysutils import mkdir
from gemlv.sysutils import make_relative_symlink
from gemlv.sysutils import read_symlink_target_abs
from gemlv.sysutils import is_safe_symlink
from gemlv.sysutils import basenameify
from gemlv.sysutils import file_uri_to_path
import gemlv.user_signature
from gemlv.pythonutils import BasicReuseable
from gemlv.pythonutils import Cyclelist
from gemlv.pythonutils import SubstractableList
import gemlv.gemlvtk as gemlvtk
from gemlv.constants import *
import gemlv.mime as mime


### helper classes, functions ###



class cfgparser(object):
	def __init__(self, name, **kvargs):
		self.var = {'regex': '^\s*([^;#].*)', 'split': [1],}
		for k in 'regex', 'splitgroups':
			if not self.var.has_key(k): self.var[k] = None
			if kvargs.has_key(k): self.var[k] = kvargs[k]
		suff = '.conf'
		self.filehandlers = []
		for t in (os.environ['HOME'], '.config', PROGNAME, name + suff), (os.path.sep, 'etc', PROGNAME, name + suff),:
			n = os.path.join(*t)
			try:
				fh = open(n, 'r')
				self.filehandlers.append(fh)
			except IOError:
				pass
	
	def __iter__(self):
		return self
	
	def next(self):
		if len(self.filehandlers) == 0:
			raise StopIteration
		else:
			fh = self.filehandlers[0]
			while True:
				ln = fh.readline()
				if ln == '':
					fh.close()
					self.filehandlers.reverse()
					self.filehandlers.pop()
					self.filehandlers.reverse()
					if len(self.filehandlers) == 0:
						raise StopIteration
					fh = self.filehandlers[0]
					continue
				m = re.search(self.var['regex'], ln)
				if m:
					grps = []
					for n, grp in enumerate(m.groups()):
						if n+1 in self.var['splitgroups']:
							if grp is None:
								grp = []
							else:
								grp = re.split('\s+', grp)
						grps.append(grp)
					return grps
	
	def __del__(self):
		for fh in self.filehandlers:
			fh.close()

class PropertyTree(dict):
	def __init__(self, *args):
		super(self.__class__, self).__init__(*args)
		self.savedprops = {}
		self.write_delay = 1.2
		self.APPNAME = 'gemlv'
	def _read(self, propname):
		propvalue = super(self.__class__, self).get(propname)
		if propvalue is None:
			for d in xdg.BaseDirectory.xdg_config_dirs:
				path = os.path.join(d, self.APPNAME, 'prop', propname)
				if os.path.exists(path):
					with open(path, 'r') as f:
						propvalue = f.read()
					break
		return propvalue
	def __getitem__(self, propname):
		propvalue = self._read(propname)
		if propvalue is not None:
			self.savedprops[propname] = propvalue
			super(self.__class__, self).__setitem__(propname, propvalue)
		return propvalue
	def get(self, propname, default):
		propvalue = self.__getitem__(propname)
		if propvalue is None: return default
		return propvalue
	def __setitem__(self, propname, propvalue):
		super(self.__class__, self).__setitem__(propname, propvalue)
		timer2_once(self.write_delay, self._write_all, reschedule=False)
	def _write_all(self):
		for propname, propvalue in self.iteritems():
			propvalue = str(propvalue)
			if self.savedprops.get(propname) != propvalue:
				propfile = os.path.join(xdg.BaseDirectory.save_config_path(self.APPNAME), 'prop', propname)
				mkdir(os.path.dirname(propfile))
				open(propfile, 'w').write(propvalue)
				self.savedprops[propname] = propvalue

class pipereader(object):
	def __init__(self, inputstr, cmd, args=[], exitdict=None):
		self.exitdict = exitdict
		args = args[:]
		args.insert(0, os.path.basename(cmd))
		child_read, parent_write, parent_read, child_write = get_pipe_handlers(2)
		pid = os.fork()
		if pid == 0:
			parent_read.close()
			parent_write.close()
			os.dup2(child_read.fileno(), sys.stdin.fileno())
			os.dup2(child_write.fileno(), sys.stdout.fileno())
			os.closerange(3, 255)
			try:
				os.execvp(cmd, args)
			except OSError as e:
				warnx(str(e))
			os._exit(127)
		else:
			child_read.close()
			child_write.close()
			parent_write.write(inputstr)
			parent_write.close()
			self.pid = pid
			self.reader = parent_read
	
	def __iter__(self):
		return self
	
	def next(self):
		s = self.reader.readline()
		if s == '':
			raise StopIteration
		else:
			return s
	
	def __del__(self):
		self.reader.close()
		status = WaitExecStatus(self.pid)
		if self.exitdict is not None:
			self.exitdict.update(status.__dict__)


def timer_once(iden, sec, func, func_args=()):
	if Timers.has_key(iden):
		glib.source_remove(Timers[iden])
		del Timers[iden]
	if func is not None:
		Timers[iden] = glib.timeout_add(sec*1000, timer_call, (func, func_args))

def timer_call(data):
	func = data[0]
	args = data[1]
	func(*args)
	return False

# TODO: move time* to timer2*
def timer2_once(sec, func, func_args=(), reschedule=True, iden=None):
	if iden is None:
		iden = func.__name__
	if Timers2.has_key(iden):
		if reschedule:
			Timers2[iden]['cancel']()
		else:
			return
	if func is not None:
		Timers2[iden] = {
			'handle': glib.timeout_add(int(sec*1000), timer2_call, iden, func, func_args),
			'func': func,
			'args': func_args,
			'cancel': lambda: timer2_cancel(iden),
		}

def timer2_cancel(iden):
	if iden in Timers2:
		glib.source_remove(Timers2[iden]['handle'])
		del Timers2[iden]

def timer2_call(iden, func, args):
	del Timers2[iden]
	func(*args)
	return False

def timer2_flush():
	for iden in Timers2.keys():
		glib.source_remove(Timers2[iden]['handle'])
		timer2_call(iden, Timers2[iden]['func'], Timers2[iden]['args'])


def save_exception_traceback(exc_obj, traceback_str):
	if hasattr(exc_obj, 'traceback_str'):
		exc_obj.traceback_str += traceback_str
	else:
		exc_obj.traceback_str = traceback_str
	exc_obj.traceback_str += '\n'

def display_error(e, suppl_text=''):
	text = None
	if hasattr(e, 'strerror'):
		text = e.strerror
		if hasattr(e, 'errno'):
			text += ' (code %d)' % e.errno
		if e.filename is not None:
			text += '\n' + _("file") + ': ' + e.filename
	elif isinstance(e, Exception):
		text = e.__class__.__name__ + ':\n' + e.message
		if hasattr(e, 'traceback_str'):
			suppl_text += '\n' + e.traceback_str
	elif isinstance(e, list):
		text = ''.join(e)
	if text is None:
		text = str(e)
	dlg = gtk.MessageDialog(gemlvtk.get_current_window(), gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_ERROR, gtk.BUTTONS_OK, text)
	dlg.set_transient_for(gemlvtk.get_current_window())
	dlg.set_title(_("Error"))
	if suppl_text != '':
		dlg.set_resizable(True)
		carea = dlg.get_content_area()
		carea.pack_start(gemlvtk.ScrolledLabelView(suppl_text), True, True)
	dlg.show_all()
	dlg.run()
	dlg.destroy()

def display_info_box_async(text, suppl_text=None):
	dlg = gtk.MessageDialog(gemlvtk.get_current_window(), gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_INFO, gtk.BUTTONS_OK, text)
	dlg.set_transient_for(gemlvtk.get_current_window())
	dlg.set_title(_("Info"))
	if suppl_text is not None:
		dlg.set_resizable(True)
		carea = dlg.get_content_area()
		carea.pack_start(gemlvtk.ScrolledLabelView(suppl_text), True, True)
	dlg.get_widget_for_response(gtk.RESPONSE_OK).connect('clicked', lambda btn, dlg: dlg.destroy(), dlg)
	dlg.show_all()

def question(msg, stock_yes=None, stock_no=None, parent=None):
	dlg = gtk.MessageDialog(parent or gemlvtk.get_current_window(), gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_QUESTION, gtk.BUTTONS_YES_NO)
	dlg.set_markup(msg)
	dlg.set_title(_("Question"))
	if stock_no is not None:
		dlg.get_widget_for_response(gtk.RESPONSE_NO).hide()
		btn_no = gemlvtk.StockButton(label=stock_no[0], stock=stock_no[1])
		dlg.add_action_widget(btn_no, gtk.RESPONSE_NO)
		btn_no.show()
	if stock_yes is not None:
		dlg.get_widget_for_response(gtk.RESPONSE_YES).hide()
		btn_yes = gemlvtk.StockButton(label=stock_yes[0], stock=stock_yes[1])
		dlg.add_action_widget(btn_yes, gtk.RESPONSE_YES)
		btn_yes.show()
	resp = dlg.run()
	dlg.destroy()
	return (resp == gtk.RESPONSE_YES)

def set_dialog_icon_name(dlg, icon):
	img = dlg.get_content_area().children()[0].children()[0]
	img.set_from_icon_name(icon, gtk.ICON_SIZE_DIALOG)

def choose_dialog(action, filename=None, multifile=False, ask_overwrite=False, custom_accept_button_stock=None):
	global FileChooserLastFolder
	selected = None
	
	assert (multifile and not ask_overwrite) or not multifile
	assert (ask_overwrite and action == gtk.FILE_CHOOSER_ACTION_SAVE) or not ask_overwrite
	
	btn_accept_stock = gtk.STOCK_SAVE
	if action == gtk.FILE_CHOOSER_ACTION_OPEN:
		btn_accept_stock = gtk.STOCK_OPEN
	if custom_accept_button_stock is not None:
		btn_accept_stock = custom_accept_button_stock
	dlg = gtk.FileChooserDialog(parent=gemlvtk.get_current_window(), action=action, buttons=(gtk.STOCK_CANCEL, gtk.RESPONSE_REJECT, btn_accept_stock, gtk.RESPONSE_ACCEPT))
	if FileChooserLastFolder is not None: dlg.set_current_folder(FileChooserLastFolder)
	if filename is not None: dlg.set_current_name(filename)
	if multifile:
		dlg.set_select_multiple(True)
		selected = []
	btn_cwd = gemlvtk.StockButton(label=_("Working Dir"), stock=gtk.STOCK_JUMP_TO)
	dlg.add_action_widget(btn_cwd, gtk.RESPONSE_NO)
	btn_cwd.show()
	while True:
		resp = dlg.run()
		if resp == gtk.RESPONSE_ACCEPT:
			if multifile:
				selected = dlg.get_filenames()
			else:
				tmp_selected = dlg.get_filename()
				if ask_overwrite and os.path.lexists(tmp_selected):
					if not question(_("This file already exists:") + ('\n<tt>%s</tt>\n' % (glib.markup_escape_text(os.path.basename(tmp_selected)))) + _("Overwrite?"), (None, gtk.STOCK_SAVE)):
						continue
				selected = tmp_selected
			break
		elif resp == gtk.RESPONSE_NO:
			dlg.set_current_folder(os.getcwd())
		else:
			break
	if dlg.get_current_folder() is not None:
		FileChooserLastFolder = dlg.get_current_folder()
	dlg.destroy()
	return selected

def choose_save_file(filename=None, ask_overwrite=False):
	return choose_dialog(gtk.FILE_CHOOSER_ACTION_SAVE, filename, ask_overwrite=ask_overwrite)

def choose_save_folder():
	return choose_dialog(gtk.FILE_CHOOSER_ACTION_SELECT_FOLDER)

def choose_open_file(custom_accept_button_stock=None):
	return choose_dialog(gtk.FILE_CHOOSER_ACTION_OPEN, custom_accept_button_stock=custom_accept_button_stock)

def choose_open_files(custom_accept_button_stock=None):
	return choose_dialog(gtk.FILE_CHOOSER_ACTION_OPEN, multifile=True, custom_accept_button_stock=custom_accept_button_stock)

def get_pipe_handlers(npairs):
	pipes = []
	for n in range(0, npairs):
		r, w = os.pipe()
		pipes.append(os.fdopen(r, 'r'))
		pipes.append(os.fdopen(w, 'w'))
	return pipes


def run_async(cmd, args, postrun):
	args = args[:]
	args.insert(0, os.path.basename(cmd))
	pid1 = os.fork()
	if pid1 == 0:
		os.closerange(0, 255)
		pid2 = os.fork()
		if pid2 == 0:
			if postrun is None:
				pid3 = 0
			else:
				pid3 = os.fork()
			if pid3 == 0:
				os.execvp(cmd, args)
				os._exit(127)
			else:
				status = WaitExecStatus(pid3)
				postrun[0](*postrun[1:])
				os._exit(status.code)
		else:
			os._exit(0)
	else:
		os.waitpid(pid1, 0)

class WaitExecStatus(object):
	def __init__(self, pid):
		x, status = os.waitpid(pid, 0)
		self.status = status >> 8
		self.code = self.status
		self.signal = status & 0x7F
		self.coredumped = status & 0x80 >> 7
	def __repr__(self):
		return 'status %s, signal %s%s' % (self.status, self.signal, ', core dumped' if self.coredumped else '')

class ExecThreadRunner(threading.Thread):
	def __init__(self, syscmd, sysargs, cb=None):
		assert isinstance(syscmd, str)
		assert isinstance(sysargs, list)
		assert isinstance(cb, list)
		assert len(cb) > 0
		super(self.__class__, self).__init__(target=self.execve, args=[syscmd, sysargs])
		self.callback = cb
	
	def execve(self, cmd, args):
		pid = os.fork()
		if pid == 0:
			os.closerange(0, 255)
			try:
				os.execvp(cmd, [cmd] + args)
			except OSError as e:
				warnx(str(e))
			os._exit(127)
		else:
			return WaitExecStatus(pid)
	
	def run(self):
		result = self._Thread__target(*self._Thread__args, **self._Thread__kwargs)
		if self.callback is not None:
			self.callback[0](result, *self.callback[1:])

def main_thread_alive():
	alive = None
	for thr in threading.enumerate():
		if thr.name == 'MainThread':
			alive = thr.is_alive()
			break
	return alive


def truish(x):
	return(str(x).lower() in ['yes', '1', 'true', 'on'])


def get_iterator_from_pos(treeview, x, y):
	pathinfo = treeview.get_path_at_pos(x, y)
	if pathinfo is None: return None
	return treeview.get_model().get_iter(pathinfo[0])




def win_main_show(widget, event):
	win_main.disconnect(start_evt)
	saved_font = Props['ui/view/font']
	if saved_font is not None: change_font(panel_content, saved_font)
	panel_content.set_data('saved-font', get_current_font(panel_content))
	if cliArgs.FILE:
		load_file(cliArgs.FILE)


def extract_email_addresses_from_headers(headername, email_obj):
	return map(lambda al: al.email, \
		getaddresslines(email_obj.headers[headername].decoded))

def extract_1_email_address_from_headers(headername, email_obj):
	addresses = extract_email_addresses_from_headers(headername, email_obj)
	if len(addresses) == 0: return None
	else: return addresses[0]


def email_from_file(filename):
	try:
		fh = open(filename, 'r')
	except IOError as e:
		display_error(e)
		act_quit()
		return None, None
	eml = email.message_from_file(fh)
	return gemlv.email.Email(eml), fh

def load_file(filename):
	global TheEmail
	global LeafParts
	TheEmail, fh = email_from_file(filename)
	if TheEmail is None: return
	TheEmail = gemlv.email.Email(TheEmail)
	win_main.set_data('email-file-handle', fh)
	win_main.set_data('email-file', filename)
	update_window_title(win_main, filename, TheEmail.header[HDR_SUBJ].decoded)
	
	senderaddr = None
	for h in OriginatorHeaders:
		addr = extract_1_email_address_from_headers(h, TheEmail)
		if addr:
			senderaddr = addr
			break
	threading.Thread(target=load_gravatar, args=(senderaddr, panel_view_avatar)).start()
	
	if TheEmail.header[HDR_DNT].nonempty:
		if get_xattr(filename, XATTR_MDNSENT) is None:
			menubutton_mdn.show()
	if truish(get_xattr(filename, XATTR_MDNSENT)):
		stck_mdn.show()
	if truish(get_xattr(filename, XATTR_REPLIED)):
		stck_repl.show()
	if truish(get_xattr(filename, XATTR_FORWARDED)):
		stck_fwd.show()
	
	if get_listaddressline_main().email:
		menubutton_replytolist.show()
	if TheEmail.header['List-Unsubscribe'].nonempty:
		menubutton_unsubscribe.show()
	
	panel_view_header.set_markup(get_headers_markup(TheEmail))
	panel_view_subject.set_markup(PMU_SUBJ + glib.markup_escape_text(TheEmail.header[HDR_SUBJ].decoded.replace('\n', '')) + PMU_SUBJ_CLOSE)
	clear_parts(Parts)
	load_parts(TheEmail, Parts, Parts.get_iter_root())
	panel_parts.expand_all()
	if TheEmail.is_multipart():
		if PartPrimary is not None:
			selection_parts.select_iter(PartPrimary)
		elif PartSecondary is not None:
			selection_parts.select_iter(PartSecondary)
		else:
			selection_parts.select_path((0,))
	else:
		selection_parts.select_path((0,))

	if LeafParts > 1:
		pos = panel_body.get_data('saved-position')
		if pos is not None:
			panel_body.set_position(pos)
			panel_body.set_data('saved-position', None)
	else:
		panel_body.set_data('saved-position', panel_body.get_position())
		panel_body.set_position(0)

def clear_parts(model):
	global LeafParts
	LeafParts = 0
	model.clear()

def load_parts(eml, model, parent):
	global PartPrimary
	global PartSecondary
	global LeafParts
	
	label = PMU_MIME + glib.markup_escape_text(eml.content_type) + PMU_MIME_CLOSE
	if eml.filename: label = glib.markup_escape_text(eml.filename) + ' ' + label
	stock = gemlvtk.get_stock_icon_by_mime(eml.content_type.main, eml.content_type.sub)
	pixb = None
	
	iterator = model.append(parent, [eml, label, stock, pixb, {}])
	# Note: buggy or incomplete Content-Type (eg. "Content-Type: pdf") is reported as text/plain by email module
	if PartPrimary is None and eml.content_type == MIMETYPE_TEXT:
		PartPrimary = iterator
	if PartSecondary is None and eml.content_type == MIMETYPE_HTML:
		PartSecondary = iterator
	if eml.content_type == 'multipart/encrypted':
		crypto_protocol = eml.header[HDR_CT].param['protocol'].decoded
		if crypto_protocol == 'application/pgp-encrypted':
			# RFC3156
			pgp_metadata_part = eml.parts[0]
			load_parts(pgp_metadata_part, model, iterator)
			encrypted_part_num = 1
			encrypted_part = eml.parts[encrypted_part_num]
			encrypted_data = encrypted_part.as_string()
			decrypt = gpg.decrypt(encrypted_data)
			if decrypt.ok:
				decrypted_eml = gemlv.email.Email(email.message_from_string(decrypt.data))
				load_parts(decrypted_eml, model, iterator)
				iconname = 'changes-allow'
			else:
				iconname = 'changes-prevent'
			
			if decrypt.key_id is not None:
				# it's a encrypted and signed message, store signatue info for later
				model[model.iter_nth_child(iterator, encrypted_part_num)][COL_PARTS_INFO]['gpg'] = {
					'valid': decrypt.valid,
					'stderr': decrypt.stderr,
					'username': decrypt.username,
				}
			
			for other_part in eml.parts[2:]:
				load_parts(other_part, model, iterator)
			
			# Display an open/locked padlock icon
			model[model.iter_nth_child(iterator, encrypted_part_num)][COL_PARTS_ICONNAME] = None
			model[model.iter_nth_child(iterator, encrypted_part_num)][COL_PARTS_ICON] = gtk.icon_theme_get_default().load_icon(iconname, gtk.ICON_SIZE_SMALL_TOOLBAR, 0)
			if not decrypt.ok:
				display_error(_("Decryption error") + ':\n' + decrypt.status, decrypt.stderr)
			return
	if eml.is_multipart():
		for part in eml.parts:
			load_parts(part, model, iterator)
	else:
		LeafParts += 1

def clear_content(s=''):
	bufr = panel_content.get_buffer()
	bufr.set_text(s)
	panel_content.set_sensitive(False)
	return bufr

def decode_readably(s, eml):
	charset = eml.header[HDR_CT].param['charset'].decoded or 'utf-8'
	return s.decode(charset, 'replace')

def get_content_readably(eml):
	return decode_readably(get_content_any(eml), eml)

def get_content_any(eml):
	if eml.is_multipart():
		# TODO: preamble+epilogue instead of as_string?
		return eml.as_string()
	else:
		return eml.payload_decoded

def set_content_text(s):
	bufr = panel_content.get_buffer()
	bufr.set_text(s)
	if s != '' and bufr.get_text(bufr.get_start_iter(), bufr.get_end_iter(), True) == '':
		return False
	panel_content.set_sensitive(True)
	return True

def get_gpg_signed_data_from_mime_part(eml):
	gpg_msg = eml.as_string().replace('\n', '\r\n')
	return gpg_msg

def verify_gpg_signature(message, signature):
	sgn_r, sgn_w = os.pipe()
	sgn_fh = os.fdopen(sgn_w, 'w')
	sgn_fh.write(signature)
	sgn_fh.close()
	return gpg.verify_data('/dev/fd/%d'%sgn_r, message)

def gpg_sign_data(message, gpg_uid):
	assert gpg_uid[0] == '<' and gpg_uid[-1] == '>', "Need GPG UID in \"<name@example.net>\" format."
	
	sgn = gpg.sign(message, keyid=gpg_uid, detach=True, extra_args=['--local-user', gpg_uid])
	if sgn.data == '':
		raise GnuPGSignError(sgn)
	return sgn.data

def get_uids_from_key0(gpg_handle):
	"""
	Return list of (the email part of) all UIDs in the 0th key on the keyring in "<name@example.net>" format.
	"""
	uids = []
	for uid_full in gpg_handle.list_keys()[0]['uids']:
		uid_mail = re.findall(r'(<[^<>]+>)\s*$', uid_full)[0]
		uids.append(uid_mail)
	return uids

def gpg_strip_all_uids(key_data, except_uid):
	if GnuPG_stripped_UIDs_keyring.has_key(key_data) and GnuPG_stripped_UIDs_keyring[key_data].has_key(except_uid):
		return GnuPG_stripped_UIDs_keyring[key_data][except_uid]
	
	# open an ephemeral gpg handle to manipulate the key in it
	tmp_gpghome = mkdtemp(prefix = PROGNAME + '-gpghome_')
	tmp_gpg = gnupg.GPG(use_agent=True, gnupghome=tmp_gpghome)
	tmp_gpg.import_keys(key_data)
	
	try:
		from io import StringIO
	except ImportError:
		from cStringIO import StringIO
	
	# gather info about UIDs
	uids_to_del = []
	for uid_n, uid in enumerate(get_uids_from_key0(tmp_gpg)):
		if uid != except_uid:
			# if this uid is not the one we want to keep, then sign up for delete
			uid_n += 1  # uid indexing is 1-based in gpg edit-key mode
			uids_to_del.append(uid_n)
	
	commands = []
	# delete uids in reverse order not to mess up the indexing
	for uid_n in reversed(uids_to_del):
		# entry these commands into gpg's edit-key mode
		commands.extend(['uid %d' % uid_n, 'deluid', 'y'])
	commands.extend(['save', 'y'])
	
	# instanciate an arbitrary class just to be able to capture the output of our custom gpg command
	result = gnupg.Verify(tmp_gpg)
	# execute gpg command
	tmp_gpg._handle_io(['--command-fd', '0', '--edit-key', except_uid], StringIO(u'\n'.join(commands)), result)
	
	# verify that there is no other uid than except_uid
	extra_uids = filter(lambda uid: uid != except_uid, get_uids_from_key0(tmp_gpg))
	if extra_uids:
		raise GnuPGError(_("Could not remove extra email identities (UIDs) from public key. Can not protect privacy of these email addresses: ")+';'.join(extra_uids))
	
	# maintain in-mempry cache
	new_key_data = tmp_gpg.export_keys(except_uid, minimal=True)
	if not GnuPG_stripped_UIDs_keyring.has_key(key_data):
		GnuPG_stripped_UIDs_keyring[key_data] = {}
	GnuPG_stripped_UIDs_keyring[key_data][except_uid] = new_key_data
	
	# drop temporary dir
	recursive_rm(tmp_gpghome)
	return new_key_data

def gpg_export_pubkey(gpg_uid):
	"""
	Returns the ascii-armoured representation (without BEGIN, END marks, or header)
	of the public key with the given email address. Removes all UIDs from the key
	except the selected one.
	"""
	
	assert gpg_uid[0] == '<' and gpg_uid[-1] == '>', "Need GPG UID in \"<name@example.net>\" format."
	
	data = gpg.export_keys(gpg_uid, minimal=True)
	if data == '':
		raise GnuPGError(_("Could not find public key for %s.") % (gpg_uid,))
	data = gpg_strip_all_uids(data, except_uid=gpg_uid)
	keydata = ''
	for line in data.split('\n'):
		if line.startswith('-'): pass
		elif line.startswith('='): pass  # skip checksum
		elif line == '': keydata = ''  # end of headers, data begins
		else: keydata += line
		if line.startswith('-----END'): break
	return keydata

def show_signature_info(*_x):
	valid = stck_sign_bad.get_data('signature-valid')
	dlg = gtk.MessageDialog(win_main, gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_INFO if valid else gtk.MESSAGE_WARNING)
	dlg.set_resizable(True)
	dlg.set_title(_("Signature info"))
	dlg.set_icon_name('mail-signed')
	set_dialog_icon_name(dlg, 'mail-signed-verified' if valid else 'dialog-warning')
	dlg.set_markup(glib.markup_escape_text(_("Digital signature is validated. See details below.") if valid else _("The digital signature on this email/attachment could not be validated. The email might be forged.")))
	if not valid:
		dlg.add_action_widget(gemlvtk.StockButton(stock=gtk.STOCK_DIALOG_WARNING, label=_("View anyway")), gtk.RESPONSE_APPLY)
	dlg.add_buttons(gtk.STOCK_CLOSE, gtk.RESPONSE_CLOSE)
	dlg.set_default_response(gtk.RESPONSE_CLOSE)
	
	carea = dlg.get_content_area()
	carea.pack_start(gemlvtk.ScrolledLabelView(stck_sign_bad.get_data('signature-info-text')), True, True)
	
	dlg.show_all()
	resp = dlg.run()
	if resp == gtk.RESPONSE_APPLY:
		load_part(stck_sign_bad.get_data('email-part'), filt=stck_sign_bad.get_data('filtering'), bypass_signature_verify=True)
	dlg.destroy()

def load_part(eml, filt=None, bypass_signature_verify=False):
	if eml is None: return
	clear_content(_("Loading failed"))
	panel_content.set_data('view-unfiltered', False)
	loaded_text = None
	
	stck_sign_good.hide()
	stck_sign_bad.hide()
	stck_sign_bad.set_data('email-part', eml)
	stck_sign_bad.set_data('filtering', filt)
	stck_sign_bad.set_data('signature-valid', None)
	stck_sign_bad.set_data('signature-info-text', 'n/a')
	btn_open2.set_sensitive(False)
	btn_save2.set_sensitive(False)
	gpg_msg = get_gpg_signed_data_from_mime_part(eml)
	gpg_signature_valid = None
	eml_data = Parts[get_part_iter(eml)][COL_PARTS_INFO]
	if eml_data.has_key('gpg'):
		gpg_info = eml_data['gpg']
		gpg_signature_valid = gpg_info['valid']
		gpg_signature_info = gpg_info['stderr']
	else:
		for parent_level, parent_part, parent_data in get_all_parent_parts(eml):
			if parent_data.has_key('gpg'):
				gpg_info = parent_data['gpg']
				gpg_signature_valid = gpg_info['valid']
				gpg_signature_info = gpg_info['stderr']
				break
			if parent_part.content_type == 'multipart/signed':
				sign_protocol = parent_part.header[HDR_CT].param['protocol'].decoded
				if parent_level == 1 and eml.content_type == sign_protocol:
					# This part is the signature itself. Skip signature verification.
					continue
				if sign_protocol:
					for sibling_part in parent_part.parts:
						if sibling_part.content_type == sign_protocol:
							sign_verify = verify_gpg_signature(gpg_msg, sibling_part.payload_decoded)
							gpg_signature_valid = sign_verify.valid
							gpg_signature_info = sign_verify.stderr
							break
				break
			else:
				# The MIME part we are about to show itself is not signed, but
				# included in a signed MIME part.
				# FIXME: it sometimes is not in a signed message: avoid extra as_string() call!
				gpg_msg = get_gpg_signed_data_from_mime_part(parent_part)
	if gpg_signature_valid is not None:
		stck_sign_bad.set_data('signature-valid', gpg_signature_valid)
		stck_sign_bad.set_data('signature-info-text', gpg_signature_info)
		if gpg_signature_valid:
			stck_sign_good.show()
		else:
			stck_sign_bad.show()
			if not bypass_signature_verify:
				return
	
	btn_open2.set_sensitive(True)
	btn_save2.set_sensitive(True)
	
	if eml.header['Content-Location'].nonempty:
		uri = urllib2.unquote(eml.header['Content-Location'].decoded)
		uri_esc = glib.markup_escape_text(uri)
		lbl_content_location.set_markup('%s <a href=\'%s\'>%s</a>' % (_("See Content here:"), uri_esc, uri_esc))
		lbl_content_location.show()
	else:
		lbl_content_location.hide()
	
	if filt is None:
		filt = get_filter_by_mime(eml.content_type.main, eml.content_type.sub)
	
	if filt is None:
		if eml.is_multipart() and all(x not in [None, ''] for x in [eml.preamble, eml.epilogue]):
			text = decode_readably('\n'.join([eml.preamble or '', eml.epilogue or '']), eml)
			set_content_text(text)
			loaded_text = text
		else:
			if eml.content_type.main == 'image':
				image_data = eml.payload_decoded
				exif_info = load_exif_metadata(image_data)
				loader = gtk.gdk.PixbufLoader()
				loader.write(image_data)
				loader.close()
				pxb = loader.get_pixbuf()
				pxb = exif_transforms(pxb, exif_info)
				panel_content_image.set_data('last-alloc', None)
				panel_content_image.set_data('pixbuf', pxb)
				panel_content_image.show()
#			elif eml.content_type.main == 'audio':
#				TODO
			else:
				label = _("Content type: %s%s%s") % (PMU_MIME, glib.markup_escape_text(eml.content_type), PMU_MIME_CLOSE)
				if eml.filename: label = (_("Filename: %s%s%s") % (PMU_NAME, glib.markup_escape_text(eml.filename), PMU_NAME_CLOSE)) + '\n' + label
				content_description = eml.header['Content-Description'].decoded
				if content_description:
					label += '\n' + _("Content Description by sender: %s%s%s") % (PMU_MIME, glib.markup_escape_text(content_description), PMU_MIME_CLOSE)
				label += '\n' + _("Size: %s") % (human_size(eml.size_decoded_approx),)
				lbl_right.set_markup(label)
				
				panel_btnbox.show()
				btn_open.show()
				btn_save.set_label(gtk.stock_lookup(gtk.STOCK_SAVE)[1])
			spanel_content.hide()
	else:
		cmd, args, binary = filt[:]
		if binary:
			content = get_content_any(eml)
		else:
			content = get_content_readably(eml)
		if cmd == '':
			panel_content.set_data('view-unfiltered', True)
			set_content_text(content) or clear_content(_("Loading failed"))
			loaded_text = content
		else:
			bufr = panel_content.get_buffer()
			bufr.set_text('')
			loaded_text = ''
			for s in pipereader(content, cmd, args):
				bufr.insert(bufr.get_end_iter(), s)
				loaded_text += s
			panel_content.set_sensitive(True)
		panel_btnbox.hide()
		panel_content_image.hide()
		spanel_content.show()
	if spanel_content.get_data('-loaded-part') != eml:
		spanel_content.get_vadjustment().set_value(0.0)
	spanel_content.set_data('-loaded-part', eml)
	if eml.content_type.main == 'text' and loaded_text is not None:
		spanel_content.set_data('last-loaded-text', loaded_text)

def on_window_configure(widget, event):
	if widget == win_main:
		winname = 'view'
	elif widget == win_comp:
		winname = 'composer'
	else:
		winname = widget.get_data('ui-unit-name')
		if winname is None:
			raise Exception("widget type unknown: %s" % repr(widget))
	for k, v in ('position/x', event.x), ('position/y', event.y), ('width', event.width), ('height', event.height):
		Props['ui/%s/%s' % (winname, k)] = v

def on_allocate_panel_content_image(wdg, alloc):
	pxb = wdg.get_data('pixbuf')
	if pxb is not None:
		lastalloc = wdg.get_data('last-alloc')
		if lastalloc is None or alloc.width != lastalloc.width or alloc.height != lastalloc.height:
			wdg.set_data('last-alloc', alloc)
			B = wdg.get_border_width()
			W, H = alloc.width - B, alloc.height - B
			w0, h0 = pxb.get_width(), pxb.get_height()
			w = w0
			h = h0
			if W < w:
				w = W
				h = h0 * w / w0
			if H < h:
				h = H
				w = w0 * h / h0
			b = 5+B*2
			pxb = pxb.scale_simple(w - b, h - b, gtk.gdk.INTERP_BILINEAR)
			wdg.children()[0].set_from_pixbuf(pxb)

def load_exif_metadata(imagedata):
	if pyexiv2 is None:
		return None
	metadata = pyexiv2.ImageMetadata.from_buffer(imagedata)
	metadata.read()
	return metadata

def exif_transforms(pxb, metadata):
	"""transform an image according to the EXIF metadata"""
	if metadata is None:
		return pxb
	
	if 'Exif.Image.Orientation' in metadata.exif_keys:
		orientation = metadata['Exif.Image.Orientation'].value
		# flip-flop:
		if orientation in [2, 4]:
			# mirror on the vertical axis
			pxb = pxb.flip(horizontal=False)
			orientation -= 1
		elif orientation in [5, 7]:
			# mirror on the horizontal axis
			pxb = pxb.flip(horizontal=True)
			orientation += 1
		# rotation:
		rotation = None
		if orientation == 6:
			# rotate 90° CW
			rotation = gtk.gdk.PIXBUF_ROTATE_CLOCKWISE
		elif orientation == 3:
			# rotate 180° CW
			rotation = gtk.gdk.PIXBUF_ROTATE_UPSIDEDOWN
		elif orientation == 8:
			# rotate 270° CW
			rotation = gtk.gdk.PIXBUF_ROTATE_COUNTERCLOCKWISE
		if rotation is not None:
			pxb = pxb.rotate_simple(rotation)
	
	return pxb

def resize_panel_view_header(wdg, rect=None):
	if not panel_view_header.get_data('all-headers'):
		if rect is None: rect = wdg.get_allocation()
		h, v = panel_view_header.get_padding()
		panel_view_header.set_size_request(rect.width - h - 4, -1)

def get_header_links(s, schemata):
	"""
	parse "Link:"-type headers and return parsed links' URI (and comments) that schema is in 
	schemata parameter or '*' is in schemata.
	returns list of dicts. keys in each dict:
	 - uri
	 - scheme
	 - comment (if any)
	 in case of "mailto:..." link:
	 - to: "To" recipients list
	 - cc: "Cc" recipients list
	 - bcc: "Bcc" recipients list
	 - subject (if any)
	 - body (if any)
	 - other accepted mailto fields (if any)
	"""
	# RFC2369
	links = []
	linkdefs = re.findall('(?:\(([^)]+)\))?\s*<([^>]+)>\s*(?:\(([^)]+)\))?', s)
	if len(linkdefs) == 0:
		# workaround for poorly behaved mail lists
		linkdefs = re.findall('^()\s*(\S+)\s*(.*)', s)
	for linkdef in linkdefs:
		comment = linkdef[0] or linkdef[2]
		uri = linkdef[1]
		uriparts = urlparse.urlsplit(uri)
		if '*' in schemata or uriparts.scheme.lower() in schemata:
			link = {}
			link['uri'] = uri
			link['scheme'] = uriparts.scheme.lower()
			link['comment'] = comment
			if link['scheme'] == 'mailto':
				for field_name in MultiRecipientsMailtoFields:
					link[field_name] = []
				link['to'] = getaddresslines([decode_mimetext(urlparse.unquote(uriparts.path))])
				for field_name, field_values in urlparse.parse_qs(uriparts.query).iteritems():
					field_name = field_name.lower()
					if field_name in AcceptableMailtoFields and len(field_values) > 0:
						field_values = [decode_mimetext(v) for v in field_values]
						if field_name in MultiRecipientsMailtoFields:
							# RFC2368
							# there may be multiple fields of the same kind (eg. "?cc=addr1&cc=addr2")
							# and each of them may hold multiple addresses delimited by comma (eg. "addr1%2C%20addr2")
							field_values = getaddresslines(field_values)
						if field_name in MultiRecipientsMailtoFields:
							link[field_name].extend(field_values)
						else:
							link[field_name] = field_values[0]
			links.append(link)
	return links

def parse_mailto(s):
	l = get_header_links('<'+s+'>', schemata=['mailto'])
	if len(l) > 0: return l[0]
	warnx(_("Can not parse mailto link: '%s'") % (s))
	return {}

def load_gravatar(addr, container):
	if not isinstance(addr, str): return
	url_templ = Props['avatar/url_template'] or 'https://www.gravatar.com/avatar/{email_md5}?default=404&size=64&rating=G'
	url = url_templ.format(email=addr.lower(), email_md5=hashlib.md5(addr.lower()).hexdigest())
	try:
		web = urllib2.urlopen(url)
	except urllib2.HTTPError:
		pass
	else:
		loader = gtk.gdk.PixbufLoader()
		try:
			loader.write(web.read())
			loader.close()
		except glib.GError as e:
			if e.code != 3:   # 'Unrecognized image file format'
				raise
		else:
			pxb = loader.get_pixbuf()
			img = container.children()[0]
			img.set_from_pixbuf(pxb)
			container.show_all()

def get_listaddressline_main():
	try:
		# Assuming there is only one list address.
		# Take the first 'To' parameter from the first mailto link.
		listaddressline = get_header_links(','.join(TheEmail.headers['List-Post'].encoded), schemata=['mailto'])[0]['to'][0]
	except (IndexError, KeyError):
		listaddressline = AddressLine('')
	return listaddressline

def get_headers_markup(eml):
	display_lines = []
	display_headers = [
		"Return-Path",
		"X-X-Sender",
		"X-Sender",
		"Sender",
		"From",
		"Organization",
		"Reply-To",
		"Importance",
		"Priority",
		"X-Priority",  # @notranslate
		"X-MSMail-Priority",  # @notranslate
		"To",
		"Cc",
		"Date",
		"Reply-By",
		"Expires",
		"X-Spam",  # @notranslate
	]
	from_addresses = extract_email_addresses_from_headers('From', eml)
	# if there is proper sender recorded in the email then do not show the envelope sender 
	# (ie. "mail from" sender, conventionally recorded in Return-Path header)
	for h in 'From', 'Sender', 'X-Sender', 'X-X-Sender':
		if h in eml.headers:
			display_headers.remove('Return-Path')
			break
	
	for hname in display_headers:
		hvals_mu = []
		for hval in eml.headers[hname].decoded:
			if hname != 'From' and hname in OriginatorHeaders:
				# Do not display Sender or Reply-To fields if they equal to From.
				addr = AddressLine(hval).email
				if addr in from_addresses: continue
			if hname in RecipientHeaders or hname in OriginatorHeaders:
				list_mu = []
				for al in getaddresslines([hval]):
					if al.realname:
						mu = '%s <a href=\'mailto:%s\'>%s</a>' % (
							glib.markup_escape_text(al.realname),
							urllib2.quote(al.addressline.encode('utf-8')),
							glib.markup_escape_text(al.email),
						)
					else:
						mu = '<a href=\'mailto:%s\'>%s</a>' % (
							urllib2.quote(al.email.encode('utf-8')),
							glib.markup_escape_text(al.email),
						)
					list_mu.append(mu)
				hval_mu = ', '.join(list_mu)
			elif hname in DateTimeHeaders:
				# Display Date field in local timezone.
				try:
					timestamp = email.utils.mktime_tz(email.utils.parsedate_tz(hval))
				except TypeError:
					timestamp = None
				else:
					hval = email.utils.formatdate(timestamp, True)
				hval_mu = glib.markup_escape_text(hval)
				if timestamp is not None and timestamp < time.time():
					wrn = None
					if hname == 'Reply-By':
						wrn = _("Overdue")
					elif hname == 'Expires':
						wrn = _("(Expired)")
					if wrn is not None:
						hval_mu += ' ' + PMU_WARN + wrn + PMU_WARN_CLOSE
			else:
				hval_mu = glib.markup_escape_text(hval)
			
			if hname == 'Importance' or hname.find('Priority')>-1:
				hval_lc = hval.lower()
				if hval_lc == 'urgent' or hval_lc.find('high')>-1 or re.search('^[12]', hval):
					# Show urgent, high priority headers emphasized.
					hval_mu = PMU_WARN + glib.markup_escape_text(hval) + PMU_WARN_CLOSE
					win_main.set_icon_name('mail-mark-important')
					stck_imp.show()
				elif hval_lc == 'non-urgent' or hval_lc.find('low')>-1 or re.search('^[45]', hval):
					stck_unimp.show()
				if not UserConfig.show_importance_headers:
					hval_mu = None
			
			if hname == 'X-Spam':
				if re.search(r'\b(no|undefined)\b', hval):
					pass
				else:
					stck_spam.show()
			
			if hval_mu is not None and len(hval_mu):
				hvals_mu.append(hval_mu)
		if len(hvals_mu):
			display_lines.append(PMU_HEAD + _(hname) + PMU_HEAD_CLOSE + ': ' + ', '.join(hvals_mu))
	return '\n'.join(display_lines)

def get_filters_by_mime(main, sub, all=True):
	filters = []
	for m, s, marks, cmd, args in cfgparser('filters', regex='^\s*([^;#][^\s/]*)/(\S+)\s+([!\$]*)(\S+)\s*(.+)?', splitgroups=[5]):
		if wildcardmatch(main, m) and wildcardmatch(sub, s):
			isbin = marks.find('!')>-1
			isshell = marks.find('$')>-1
			e = None
			if cmd == '-':
				e = ('', None, isbin)
			else:
				if isshell:
					e = ('sh', ['-c', ' '.join([cmd]+args)], isbin)
				else:
					if which(cmd):
						e = (cmd, args, isbin)
			if e is not None:
				if all:
					filters.append(e)
				else:
					return e
	if all:
		return filters
	return None

def get_filter_by_mime(main, sub):
	return get_filters_by_mime(main, sub, all=False)

def sighandler(sign, frame):
	if sign == signal.SIGTERM:
		glib.idle_add(sig_term, priority=glib.PRIORITY_HIGH)

def sig_term():
	act_quit()
	return False

def act_quit():
	if win_comp.get_visible():
		act_close_edit()
	if win_comp.get_visible():
		return True
	win_main.hide()
	win_comp.hide()
	gtk.main_quit()
	return False

def act_close_edit():
	if not win_comp.get_data('email-sent') and not win_comp.get_data('is-saved'):
		if not question(_("Message is being edited, not saved.\nClose anyway?"), (None, gtk.STOCK_QUIT if cliArgs.compose else gtk.STOCK_CLOSE), (_("Continue Editing"), gtk.STOCK_EDIT)):
			return True
	win_comp.hide()
	glib.source_remove(Timers['auto-save-draft'])
	remove_old_draft()
	if cliArgs.compose:
		win_main.hide()
		gtk.main_quit()
		return False
	else:
		toggle_rqdn.set_sensitive(True)
		composer_text_buffer.delete_namedrange('user_signature')
		composer_text_buffer.delete_namedrange('quoted_message')
		return True

def act_button(func):
	if type(func) != type(()):
		func = (func,)
	if func[0] is not None:
		func[0](*func[1:])

def on_click_button(btn, func):
	act_button(func)
	return False

def on_press_button(btn, evt, func):
	if evt.type == gtk.gdk.BUTTON_PRESS:
		if evt.button == 3 or (evt.button == 1 and evt.state & gtk.gdk.SHIFT_MASK):
			act_button(func)
	return False

def open_comp_hdr_menu(widget, event):
	if event.button == 3 or (event.button == 1 and event.state & gtk.gdk.SHIFT_MASK):
		menu_add_header.popup(None, None, None, event.button, event.time)
		return True

def act_comp_hdr_menuitem(mi, hname=None):
	if hname is None:
		hname = mi.get_data('chname')
	if hname == '':
		menuitem_all_comp_hdr.set_active(True)
	on = mi.active if isinstance(mi, gtk.CheckMenuItem) else None
	box = add_composer_header__direct(hname)
	if on == False:
		box.cancel()
	else:
		glib.idle_add(box.scrollfocus, priority=glib.PRIORITY_DEFAULT_IDLE)
	return True

def act_all_comp_hdr(mi):
	show_advanced_comp_hdr(mi.active)

def act_tgl_comp_hdr():
	on = menuitem_all_comp_hdr.get_active()
	menuitem_all_comp_hdr.set_active(not on)
	show_advanced_comp_hdr(not on)

def show_advanced_comp_hdr(show=True):
	clear_composer_headers('', '')
	for n in range(0, len(panel_comp_header.children())):
		box = panel_comp_header.children()[n]
		if box.hntype == compose_header_box.HNTYPE_CUSTOM:
			if show:
				box.show()
			else:
				box.hide()

def add_composer_header__direct(hname, hval=None, manual_call=True):
	box = None
	for thisbox in panel_comp_header.children():
		if thisbox.hntype == compose_header_box.HNTYPE_LABEL and thisbox.name == hname:
			box = thisbox
			if hval: box.value = hval
			break
	if box is None:
		# TODO: revise all add_composer_header__direct/add_composer_header/compose_header_box calls, let hval always not None
		if hval is None: hval = ''
		box = compose_header_box(hname, hval)
		panel_comp_header.pack_start(box, False, True)
		if box.hntype == compose_header_box.HNTYPE_MENU:
			for n in range(len(panel_comp_header.children())):
				if panel_comp_header.children()[n].hntype == compose_header_box.HNTYPE_CUSTOM:
					panel_comp_header.reorder_child(box, n)
					break
				# Ignore every 2nd child.
				n += 1
	if manual_call: box.focus()
	box.show_all()
	return box

def add_composer_header(hname, hval=None, manual_call=True):
	box = add_composer_header__direct(hname, hval, manual_call)
	box.tick_my_menuitem(1)
	return box

def add_composer_headers(hname, hvals, manual_call=True):
	for hval in hvals:
		add_composer_header(hname, hval, manual_call)

def reset_composer_headers(hname, hvals, manual_call=True):
	clear_composer_headers(hname)
	for hval in hvals:
		add_composer_header(hname, hval, manual_call)

def set_composer_header(hname, hval):
	for hbox in panel_comp_header.children():
		if hbox.name == hname:
			hbox.value = hval
			return hbox
	return add_composer_header(hname, hval)

def clear_composer_headers(hname, content=None):
	for box in panel_comp_header.children():
		if (hname is None or box.name == hname) and (content is None or content == box.value):
			box.cancel(manual=False)

def composer_maintain_references_headers():
	references = TheEmail.header[HDR_REF].decoded
	messageid = TheEmail.header[HDR_MID].decoded
	if messageid:
		if references:
			references = references + ' ' + messageid
		else:
			references = messageid
	if references:
		add_composer_header(HDR_REF, references, manual_call=False)

def composer_append_to_list_header(hname, hvals, delimiter=' '):
	hval = delimiter.join(filter(lambda x: x is not None, hvals))
	headers = get_composer_headers(hname)
	if len(headers) == 0:
		reset_composer_headers(hname, [hval])
	else:
		headers[-1] = delimiter.join([headers[-1], hval])
		reset_composer_headers(HDR_REF, headers, manual_call=False)

def composer_substract_from_list_header(hname, hvals, delimiter=' '):
	headers = get_composer_headers(hname)
	for idx in reversed(range(len(headers))):
		newvalue = []
		for word in headers[idx].split(delimiter):
			if word in hvals:
				hvals.remove(word)  # FIXME: is it needed??
			else:
				newvalue.append(word)
		headers[idx] = delimiter.join(newvalue)
	reset_composer_headers(hname, headers, manual_call=False)

class compose_header_box(gtk.HBox):
	HNTYPE_LABEL, HNTYPE_MENU, HNTYPE_CUSTOM = range(3)
	ICON_POS_VALIDATION = 1
	
	def __init__(self, chname, val, hntype=None):
		if isinstance(val, AddressLine): val = str(val)
		assert isinstance(chname, str), 'chname is %s not str.'%(repr(type(chname)),)
		assert isinstance(val, str) or isinstance(val, unicode), 'val is %s not str nor unicode.'%(repr(type(val)),)
		plus = True
		minus = True
		
		super(self.__class__, self).__init__(False, 2)
		if hntype is None:
			if chname in SenderHeaders:
				hntype = self.HNTYPE_LABEL
			elif chname in RecipientHeaders:
				hntype = self.HNTYPE_MENU
			else:
				hntype = self.HNTYPE_CUSTOM
		
		self.hntype = hntype
		if self.hntype == self.HNTYPE_CUSTOM:
			self.wdg_name = gtk.combo_box_entry_new_with_model(UnionHeadersStore, 0)
			self.wdg_name.connect('changed', self.on_name_changed)
		elif self.hntype == self.HNTYPE_MENU:
			self.wdg_name = gtk.Button()
			self.wdg_name.set_relief(gtk.RELIEF_NONE)
			self.wdg_name.connect('button-release-event', self.popup_rcpt_menu)
			self.wdg_name.connect('button-press-event', self.propagate_button_press_event)
		elif self.hntype == self.HNTYPE_LABEL:
			plus = False
			self.wdg_name = gtk.Label()
		self.pack_start(self.wdg_name, False, True)
		
		self.wdg_value = gtk.Entry()
		self.pack_start(self.wdg_value, True, True)
		self.wdg_value.connect('changed', self.on_value_changed)
		self.wdg_value.connect('key-press-event', self.on_keypress)
		self.wdg_value.connect('populate-popup', self.on_populate_text_context_menu)
		self.completer = gtk.EntryCompletion()
		self.wdg_value.set_completion(self.completer)
		self.completer.set_model(gtk.ListStore(str, str, bool, int))
		self.completer.set_minimum_key_length(0)
		col_text, col_markup, col_ismatch, col_order = 0, 1, 2, 3
		self.completer.set_match_func(self.autocomplete_matcher, {'text': col_text, 'markup': col_markup, 'is_match': col_ismatch, 'order': col_order})
		self.completer.set_text_column(col_text)
		self.completer.set_attributes(self.completer.get_cells()[0], markup=col_markup)
		self.completer.get_model().set_sort_column_id(col_order, gtk.SORT_ASCENDING)
		self.completer.set_popup_single_match(True)
		
		self.btn_datetime = gemlvtk.StockButton('', 'x-office-calendar', icon_size=gtk.ICON_SIZE_MENU)
		self.btn_datetime.set_tooltip_text(_("Pick date and time"))
		self.btn_datetime.set_relief(gtk.RELIEF_NONE)
		self.pack_start(self.btn_datetime, False, False)
		self.btn_datetime.connect('clicked', self.pick_datetime)
		self.btn_datetime.connect('button-press-event', self.propagate_button_press_event)
		
		self.btn_suggestions = gemlvtk.StockButton('', gtk.STOCK_DIALOG_INFO, icon_size=gtk.ICON_SIZE_MENU)
		self.btn_suggestions.set_tooltip_text(_("Suggestions…"))
		self.btn_suggestions.set_relief(gtk.RELIEF_NONE)
		self.pack_start(self.btn_suggestions, False, False)
		self.btn_suggestions.connect('clicked', self.open_suggestions_panel)
		self.btn_suggestions.connect('button-press-event', self.propagate_button_press_event)
		
		if plus:
			self.btn_add = gemlvtk.StockButton('', gtk.STOCK_ADD, icon_size=gtk.ICON_SIZE_MENU)
			self.pack_start(self.btn_add, False, False)
			self.btn_add.set_relief(gtk.RELIEF_NONE)
			self.btn_add.connect('clicked', self.duplicate)
			self.btn_add.connect('button-press-event', self.propagate_button_press_event)
		if minus:
			self.btn_del = gemlvtk.StockButton('', gtk.STOCK_REMOVE, icon_size=gtk.ICON_SIZE_MENU)
			self.btn_del.set_relief(gtk.RELIEF_NONE)
			self.pack_start(self.btn_del, False, False)
			self.btn_del.connect('clicked', self.cancel)
			self.btn_del.connect('button-press-event', self.propagate_button_press_event)
		
		self.name = chname
		self.value = val
		self.readonly = False
		self.removable = True
	
	def autocomplete_matcher(self, completion, userinput, treeiter, column):
		ac_model = completion.get_model()
		ac_last_userinput = self.wdg_value.get_data('autocomplete-computed-for')
		if ac_last_userinput is None or ac_last_userinput != userinput:
			self.wdg_value.set_data('autocomplete-computed-for', userinput)
			# Compute auto completion hits and sort order
			if fuzzywuzzy is not None:
				if userinput == '':
					if len(ac_model) <= AutocompletionListSizeLimitOnEmptyInput:
						for item in ac_model:
							item[column['is_match']] = True
							item[column['order']] = 0
				else:
					hits = fuzzywuzzy.process.extract(userinput.decode('utf-8'), [item[column['text']] for item in ac_model], limit=None, scorer=fuzzywuzzy.fuzz.token_set_ratio)
					hits = dict(hits)
					# Highlight only somewhat meaningful chars
					userinput_norm = re.sub('[^\w.@]', '', userinput, flags = re.IGNORECASE | re.UNICODE)
					for item in ac_model:
						text = item[column['text']]
						item[column['is_match']] = text in hits.keys() and hits[text] > 0
						item[column['order']] = 100 - hits.get(text, 0)
						if hits.get(text):
							# Generate markup string highlighting the matched chars
							cur_does_match = False
							end_string = ''
							substr = ''
							for c in text:
								if c in userinput_norm and not cur_does_match:
									end_string += glib.markup_escape_text(substr)
									substr = ''
								elif c not in userinput_norm and cur_does_match:
									end_string += PMU_AUTOCOMPLETION_MATCH_CHAR % (glib.markup_escape_text(substr),)
									substr = ''
								cur_does_match = c in userinput_norm
								substr += c
							if substr != '':
								if cur_does_match:
									end_string += PMU_AUTOCOMPLETION_MATCH_CHAR % (glib.markup_escape_text(substr),)
								else:
									end_string += glib.markup_escape_text(substr)
							item[column['markup']] = end_string
						else:
							item[column['markup']] = glib.markup_escape_text(text)
			else:
				for item in ac_model:
					text = item[column['text']]
					item[column['order']] = text.find(userinput)
		
		if fuzzywuzzy is not None:
			return ac_model.get_value(treeiter, column['is_match'])
		else:
			return ac_model.get_value(treeiter, column['order']) != -1
	
	def open_suggestions_panel(self, wdg):
		assert self.name in SenderHeaders
		
		win = AddressBrowser(modal_window=True, single_select=True)
		win.set_title(_("Contact Address Chooser"))
		win.set_transient_for(win_comp)
		win.button_edit.hide()
		win.connect('items-add', lambda addressbrowser, items: setattr(self, 'value', items[0]))
		
		# load those (self-) addresses from the participants database which are in correspondence with the current recipients
		recipients = get_composer_all_recipients_emails()
		participants = query_participants(recipients)
		correspondence = dict([(x['our_address'], x) for x in participants])
		def load_one(al, correspondence):
			emailaddr = AddressLine(MimeDecoded(al)).email
			if emailaddr in correspondence.keys():
				if 'our_address_lines' not in correspondence[emailaddr]: correspondence[emailaddr]['our_address_lines'] = {}
				correspondence[emailaddr]['our_address_lines'][al] = 1
		gemlv.addressbook.load(callback = load_one, userdata = correspondence, gettext = _)
		suggestions = correspondence.values()
		suggestions.sort(key = lambda x: (x['total_correspondences'], x['our_address']), reverse = True)
		for suggestion in suggestions:
			for our_address_line in suggestion.get('our_address_lines', {suggestion['our_address']: 1}).keys():
				label = '%s <small>(%s %s)</small>' % (
					glib.markup_escape_text(our_address_line),
					_("%d exchange(s) with:") % suggestion['total_correspondences'],
					glib.markup_escape_text(', '.join(suggestion['their_addresses']))
				)
				win.addresslist_model.append([our_address_line, label])
		
		return True
	
	def on_keypress(self, wdg, evt):
		if evt.keyval == gtk.gdk.keyval_from_name('Down'):
			try:
				if wdg.get_text() == '' and len(wdg.get_completion().get_model()) <= AutocompletionListSizeLimitOnEmptyInput:
					# Trigger auto completion popup. [hack]
					wdg.emit('changed')
					return True
			except AttributeError:
				pass
		return False
	
	def propagate_button_press_event(self, w, evt):
		self.parent.parent.parent.emit('button-press-event', evt)
	
	def pick_datetime(self, w):
		prompt_datetime(self.wdg_value)
	
	def showhide_pick_buttons(self):
		if self.name in DateTimeHeaders:
			self.btn_datetime.show()
		else:
			self.btn_datetime.hide()
		if self.name in SenderHeaders:
			self.btn_suggestions.show()
		else:
			self.btn_suggestions.hide()
	
	def on_populate_text_context_menu(self, entry, menu):
		if self.name in AddressbookHeaders:
			pos = 0
			mi = gemlvtk.StockMenuItem(icon_name='contact-new', label=_("Add to addressbook"))
			mi.connect('activate', self.add_value_to_addressbook)
			menu.insert(mi, pos)
			menu.show_all()
	
	def add_value_to_addressbook(self, *_x):
		act_add_to_addressbook_manual(AddressLine(MimeDecoded(self.value)))
	
	def set_autocomplete_list(self, autocomplete_list):
		ac_model = self.completer.get_model()
		ac_model.clear()
		for item in autocomplete_list:
			ac_model.append([item, glib.markup_escape_text(item), False, 0])
		self.wdg_value.remove_data('autocomplete-computed-for')
	
	
	def point_out(self):
		if self.hntype == self.HNTYPE_CUSTOM:
			menuitem_all_comp_hdr.set_active(True)
		self.focus()
		glib.idle_add(self.scrollfocus, priority=glib.PRIORITY_DEFAULT_IDLE)
	
	def popup_rcpt_menu(self, wdg, evt):
		if evt.button == 1:
			wdg.set_relief(gtk.RELIEF_NORMAL)
			mnu = gtk.Menu()
			mnu.connect('deactivate', self.popup_rcpt_menu_disappear, wdg)
			for chname in RecipientHeaders:
				mi = gtk.MenuItem(label=_(chname))
				mi.set_data('name', chname)
				mi.connect('activate', self.popup_rcpt_menuitem_activated, wdg)
				mnu.append(mi)
			mnu.show_all()
			mnu.popup(None, None, self.bottomleft, evt.button, evt.time, wdg)
			return True
		return False
	
	def popup_rcpt_menuitem_activated(self, mi, wdg):
		self.name = mi.get_data('name')
		self.popup_rcpt_menu_disappear(mi.parent, wdg)
	
	def popup_rcpt_menu_disappear(self, mnu, wdg):
		wdg.set_relief(gtk.RELIEF_NONE)
		self.focus()
	
	def bottomleft(self, _mnu, wdg):
		"returns the widget's bottom-left corner's coordinates"
		X, Y = self.window.get_origin()
		x, y, w, h = wdg.get_allocation()
		mx = X + x
		my = Y + y + h
		return (mx, my, True)
	
	def show_all(self):
		super(self.__class__, self).show_all()
		if self.hntype == self.HNTYPE_CUSTOM and not menuitem_all_comp_hdr.get_active():
			self.hide()
		self.showhide_pick_buttons()
	
	def duplicate(self, evtwdg=None):
		newbox = self.__class__(self.name, '', hntype=self.hntype)
		self.parent.pack_start(newbox, False, True)
		newbox.show_all()
		newbox.focus()
		for n in range(0, len(self.parent.children())):
			if self.parent.children()[n] == self:
				self.parent.reorder_child(newbox, n)
	
	def cancel(self, evtwdg=None, manual=True):
		if self.name and self.value:
			set_unsaved()
		if self.hntype == self.HNTYPE_LABEL:
			self.hide()
			self.tick_my_menuitem(0)
			if not manual:
				self.value = ''
		else:
			if manual and self.hntype == self.HNTYPE_MENU:
				n = 0
				for x in self.parent.children():
					if x.hntype == self.HNTYPE_MENU: n += 1
					if n > 1: break
				if n < 2:
					self.value = ''
					return False
			self.parent.remove(self)
			update_composer_toolbar_toggle_buttons()
		if self.name in RecipientHeaders:
			glib.idle_add(update_addressbook_highlights, priority=glib.PRIORITY_DEFAULT_IDLE)
		update_composer_status_message()
	
	def tick_my_menuitem(self, on):
		for mi in menu_add_header.children():
			if mi.get_data('chname') == self.name:
				mi.set_active(on)
				break
	
	def focus(self):
		if not self.wdg_value.has_focus():
			self.wdg_value.grab_focus()
			self.wdg_value.set_position(-1)
	
	def scrollfocus(self):
		if self.get_visible():
			scrwin = self.parent.parent
			cntnr = scrwin.child
			vadj = scrwin.get_vadjustment()
			wdg = win_comp.get_focus()
			
			if wdg is not None:
				wleft, wtop = wdg.translate_coordinates(cntnr, 0, 0)
				wbottom = wtop + wdg.get_allocation().height
				top = vadj.value
				bottom = top + vadj.page_size
				if wtop < top:
					vadj.value = wtop
				elif wbottom > bottom:
					vadj.value = wbottom - vadj.page_size
	
	@property
	def name(self):
		if self.hntype == self.HNTYPE_CUSTOM:
			it = self.wdg_name.get_active_iter()
			if it is not None:
				ret = self.wdg_name.get_model().get_value(it, 0)
			else:
				ret = self.wdg_name.children()[0].get_text()
		else:
			ret = self.wdg_name.get_data('name')
		if ret is not None:
			ret = gemlv.email.Header(ret).name
		return ret
	
	@name.setter
	def name(self, newname):
		newname = gemlv.email.Header(newname).name
		self.wdg_name.set_data('name', newname)
		if self.hntype == self.HNTYPE_CUSTOM:
			self.wdg_name.children()[0].set_text(newname)
		else:
			self.wdg_name.set_label(_(newname))
		self.on_name_changed()
	
	def on_name_changed(self, _x=None):
		name = self.name
		self.showhide_pick_buttons()
		if name in HeaderValidators.keys():
			self.validators = HeaderValidators[name]
		else:
			self.validators = None
		
		if name in AddressbookHeaders:
			self.set_autocomplete_list(gemlv.addressbook.get_full())
		elif name in AutocompletionHeaders.keys():
			self.set_autocomplete_list(AutocompletionHeaders[name])
		self.on_changed()
	
	@property
	def value(self):
		return self.wdg_value.get_text()
	
	@value.setter
	def value(self, newvalue):
		self.wdg_value.set_text(newvalue)
	
	def on_value_changed(self, entry=None):
		if entry is None: entry = self.wdg_value
		
		# indicate field validity
		bg_invalid = gtk.gdk.Color('#FFA4A4')
		bg_normal = entry.get_data('bg-normal')
		if not bg_normal:
			bg_normal = entry.get_style().base[gtk.STATE_NORMAL]
			entry.set_data('bg-normal', bg_normal)
		valid = self.validate()
		if valid == VALIDATION_RESULT_PASS:
			entry.modify_base(gtk.STATE_NORMAL, bg_normal)
			entry.set_icon_from_stock(self.ICON_POS_VALIDATION, None)
		else:
			if valid == VALIDATION_RESULT_INVALID:
				entry.modify_base(gtk.STATE_NORMAL, bg_invalid)
				entry.set_icon_from_stock(self.ICON_POS_VALIDATION, gtk.STOCK_STOP)
				entry.set_icon_tooltip_text(self.ICON_POS_VALIDATION, _("Invalid input"))
			else:
				entry.modify_base(gtk.STATE_NORMAL, bg_normal)
				entry.set_icon_from_stock(self.ICON_POS_VALIDATION, gtk.STOCK_DIALOG_QUESTION)
				entry.set_icon_tooltip_text(self.ICON_POS_VALIDATION, _("Strange input; maybe double check"))
			self.point_out()
		
		self.on_changed()
		return False
	
	def validate(self, fail_on_empty=False):
		if not self.validators:
			return VALIDATION_RESULT_PASS
		text = self.value
		result = True
		for validation_rule in self.validators:
			if validation_rule.has_key('require'):
				result = bool(re.search(validation_rule['require'], text))
			elif validation_rule.has_key('require-repetative'):
				remainder = text
				while True:
					m = re.search(validation_rule['require-repetative'], remainder)
					if m is not None:
						remainder = remainder[m.end():]
						if remainder == '':
							break
					else:
						result = False
						break
				if remainder != '':
					result = False
			if not result:
				break
		if result:
			return VALIDATION_RESULT_PASS
		else:
			if not fail_on_empty and self.value == '':
				return VALIDATION_RESULT_PASS
			return validation_rule.get('fail-result', VALIDATION_RESULT_INVALID)
	
	def on_changed(self):
		"runs when either the name or the value has been changed"
		update_composer_toolbar_toggle_buttons()
		if self.name in RecipientHeaders:
			glib.idle_add(update_addressbook_highlights, priority=glib.PRIORITY_DEFAULT_IDLE)
		set_unsaved()
		update_composer_status_message()
	
	@property
	def readonly(self):
		return not self.wdg_value.get_sensitive()
	
	@readonly.setter
	def readonly(self, newreadonly):
		self.wdg_name.set_sensitive(not newreadonly)
		self.wdg_value.set_sensitive(not newreadonly)
	
	@property
	def validators(self):
		return self._validators
	
	@validators.setter
	def validators(self, newvalidators):
		self._validators = newvalidators
		self.on_value_changed()
	
	@property
	def removable(self):
		return self.btn_del.get_sensitive()
	
	@removable.setter
	def removable(self, newremovable):
		self.btn_del.set_sensitive(newremovable)


def act_add_to_addressbook_manual(address_line):
	try:
		gemlv.addressbook.add(section='gemlv.manual', address_line=address_line)
	except Exception as e:
		save_exception_traceback(e, traceback.format_exc())
		display_error(e)
		raise
	else:
		display_info_box_async(_("Added to addressbook"))

def query_participants(recipients):
	participants = []
	if sqlite3 is not None:
		with sqlite3.connect(os.path.expanduser('~/Mail/.participants.db')) as db:
			questionmarks = ','.join(['?'] * len(recipients))
			separator = ' '
			cursor = db.execute("""SELECT our.address AS our_address,
				sum(times) AS total_correspondences,
				GROUP_CONCAT(their.address, ?) AS their_addresses
				FROM contact c LEFT JOIN address our ON c.aid_our=our.aid LEFT JOIN address their ON c.aid_their=their.aid
				WHERE their.address IN (%s) AND their.address != ''
				GROUP BY our_address""" % (questionmarks,), [separator] + recipients)
			for row in cursor:
				our_address, total_correspondences, their_addresses = row[:]
				their_addresses = their_addresses.split(separator)
				participants.append({
					'our_address': our_address, 
					'total_correspondences': total_correspondences, 
					'their_addresses': their_addresses,
				})
	return participants

def prompt_datetime(entry):
	"""
	prompt_datetime(entry)
	
		displays a message dialog with a date-time picker and writes picked date-time in entry
	"""
	def select_datetime(ts=None):
		y, m, d, x, x, x, x, x, x = time.localtime(ts)
		calendar.select_month(m-1, y)
		calendar.select_day(d)
		clock.select_time(ts)
	dlg = gtk.MessageDialog(gemlvtk.get_current_window(), gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_OTHER, gtk.BUTTONS_OK_CANCEL, _("Select Date and Time in local TimeZone"))
	dlg.set_title(_("Pick date and time"))
	calendar = gtk.Calendar()
	clock = gemlvtk.Clock()
	dt = email.utils.parsedate_tz(entry.get_text())
	if dt is not None:
		select_datetime(email.utils.mktime_tz(dt))
	cbox = dlg.get_content_area()
	cbox.pack_start(calendar, True, True)
	cbox.pack_start(clock, True, True)
	btn_now = gemlvtk.StockButton(_("Now"), gtk.STOCK_JUMP_TO)
	btn_now.connect('clicked', lambda x: select_datetime())
	abox = dlg.get_action_area()
	abox.pack_start(btn_now, False, False)
	dlg.show_all()
	resp = dlg.run()
	if resp == gtk.RESPONSE_OK:
		y, m, d = calendar.get_date()
		H, M, S = clock.get_time()
		entry.set_text(email.utils.formatdate(time.mktime((y, m+1, d, H, M, S, -1, -1, -1)), True))
	dlg.destroy()

def get_composer_headerboxes(search_hname):
	"""
	get_composer_headerboxes(search_hname)
	
		finds those compose_header_box objects of which name 
		- is in search_hname (if search_hname is list)
		- is search_hname (if search_hname is str)
		- is anything (if search_hname is None)
		
		do not count hidden compose_header_box objects which represent sender (From, Organization, Reply-To, …)
	"""
	search_hnames = None
	if search_hname is not None:
		if type(search_hname) == list:
			search_hnames = list([x.lower() for x in search_hname])
		else:
			search_hnames = [search_hname.lower()]
	hlist = []
	for hbox in panel_comp_header.children():
		if hbox.get_visible() or hbox.name.lower() not in [x.lower() for x in SenderHeaders]:
			if search_hname is None:
				hlist.append(hbox)
			elif hbox.name.lower() in search_hnames:
				hlist.append(hbox)
	return hlist

def get_composer_headers(search_hname):
	hlist = []
	for hbox in get_composer_headerboxes(search_hname):
		if search_hname is None:
			hlist.append((hbox.name, hbox.value))
		else:
			hlist.append(hbox.value)
	return hlist

def get_composer_header_last(hname):
	hdrs = get_composer_headers(hname)
	if hdrs:
		return hdrs[-1]
	return None

def get_composer_headerbox_last(hname):
	hdrs = get_composer_headerboxes(hname)
	if hdrs:
		return hdrs[-1]
	return None

def get_composer_all_recipients_emails():
	return [al.email for al in getaddresslines(get_composer_headers(RecipientHeaders))]


def set_composer_subject(s):
	entry_subject.set_text(s)

def get_composer_subject():
	return entry_subject.get_text()

def on_edit_subject(_wdg):
	update_window_title(win_comp, win_comp.get_data('saved-to-file'), entry_subject.get_text())
	set_unsaved()
	timer_once('update_composer_status_message', 5, update_composer_status_message)

def on_change_message(_wdg):
	timer_once('update_composer_status_message', 5, update_composer_status_message)
	win_comp.set_data('is-auto-saved', False)

def set_composer_text(s):
	composer_text_buffer.set_text(s)
	composer_text_buffer.place_cursor(composer_text_buffer.get_start_iter())

def append_composer_text_default_user_signature():
	composer_text_buffer.append('\n\n')
	composer_text_buffer.append_namedrange('user_signature', gemlv.user_signature.default())

def get_reply_quotation():
	return _("Quote:") + '\n\n' + quote_message()

def quote_message():
	if spanel_content.get_data('last-loaded-text') is not None:
		# TODO: quote only 1 text message part, or more/all of them?
		return re.sub('^', '> ', re.sub('\r', '', spanel_content.get_data('last-loaded-text')), 0, re.MULTILINE)
	return ''

def make_new_blank_email():
	eml = gemlv.email.Email(MIMEMultipart('mixed'))
	eml.preamble = COMMON_MULTIPART_PREAMBLE
	part_body = gemlv.email.Email(MIMEText(''), parent_email_obj = eml)
	part_body.set_charset('UTF-8')
	part_body.header[HDR_CTE].decoded = ''
	eml.attach(part_body)
	return eml

def open_composer(reason):
	if win_comp.get_visible():
		cur_reason = win_comp.get_data('reason')
		if cur_reason == reason:
			win_comp.set_urgency_hint(True)
			win_comp.present()
			return False
		else:
			act_close_edit()
			if win_comp.get_visible():
				return False
	
	global NewEmail
	NewEmail = make_new_blank_email()
	Attachments.clear()
	
	win_comp.show_all()
	panel_edit_message.set_data('saved-font', get_current_font(panel_edit_message))
	menuitem_all_comp_hdr.set_active(False)
	clear_composer_headers(None)
	
	for h in SenderHeaders:
		add_composer_header(h).cancel()
	my_addressline = guess_my_addressline()
	if my_addressline.email:
		add_composer_header('From', str(my_addressline))
	set_composer_subject('')
	composer_text_buffer.clear()
	
	win_comp.set_data('is-an-mdn', False)
	win_comp.set_data('add-msgid-xattr-on-send', [])
	win_comp.set_data('saved-to-file', None)
	on_after_save_draft()
	Timers['auto-save-draft'] = glib.timeout_add(5*1000, auto_save_draft)
	return True

def get_autosave_dir():
	return os.path.join(os.environ['HOME'], '.cache', PROGNAME, 'drafts')

def remove_old_draft():
	last_draft_name = win_comp.get_data('last-auto-saved-draft-file-name')
	if last_draft_name:
		draft_dir = get_autosave_dir()
		draft_file = os.path.join(draft_dir, last_draft_name)
		try:
			os.unlink(draft_file)
		except OSError as e:
			if e.errno not in [os.errno.ENOENT]:
				raise

def auto_save_draft():
	if not win_comp.get_data('is-auto-saved'):
		draft_name = '%s pid-%d.eml' % (time.strftime('%F %T').replace(':', '.'), os.getpid())
		draft_dir = get_autosave_dir()
		mkdir(draft_dir)
		email_to_save = build_newemail(with_attachment_data=False)
		if save_to_file(email_to_save, os.path.join(draft_dir, draft_name), ask_overwrite=False):
			win_comp.set_data('is-auto-saved', True)
			remove_old_draft()
			win_comp.set_data('last-auto-saved-draft-file-name', draft_name)
	# Keep timer running:
	return True

def add_composer_agent_headers():
	add_composer_header('User-Agent', USERAGENT)
	add_composer_header('X-Mailer', USERAGENT)

def add_composer_mailto(mailto):
	for field in AcceptableMailtoFields:
		if field in mailto:
			header = gemlv.email.Header(field).name
			if field in MultiRecipientsMailtoFields:
				add_composer_headers(header, mailto[field])
			elif field == 'subject':
				set_composer_subject(mailto[field])
			elif field == 'body':
				set_composer_text(mailto[field])
			else:
				add_composer_header(header, mailto[field])

def guess_my_addressline():
	"guess what is the user's address line to which the currently opened email is sent"
	if TheEmail is None: return AddressLine('')
	addr = TheEmail.header['Envelope-To'].decoded or TheEmail.header['Delivered-To'].decoded
	realname = gemlv.utils.get_gecos_name()
	# TODO: consult addressbook for a known realname part
	return AddressLine((realname, addr))

def guess_reply_addressline():
	if TheEmail is not None:
		for hname in ['Reply-To', 'From', 'Sender', 'X-Sender', 'X-X-Sender']:
			if hname in TheEmail.headers:
				return AddressLine(TheEmail.header[hname].decoded)
	return AddressLine('')


def act_compose():
	if open_composer(reason=COMPOSE_NEW):
		add_composer_agent_headers()
		add_composer_header('To', '')
		set_composer_subject('')
		composer_text_buffer.clear()
		append_composer_text_default_user_signature()
		composer_text_buffer.place_cursor(composer_text_buffer.get_start_iter())
		on_after_save_draft()
		panel_edit_message.grab_focus()


class InvalidSubjectLinePrefix(Exception):
	pass

def make_subject_line(original, pre_kind):
	# TODO: get language-alternative subject prefixes from gettext database
	if pre_kind == SUBJECT_PREFIX_FWD:
		pre = _("Fwd: ")
		alternatives = ["to:", "tov:"]  # @notranslate
	elif pre_kind == SUBJECT_PREFIX_RE:
		pre = _("Re: ")
		alternatives = ["vá:"]  # @notranslate
	else:
		raise InvalidSubjectLinePrefix()
	
	if all([not original.lower().startswith(altpre) for altpre in alternatives]):
		return pre + original
	
	return original

def act_reply(compose_type):
	if open_composer(reason=compose_type):
		add_composer_agent_headers()
		orig_subj = TheEmail.header[HDR_SUBJ].decoded
		composer_text_buffer.clear()
		append_composer_text_default_user_signature()
		composer_text_buffer.place_cursor(composer_text_buffer.get_start_iter())
		my_addressline = guess_my_addressline()
		
		if compose_type in [COMPOSE_FORWARD_MSG, COMPOSE_FORWARD_BODY]:
			win_comp.set_data('add-msgid-xattr-on-send', [XATTR_FORWARDED])
			fwdname = (orig_subj or _("Email")) + '.eml'
			subj = make_subject_line(orig_subj, SUBJECT_PREFIX_FWD)
			set_composer_subject(subj)
			# TODO: maintain Thread-Topic header here in forwards too?
			add_composer_header('To', '')
			composer_maintain_references_headers()
			
			if compose_type == COMPOSE_FORWARD_MSG:
				# copy the whole viewed email to an attachment
				email_to_forward = gemlv.email.Email(email.message_from_string(TheEmail.as_string()))
				# remove sensitive email headers from the forwarded email
				for fwd_header in email_to_forward.headers.keys:
					if any(wildcardmatch(fwd_header, sensitive_header) for sensitive_header in SensitiveHeaders):
						del email_to_forward.headers[fwd_header]
				part = gemlv.email.Email(MIMEMessage(email_to_forward._ll_email))
				part.header[HDR_CD].value.encoded = 'attachment'
				part.header[HDR_CD].param['filename'].decoded = fwdname
				NewEmail.attach(part)
				# TODO: make the attached email's row expandable in the attachments panel,
				# so its big attachments can be removed by the user
				Attachments.append(None, [part, glib.markup_escape_text(fwdname), 'emblem-mail', None, '', calc_attachment_checksum(part)])
			else:
				composer_text_buffer.append('\n')
				composer_text_buffer.append_namedrange('quoted_message', get_reply_quotation())
		else:
			win_comp.set_data('add-msgid-xattr-on-send', [XATTR_REPLIED])
			add_composer_header('Thread-Topic', TheEmail.header['Thread-Topic'].decoded or orig_subj)
			subj = make_subject_line(orig_subj, SUBJECT_PREFIX_RE)
			set_composer_subject(subj)
			composer_text_buffer.append('\n')
			composer_text_buffer.append_namedrange('quoted_message', get_reply_quotation())
			
			messageid = TheEmail.header[HDR_MID].decoded
			add_composer_header('In-Reply-To', messageid)
			composer_maintain_references_headers()
			
			reply_addressline = guess_reply_addressline()
			listaddress = get_listaddressline_main()
			
			if compose_type == COMPOSE_REPLY:
				add_composer_header('To', str(reply_addressline))
			elif compose_type == COMPOSE_REPLY_ALL:
				# gather all email addresses in the message
				# but do not duplicate any
				skip_addresses = [my_addressline.email, reply_addressline.email, '']
				rcpt_addresses = []
				
				if reply_addressline.email and reply_addressline.email != my_addressline.email:
					add_composer_header('To', str(reply_addressline))
					rcpt_addresses.append(reply_addressline.email)
				for h in RecipientHeaders:
					for addressline in [al.email for al in getaddresslines(TheEmail.headers[h].decoded)] - SubstractableList(skip_addresses):
						add_composer_header(h, str(addressline))
						rcpt_addresses.append(addressline.email)
				if listaddress.email and listaddress.email not in rcpt_addresses:
					add_composer_header('To', str(listaddress))
			elif compose_type == COMPOSE_REPLY_LIST:
				add_composer_header('To', str(listaddress))
		
		composer_text_buffer.place_cursor(composer_text_buffer.get_start_iter())
		on_after_save_draft()
		panel_edit_message.grab_focus()


def act_unsubscribe():
	links = get_header_links(','.join(TheEmail.headers['List-Unsubscribe'].encoded), schemata=['*'])
	if len(links) == 1 and links[0]['scheme'] == 'mailto':
		if open_composer(reason=COMPOSE_UNSUB):
			add_composer_mailto(links[0])
			on_after_save_draft()
	else:
		text = ''
		for link in links:
			uri = link['uri']
			if link['scheme'] == 'mailto' and link.get('to') and len(link['to'])>0:
				linktext = str(link['to'][0])
			else:
				linktext = uri
			short = shorturl(linktext, 80)
			if short is not None: linktext = short
			text += '\n\n<a href=\'%s\'>%s</a> <i>%s</i>' % (
				glib.markup_escape_text(uri), 
				glib.markup_escape_text(linktext), 
				glib.markup_escape_text(link['comment']),
			)
		dlg = gtk.MessageDialog(win_main, gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_OTHER, gtk.BUTTONS_CLOSE)
		dlg.set_title(_("Unsubscribe"))
		dlg.set_markup(_("Select a link to unsubscribe") + '\n\n' + _("Beware, open links only from trusted source. Spammers know their spam reached target if you follow fake unsubscribe links.") + text)
		dlg.get_action_area().children()[0].grab_focus()
		dlg.run()
		dlg.destroy()

def scroll_textview(tv, rect, scrwin):
	vadj = scrwin.get_vadjustment()
	vadj.set_value(vadj.upper - vadj.page_size)

def act_report_spam(considered_as_spam = True):
	emailfile = os.path.abspath(cliArgs.FILE)
	run_async('gemlv-report-%s' % ('spam' if considered_as_spam else 'ham'), [emailfile], None)

def runcmd_thread(args, input_fd, out_buffer, vb):
	reader, writer = get_pipe_handlers(1)
	pid = os.fork()
	if pid == 0:
		reader.close()
		os.dup2(input_fd, sys.stdin.fileno())
		os.dup2(writer.fileno(), sys.stdout.fileno())
		os.dup2(writer.fileno(), sys.stderr.fileno())
		os.closerange(3, 255)
		try:
			os.execvp(args[0], args)
		except OSError as e:
			warnx(str(e))
		os._exit(127)
	
	writer.close()
	while True:
		ln = reader.readline()
		if ln == '': break
		gtk.threads_enter()
		out_buffer.insert(out_buffer.get_end_iter(), ln)
		gtk.threads_leave()
	reader.close()
	status = WaitExecStatus(pid)

	gtk.threads_enter()
	out_buffer.insert(out_buffer.get_end_iter(), _("exit code: %s") % (status.code))
	out_buffer.set_data('process-exit-status', status)
	glib.idle_add(lambda: finished_razor_thread(vb), priority=glib.PRIORITY_DEFAULT_IDLE)
	gtk.threads_leave()

def get_extension_by_mime(mime):
	if not mime:
		e = None
	elif mime.main == 'multipart':
		e = '.eml'
	else:
		e = guess_extension(mime)
	if e is None:
		e = '.dat'
	return e

def get_mime_by_filepath(path):
	t = get_xattr(path, XATTR_TYPE)
	if t is None or t.find('/')<1:
		t = Magic.file(os.path.realpath(path))
		if t is None or t.find('/')<1:
			return MIMETYPE_OCTETSTREAM
	return ContentTypeString(t)

def get_mime_by_data(data):
	return ContentTypeString(Magic.buffer(data))

def act_open():
	eml = get_part_by_itpath()
	if eml is None: return
	fd, tmppath = mkstemp(prefix = PROGNAME + '-', suffix = get_extension_by_mime(eml.content_type))
	try:
		save_to_filedescriptor(eml, fd)
		fh = os.fdopen(fd, 'r')
		set_xattrs(fh, {XATTR_CHARSET: eml.header[HDR_CT].param['charset'].decoded, XATTR_TYPE: eml.content_type}, tmppath)
		fh.close()
	except OSError as e:
		os.unlink(tmppath)
		e.filename = tmppath
		display_error(e)
		return
	run_async(cliArgs.opener, cliArgs.opener_args + [tmppath], [os.unlink, tmppath])


def calc_attachment_name(part, n=None):
	"""
	Return a filename for a given MIME part to save it into a file.
	The filename is based on the Content-Disposition headers, else the Subject plus the MIME part's index.
	"""
	name = part.filename
	if not name:
		sfx = ''
		if n is not None: sfx = '-' + str(n)
		name = "%s - attachment%s%s" % (TheEmail.header[HDR_SUBJ].decoded or _("Email"), sfx, get_extension_by_mime(part.content_type))
	return basenameify(name)

def find_free_filename(directory=None, nice_name=None, nice_path=None):
	assert (directory is not None and nice_name is not None and nice_path is None) or (directory is None and nice_name is None and nice_path is not None)
	
	if nice_path is not None:
		return find_free_filename(directory=os.path.dirname(nice_path), nice_name=os.path.basename(nice_path))
	
	rootname, ext = os.path.splitext(nice_name)
	free_path = os.path.join(directory, nice_name)
	counter = 1
	while os.path.lexists(free_path):
		counter += 1
		free_path = os.path.join(directory, '%s (%d)%s' % (rootname, counter, ext))
	return os.path.basename(free_path)

def part_filename_by_iteratorpath(itpath, prefix='part', add_extension=True, add_subject=False):
	part = Parts[itpath][COL_PARTS_EML]
	fname = part.filename
	if not fname:
		fname = ''
		if add_subject:
			fname += basenameify(TheEmail.header[HDR_SUBJ].decoded)
			if fname:
				fname += ' - '
		oid = '-'.join(map(str, itpath))
		fname += '%s-%s' % (prefix, oid)
		if add_extension not in [False, None]:
			if add_extension is True:
				fname += get_extension_by_mime(part.content_type)
			else:
				fname += '.' + add_extension
	return fname

def act_save_struct():
	itpaths = selection_parts.get_selected_rows()[1]
	savedir = choose_save_folder()
	if savedir is not None:
		for n in range(len(itpaths)):
			act_save_struct_inner(savedir, Parts.get_iter(itpaths[n]))

def act_save_struct_inner(savedir, iterator):
	part = Parts[iterator][COL_PARTS_EML]
	itpath = Parts.get_path(iterator)
	mimepart_name = part.filename
	if mimepart_name:
		mimepart_name = os.path.basename(mimepart_name)
	if Parts.iter_has_child(iterator):
		if not mimepart_name:
			mimepart_name = part_filename_by_iteratorpath(itpath, prefix='multipart', add_extension=False)
		if part.is_multipart():
			savefile = os.path.join(savedir, part_filename_by_iteratorpath(itpath, prefix='part', add_extension='txt'))
			# TODO: should we care about overwriting files here?
			save_to_file(part, savefile, consider_preamble=True)
		else:
			body = part.payload_decoded
		mysavedir = os.path.join(savedir, mimepart_name)
		try:
			mkdir(mysavedir)
		except OSError as e:
			display_error(e)
		else:
			for nth in range(0, Parts.iter_n_children(iterator)):
				subiter = Parts.iter_nth_child(iterator, nth)
				act_save_struct_inner(mysavedir, subiter)
			moddatetime = part.header[HDR_CD].param['modification-date'].decoded
			posixmode = part.header[HDR_CD].param['posix-mode'].decoded
			try:
				if moddatetime:
					mod_timestamp = email.utils.mktime_tz(email.utils.parsedate_tz(moddatetime))
					os.utime(mysavedir, (-1, mod_timestamp))
				if posixmode:
					os.chmod(mysavedir, int(posixmode, 8))
			except OSError as e:
				display_error(e)
	else:
		if not mimepart_name:
			if part.is_multipart() or part.payload_decoded == '':
				# Skip empty noname parts.
				return
			mimepart_name = part_filename_by_iteratorpath(itpath, prefix='part', add_extension=True)
		savefile = os.path.join(savedir, mimepart_name)
		# TODO: should we care about overwriting files here?
		save_to_file(part, savefile)

def act_save():
	itpaths = selection_parts.get_selected_rows()[1]
	if len(itpaths) == 1:
		itpath = itpaths[0]
		eml = get_part_by_itpath(itpath)
		savefile = choose_save_file(find_free_filename(directory=FileChooserLastFolder, nice_name=calc_attachment_name(eml)))
		if savefile is not None:
			save_to_file(eml, savefile)
	elif len(itpaths) > 1:
		savedir = choose_save_folder()
		if savedir is not None:
			for n in range(0, len(itpaths)):
				eml = get_part_by_itpath(itpaths[n])
				basename = find_free_filename(directory=savedir, nice_name=calc_attachment_name(eml, n))
				savefile = os.path.join(savedir, basename)
				save_to_file(eml, savefile)

def get_xattr(file_, attrname):
	if xattr is not None:
		try:
			return xattr.getxattr(file_, attrname)
		except IOError as e:
			if e.errno not in [os.errno.ENODATA, os.errno.ENOTSUP, os.errno.ENOSYS]:
				raise
	return None

def append_xattrs(fh, attrs, filename='-', glue=''):
	attrs = attrs.copy()
	for attr in attrs.keys():
		curr_value = get_xattr(fh, attr)
		if curr_value is not None:
			attrs[attr] = curr_value + glue + attrs[attr]
	return set_xattrs(fh, attrs, filename)

def set_xattrs(fh, attrs, filename='-'):
	allok = True
	if xattr is not None:
		for attrname, attrval in attrs.iteritems():
			try:
				if attrval is None:
					xattr.removexattr(fh, attrname)
				else:
					xattr.setxattr(fh, attrname, attrval)
			except IOError as e:
				if e.errno == os.errno.ENODATA and attrval is None:
					# Ignore that a nonexistent attribute could not be removed
					pass
				else:
					warnx(_("Notice: can not set xattr '%s' on '%s': %s") % (attrname, filename, str(e)))
					allok = False
					if e.errno not in [os.errno.ENODATA, os.errno.ENOTSUP, os.errno.ENOSYS]:
						raise
	return allok

def save_to_file(eml, filename, ask_overwrite=True, consider_preamble=False):
	if ask_overwrite:
		if os.path.lexists(filename):
			if not question(_("This file already exists:") + ('\n<tt>%s</tt>\n' % (glib.markup_escape_text(os.path.basename(filename)))) + _("Overwrite?"), (None, gtk.STOCK_SAVE)):
				return None
	try:
		if eml.content_type == MIMETYPE_SYMLINK:
			link_target = eml.payload_decoded
			# TODO: check safe symlink
			os.symlink(link_target, filename)
		else:
			fh = open(filename, 'w')
			fd = fh.fileno()
			save_to_filedescriptor(eml, fd, consider_preamble)
			if eml.content_type.main == 'multipart':
				mimetype = MIMETYPE_EMAIL
			else:
				mimetype = eml.content_type
			messageid = eml.header[HDR_MID].decoded
			if not messageid and TheEmail is not None:
				messageid = TheEmail.header[HDR_MID].decoded
			set_xattrs(fh, {XATTR_CHARSET: eml.header[HDR_CT].param['charset'].decoded, XATTR_TYPE: mimetype, XATTR_ORIGIN: messageid}, filename)
			fh.flush()
			moddatetime = eml.header[HDR_CD].param['modification-date'].decoded
			posixmode = eml.header[HDR_CD].param['posix-mode'].decoded
			if moddatetime:
				mod_timestamp = email.utils.mktime_tz(email.utils.parsedate_tz(moddatetime))
				futimes(fd, (-1, mod_timestamp))
			if posixmode:
				# set POSIX permission bits, except the suid/sgid octet
				os.fchmod(fd, int(posixmode, 8) & 0777)
			fh.close()
		return True
	except IOError as e:
		display_error(e)
	except OSError as e:
		e.filename = filename
		display_error(e)
	return False

def save_to_filedescriptor(eml, fd, consider_preamble=False):
	if eml.is_multipart():
		if consider_preamble:
			s = '\n'.join([eml.preamble or '', eml.epilogue or ''])
		else:
			s = eml.as_string()
	else:
		s = eml.payload_decoded
	written = os.write(fd, s)
	if written != len(s):
		raise OSError(5, 'Write Error. %d out of %d bytes written.' % (written, len(s)))
	os.fdatasync(fd)

def act_view_source():
	if panel_content.get_data('view-unfiltered'):
		filt = None
	else:
		filt = ('', None, False)
	load_part(get_part_by_itpath(), filt)

def act_wrap(tv, i=1):
	modes = Cyclelist([gtk.WRAP_WORD, gtk.WRAP_WORD_CHAR, gtk.WRAP_NONE], at=tv.get_wrap_mode())
	tv.set_wrap_mode(modes.turn(i))

def get_current_font(txtv):
	pctx = txtv.get_pango_context()
	fdsc = pctx.get_font_description()
	s = fdsc.to_string()
	m = re.search('\s(\d+)(\s|$)', s)
	if m: pt = int(m.group(1))
	else: pt = 12
	return {'family': fdsc.get_family().lower(), 'string': s.lower(), 'size': pt, 'desc': fdsc,}

def act_font_switch(tv):
	font = get_current_font(tv)
	if font['family'] != 'monospace':
		tv.set_data('saved-font', font)
		f = tv.get_data('saved-font-monospace')
		if f is None: f = 'monospace 12'
		else: f = f['string']
	else:
		f = tv.get_data('saved-font')['string']
	Props['ui/view/font'] = f
	change_font(tv, f)

def act_font(tv):
	dlg = gtk.FontSelectionDialog(_("Select Font"))
	dlg.set_transient_for(gemlvtk.get_current_window())
	dlg.set_modal(True)
	dlg.set_font_name(tv.get_data('saved-font')['string'])
	if dlg.run() == gtk.RESPONSE_OK:
		font_name = dlg.get_font_name()
		Props['ui/view/font'] = font_name
		change_font(tv, font_name)
		font = get_current_font(tv)
		if font['family'] == 'monospace':
			key = 'saved-font-monospace'
		else:
			key = 'saved-font'
		tv.set_data(key, font)
	dlg.destroy()

def on_scroll_on_button_font(wdg, evt, textview, modmask):
	if modmask is None or (evt.state & modmask) != 0:
		delta = +1 if evt.direction == gtk.gdk.SCROLL_UP else -1
		pctx = textview.get_pango_context()
		font = pctx.get_font_description()
		font.set_size(font.get_size() + delta * pango.SCALE)
		textview.modify_font(font)
		textview.set_data('saved-font', get_current_font(panel_content))
		Props['ui/view/font'] = str(font)
		return True

def change_font(tv, s):
	tv.modify_font(pango.FontDescription(s))

def on_select_parts(selection):
	itpaths = selection.get_selected_rows()[1]
	stck_sign_good.hide()
	stck_sign_bad.hide()
	if len(itpaths) > 1:
		panel_btnbox.show()
		lbl_right.set_markup(_("Multiple (%s) selected attachments") % (len(itpaths)))
		btn_open.hide()
		btn_save.set_label(_("Save All"))
		panel_content_image.hide()
		spanel_content.hide()
		btn_open2.set_sensitive(False)
		btn_save2.set_sensitive(True)
		menubutton_filters.set_sensitive(False)
	else:
		panel_btnbox.hide()
		panel_content_image.hide()
		spanel_content.show()
		if len(itpaths) == 1:
			btn_open2.set_sensitive(True)
			btn_save2.set_sensitive(True)
			itpath = itpaths[0]
			eml = get_part_by_itpath(itpath)
			load_part(eml)
			menubutton_filters.set_sensitive(True)
			populate_filters_menu(eml)
		else:
			btn_open2.set_sensitive(False)
			btn_save2.set_sensitive(False)
			clear_content()
			menubutton_filters.set_sensitive(False)
	set_dnd_drag_targets()

def act_show_view_headers(chkmi):
	show_view_headers(chkmi.active)

def show_view_headers(show=True):
	if show:
		spanel_view_header.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
		panel_view_header.set_size_request(-1, -1)
		panel_view_header.set_line_wrap(False)
		headers_markup = [ \
			PMU_HEAD + glib.markup_escape_text(header.name) + PMU_HEAD_CLOSE + ': ' + \
			glib.markup_escape_text(header.value.decoded) \
			for header in TheEmail.headers.items \
		]
		panel_view_header.set_markup(list2text(headers_markup))
	else:
		spanel_view_header.set_policy(gtk.POLICY_NEVER, gtk.POLICY_AUTOMATIC)
		resize_panel_view_header(spanel_view_header)
		panel_view_header.set_line_wrap(True)
		panel_view_header.set_markup(get_headers_markup(TheEmail))
	panel_view_header.set_data('all-headers', show)

def populate_header_menu(label, menu):
	selected_link = label.get_current_uri()
	if selected_link is not None:
		mi = gemlvtk.StockMenuItem(icon_name='contact-new', label=_("Add to addressbook"))
		mailto_al = parse_mailto(selected_link)['to'][0]
		mi.connect('activate', lambda *_x: act_add_to_addressbook_manual(mailto_al))
		menu.append(mi)
	
	menu.append(gtk.SeparatorMenuItem())
	mi = gtk.CheckMenuItem(_("Show All Headers"))
	mi.set_active(panel_view_header.get_data('all-headers') == True)
	mi.connect('toggled', act_show_view_headers)
	menu.append(mi)
	menu.show_all()

def populate_filters_menu(eml):
	for mi in menu_filters.children():
		menu_filters.remove(mi)
	uniqfilt = {}
	rmi_group = None
	for filt in get_filters_by_mime(eml.content_type.main, eml.content_type.sub):
		if filt[0] == '': continue
		if uniqfilt.has_key(filt[0]) and uniqfilt[filt[0]] == filt[1]: continue
		uniqfilt[filt[0]] = filt[1]
		lbl = filt[0]
		if lbl == 'sh':
			lbl = ' '.join(re.findall('(^\S+|\d*[<>]+(?:&\d+|\s*\S+)|[;\|&]+\s*\S+)', filt[1][1]))
		mi = gtk.RadioMenuItem(group=rmi_group, label=lbl, use_underline=False)
		if rmi_group is None: mi.set_active(True)  # check the first menu item on menu creation
		mi.connect('activate', filters_menu_filter_selected, eml, filt)
		menu_filters.append(mi)
		rmi_group = mi
	menu_filters.show_all()
	disable_filters_menu(True if len(menu_filters.children()) == 0 else False)

def filters_menu_filter_selected(mi_selected, eml, filt):
	load_part(eml, filt)

class TextBuffer(gtk.TextBuffer):
	class TextBufferNamedRangeError(Exception):
		pass
	def __init__(self):
		super(self.__class__, self).__init__()
		self.text_namedranges = {}
	def set_namedrange(self, rangename, content):
		self.clear_namedrange(rangename)
		self.set_end_mark_gravity(rangename, 'right')
		itr = self.get_namedrange_boundaries(rangename)[0]
		self.insert(itr, content)
		self.set_end_mark_gravity(rangename, 'left')
	def clear_namedrange(self, rangename):
		self.delete(*self.get_namedrange_boundaries(rangename))
	def add_namedrange(self, rangename, content, position_iter_cb):
		if self.text_namedranges.has_key(rangename):
			raise self.TextBufferNamedRangeError("Range '%s' in TextBuffer is already exists." % (rangename,))  # @notranslate
		mark_start = self.create_mark(rangename+'-start', position_iter_cb(), left_gravity=True)
		mark_end = self.create_mark(rangename+'-end', position_iter_cb(), left_gravity=False)
		self.text_namedranges[rangename] = {'start': mark_start, 'end': mark_end}
		if content != '':
			self.set_namedrange(rangename, content)
		self.set_end_mark_gravity(rangename, 'left')
	def set_end_mark_gravity(self, rangename, gravity):
		mark_end = self.text_namedranges[rangename]['end']
		tmp_iter = self.get_iter_at_mark(mark_end)
		self.delete_mark(mark_end)
		mark_end = self.create_mark(rangename+'-end', tmp_iter, left_gravity=bool(gravity=='left'))
		self.text_namedranges[rangename]['end'] = mark_end
	def append_namedrange(self, rangename, content=''):
		return self.add_namedrange(rangename, content, position_iter_cb=self.get_end_iter)
	def update_namedrange(self, rangename, content='', position_iter_cb=None):
		if self.text_namedranges.has_key(rangename) and position_iter_cb is None:
			self.set_namedrange(rangename, content)
		else:
			self.delete_namedrange(rangename)
			if position_iter_cb is None: position_iter_cb = self.get_iter_at_cursor
			self.add_namedrange(rangename, content, position_iter_cb)
	def get_iter_at_cursor(self):
		return self.get_iter_at_mark(self.get_insert())
	def delete_namedrange(self, rangename):
		if self.text_namedranges.has_key(rangename):
			self.clear_namedrange(rangename)
			self.delete_mark(self.text_namedranges[rangename]['start'])
			self.delete_mark(self.text_namedranges[rangename]['end'])
			del self.text_namedranges[rangename]
	def get_namedrange_boundaries(self, rangename):
		if not self.text_namedranges.has_key(rangename):
			raise self.TextBufferNamedRangeError("Range '%s' in TextBuffer is not exists." % (rangename,))  # @notranslate
		return self.get_iter_at_mark(self.text_namedranges[rangename]['start']), self.get_iter_at_mark(self.text_namedranges[rangename]['end'])
	def get_namedrange_text(self, rangename):
		if self.text_namedranges.has_key(rangename):
			return self.get_text(*self.get_namedrange_boundaries(rangename))
		else:
			return None
	def append(self, content):
		self.insert(self.get_end_iter(), content)
	def clear(self):
		return self.delete(self.get_start_iter(), self.get_end_iter())
	def get_text_all(self):
		return self.get_text(self.get_start_iter(), self.get_end_iter(), include_hidden_chars=True)

def populate_composer_textview_menu(textview, menu):
	pos = 0
	mi = gemlvtk.StockMenuItem(stock_id=gtk.STOCK_ADD, label=_("Add signature"))
	menu_addsign = gtk.Menu()
	for user_signature_name in gemlv.user_signature.iter_all():
		submi = gtk.MenuItem(label = user_signature_name if user_signature_name is not None else _("Default"))
		submi.connect('activate', lambda _x, user_signature_name: composer_text_buffer.update_namedrange('user_signature', gemlv.user_signature.byname(user_signature_name)), user_signature_name)
		menu_addsign.append(submi)
	menu_addsign.append(gtk.SeparatorMenuItem())
	submi = gemlvtk.StockMenuItem(stock_id=gtk.STOCK_REMOVE, label=_("Remove signature"))
	submi.connect('activate', lambda *_x: composer_text_buffer.clear_namedrange('user_signature'))
	menu_addsign.append(submi)
	mi.set_submenu(menu_addsign)
	menu.insert(mi, pos)
	
	pos += 1
	if composer_text_buffer.get_namedrange_text('quoted_message'):
		mi = gemlvtk.StockMenuItem(stock_id=gtk.STOCK_REMOVE, label=_("Remove quote"))
		mi.connect('activate', lambda *_x: composer_text_buffer.clear_namedrange('quoted_message'))
	else:
		mi = gemlvtk.StockMenuItem(stock_id=gtk.STOCK_ADD, label=_("Quote message"))
		mi.connect('activate', lambda *_x: composer_text_buffer.update_namedrange('quoted_message', get_reply_quotation()))
	menu.insert(mi, pos)
	pos += 1
	menu.insert(gtk.SeparatorMenuItem(), pos)
	pos +=1 
	menu.show_all()

def disable_filters_menu(b=True):
	menubutton_filters.children()[0].children()[1].set_sensitive(not b)

def get_part_by_itpath(itpath = None):
	if itpath is None:
		try:
			itpath = selection_parts.get_selected_rows()[1][0]
		except IndexError:
			return None
	model = Parts
	return model.get_value(model.get_iter(itpath), 0)

def get_part_iter(part_asked):
	lookup = {'iter': None}
	Parts.foreach(lambda model, path, it, userdata: (userdata.__setitem__('iter', it), model[it][0] == part_asked)[1], lookup)
	return lookup['iter']

def get_all_parent_parts(part_asked):
	it = get_part_iter(part_asked)
	level = 0
	while True:
		it = Parts.iter_parent(it)
		level += 1
		if it is None:
			break
		else:
			yield level, Parts[it][COL_PARTS_EML], Parts[it][COL_PARTS_INFO]

def load_toolitems(toolbar, toolitems):
	items = []
	for label, stock, tip, fnc_left, fnc_right in toolitems:
		hid = None
		if type(fnc_left) == str:
			tbi = gtk.SeparatorToolItem()
			if fnc_left == 'space':
				tbi.set_draw(False)
				tbi.set_expand(True)
			elif fnc_left == 'separator':
				tbi.set_draw(True)
				tbi.set_expand(False)
		elif isinstance(stock, gtk.ToolItem):
			tbi = stock
			if tip is not None:
				tbi.set_tooltip_text(tip)
			if isinstance(tbi, gtk.ToolButton):
				if label is None:
					tbi.set_label(tip)
				else:
					tbi.set_label(label)
				hid = tbi.connect('clicked', on_click_button, fnc_left)
		else:
			Lstocklabel = None
			st = gtk.stock_lookup(stock)
			if st:
				Lstocklabel = re.sub('_', '', st[1])  # remove shortcut key from button
			if label is not None:
				Llabel = label
			elif Lstocklabel is not None:
				Llabel = Lstocklabel
			else:
				Llabel = None
			if tip is not None:
				Ltip = tip
				if Llabel is None:
					Llabel = Ltip
			else:
				if label is not None:
					Ltip = Llabel
				else:
					Ltip = Lstocklabel
			if fnc_left is None and fnc_right is None:
				tbi = gtk.ToolItem()
				tbi.set_border_width(3)
				tbi.add(gtk.image_new_from_icon_name(stock, toolbar.get_icon_size()))
				tbi.set_tooltip_text(Ltip)
			else:
				tbi = gemlvtk.StockToolButton(label=Llabel, stock=stock, tooltip=Ltip)
				tbi.set_data('stock', stock)
				tbi.set_data('label', label)
				hid = tbi.connect('clicked', on_click_button, fnc_left)
				tbi.child.connect('button-press-event', on_press_button, fnc_right)
		tbi.set_data('clicked-handler', hid)
		toolbar.insert(tbi, -1)
		items.append(tbi)
	return items

COL_PARTS_EML, COL_PARTS_LABEL_MARKUP, COL_PARTS_ICONNAME, COL_PARTS_ICON, COL_PARTS_INFO = range(5)
COL_ATTACHMENTS_EML, COL_ATTACHMENTS_LABEL_MARKUP, COL_ATTACHMENTS_ICONNAME, COL_ATTACHMENTS_ICON, COL_ATTACHMENTS_SIZE_LABEL, COL_ATTACHMENTS_CHECKSUM = range(6)
assert COL_PARTS_LABEL_MARKUP == COL_ATTACHMENTS_LABEL_MARKUP
assert COL_PARTS_ICONNAME == COL_ATTACHMENTS_ICONNAME
assert COL_PARTS_ICON == COL_ATTACHMENTS_ICON

def setup_treeview__icon_label(tv, label_edit_cb=None):
	colnum_txt = 1
	tvc = gtk.TreeViewColumn()
	tv.append_column(tvc)
	cr_pix = gtk.CellRendererPixbuf()
	cr_txt = gtk.CellRendererText()
	if label_edit_cb is not None:
		cr_txt.set_property('editable', True)
		cr_txt.connect('edited', label_edit_cb, colnum_txt)
	tvc.pack_start(cr_pix, False)
	tvc.pack_start(cr_txt, True)
	tvc.add_attribute(cr_txt, 'markup', COL_ATTACHMENTS_LABEL_MARKUP)
	tvc.add_attribute(cr_pix, 'icon-name', COL_ATTACHMENTS_ICONNAME)
	tvc.add_attribute(cr_pix, 'pixbuf', COL_ATTACHMENTS_ICON)


class ComposerHeaderValidationError(Exception):
	pass

def validate_all_comp_headers():
	for n in range(0, len(panel_comp_header.children())):
		box = panel_comp_header.children()[n]
		if box.get_visible():
			valid = box.validate()
			if valid == VALIDATION_RESULT_INVALID:
				box.point_out()
				raise ComposerHeaderValidationError(box.name)

class CanNotPrepareEmailToSend(Exception):
	pass

class EmailPreparationCanceled(Exception):
	pass

def prepare_to_send():
	validate_all_comp_headers()
	err_msg = ''
	if not get_composer_subject():
		err_msg += _("No Subject.") + '\n'
	if len(filter(lambda x: len(x.strip()), get_composer_headers(RecipientHeaders))) < 1:
		err_msg += _("No any Recipient.") + '\n'
	if toggle_rqdn.get_active() and not filter(None, get_composer_headers([HDR_DNT, 'From', 'Reply-To'])):
		err_msg += _("Disposition Notification requested but no address given.") + ' ' + _(MSG_NO_ADDRESS_FOR_DNT) + '\n'
	if err_msg != '':
		err_msg += _("Send anyway?")
		if not question(err_msg, (_("Send"), 'mail-send')):
			raise EmailPreparationCanceled()
	try:
		email_to_send = build_newemail_to_send()
	except GnuPGSignError as e:
		display_error(_("Crypto-signing error"), e.message)
		raise CanNotPrepareEmailToSend()
	except GnuPGEncryptError as e:
		if e.status == 'invalid recipient':
			# TODO: choose GPG recipients
			pass
		save_exception_traceback(e, traceback.format_exc())
		display_error(e)
		raise CanNotPrepareEmailToSend()
	
	return email_to_send

def act_send_to_file():
	try:
		email_to_send = prepare_to_send()
	except (EmailPreparationCanceled, CanNotPrepareEmailToSend) as e:
		return
	except Exception as e:
		traceback.print_exc()
		save_exception_traceback(e, traceback.format_exc())
		display_error(e)
		return
	
	filename = propose_and_confirm_a_filename_to_save_edit()
	if filename is not None:
		# NOTE: do not ask overwrite, because the file chooser dialog asked it.
		save_to_file(email_to_send, filename, ask_overwrite=False)
		# not calling on_after_save_draft() and not updating win_comp 'saved-to-file' data
		# because now we're saving the ready-to-send email, not the edit-later one.
		# the user might not able to read it because it may be encrypted for the recipient.

def act_send():
	try:
		email_to_send = prepare_to_send()
	except (EmailPreparationCanceled, CanNotPrepareEmailToSend) as e:
		return
	except Exception as e:
		save_exception_traceback(e, traceback.format_exc())
		display_error(e)
		return
	
	dlg = gtk.MessageDialog(win_comp, gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_INFO, gtk.BUTTONS_CANCEL)
	dlg.connect('delete-event', lambda w, e: True)
	with BasicReuseable(_("Sending...")) as s:
		dlg.set_title(s)
		dlg.set_markup(s)
	set_dialog_icon_name(dlg, 'mail-send-receive')
	
	carea = dlg.get_content_area()
	progressbar = gtk.ProgressBar()
	details = gemlvtk.ScrolledLabelView()
	carea.pack_start(progressbar, False, True)
	carea.pack_start(details, True, True)
	
	aarea = dlg.get_action_area()
	btn_cancel = aarea.children()[0]
	btn_show_details = gemlvtk.StockButton(label=_("Show Details"), stock=gtk.STOCK_INFO)
	btn_show_details.connect('clicked', act_show_details_on_send_panel, dlg, details)
	
	aarea.pack_start(btn_show_details, False, True)
	dlg.show_all()
	details.hide()
	btn_show_details.hide()
	
	thrd = threading.Thread(target=sending_thread, args=(dlg, progressbar, btn_cancel, btn_show_details, details, email_to_send))
	thrd.start()

def sending_thread(dlg, progressbar, btn_cancel, btn_show_details, details_widget, email_to_send):
	global StopSending
	StopSending = False
	
	recipients_deep = [email_to_send.headers[h].decoded for h in RecipientHeaders]
	recipients_flat = reduce(lambda a, b: a+b, recipients_deep)
	recipients_addr = getaddresslines(recipients_flat)
	
	sendmail_envs = {
		'FROM': get_email_address_from_headers('From', email_to_send),
		'RCPT': ','.join(map(lambda al: al.email, recipients_addr)),
	}
	
	child_read, parent_write, parent_read, child_write = get_pipe_handlers(2)
	pid = os.fork()
	if pid == 0:
		parent_read.close()
		parent_write.close()
		os.dup2(child_read.fileno(), sys.stdin.fileno())
		os.dup2(child_write.fileno(), sys.stdout.fileno())
		os.dup2(child_write.fileno(), sys.stderr.fileno())
		os.closerange(3, 255)
		try:
			# set helper env vars to aid custom sendmail script
			for env_name, env_val in sendmail_envs.iteritems():
				os.environ['SENDMAIL_%s' % env_name] = env_val
			os.execvp('sendmail', ['sendmail', '-ti'])
		except OSError as e:
			warnx(str(e))
		os._exit(127)
	
	gtk.threads_enter()
	sn = btn_cancel.connect('clicked', sending_cancel, pid, parent_write)
	gtk.threads_leave()
	
	child_read.close()
	child_write.close()
	set_blocking(parent_write, False)
	resp = ''
	text = email_to_send.as_string()
	pos = 0
	bufsize = 4096
	length = len(text)
	while pos < length and not StopSending:
		try:
			byteswritten = os.write(parent_write.fileno(), text[pos:pos+bufsize])
			pos += byteswritten
		except ValueError as e:
			resp += '>>> ' + str(e) + '\n'
			break
		except OSError as e:
			if e.errno == os.errno.EAGAIN:
				while not StopSending:
					ready = select.select([], [parent_write], [], 1.0)
					if len(ready[1]) > 0:
						break
			else:
				gtk.threads_enter()
				display_error(e)
				gtk.threads_leave()
				break
		gtk.threads_enter()
		progressbar.set_fraction((min(pos, length) + 0.0) / length)
		gtk.threads_leave()
	set_blocking(parent_write, True)
	if not StopSending:
		try:
			parent_write.close()
		except IOError as e:
			resp += '>>> ' + str(e) + '\n'
	
	resp += ''.join(parent_read.readlines())
	parent_read.close()
	status = WaitExecStatus(pid)
	
	gtk.threads_enter()
	progressbar.hide()
	btn_cancel.hide()
	btn_close = gtk.Button(stock=gtk.STOCK_CLOSE)
	btn_close.connect('clicked', lambda x: dlg.destroy())
	dlg.get_action_area().pack_start(btn_close, False, False)
	btn_close.show_all()
	
	btn_save_sent = gemlvtk.StockButton(stock=gtk.STOCK_SAVE, label=_("Save to Sent"))
	btn_save_sent.connect('clicked', on_save_sent)
	dlg.get_action_area().pack_start(btn_save_sent, False, False)
	
	if status.code == 0 and status.signal == 0:
		set_dialog_icon_name(dlg, gtk.STOCK_APPLY)
		dlg.set_title(_("Email is sent."))
		dlg.set_markup(_("Email is sent."))
		if win_comp.get_data('is-an-mdn'):
			menubutton_mdn.set_markup(menubutton_mdn.get_data('saved-label'))
		# Assume the last line is the queue id.
		sendmail_queue_id = resp.strip().split('\n')[-1]
		add_composer_header(HDR_XQID, sendmail_queue_id)
		add_composer_header(HDR_XSD, email.utils.formatdate(time.time(), True))
		win_comp.set_data('email-sent', True)
		composer_text_buffer.set_modified(False)
		# Save Message-ID to the email file's xattr which we forwarded or replied to.
		origin_email_fh = win_main.get_data('email-file-handle')
		if origin_email_fh is not None:
			origin_email_file = win_main.get_data('email-file')
			msgid = email_to_send.header[HDR_MID].decoded
			for xattrname in win_comp.get_data('add-msgid-xattr-on-send'):
				append_xattrs(origin_email_fh, {xattrname: msgid}, origin_email_file, glue=',')
		# Save queue id to the composed email file's xattr.
		emailfile = win_comp.get_data('saved-to-file')
		if emailfile is not None:
			# Note: queue id won't be saved in xattributes if you have not saved the email before sent.
			append_xattrs(open(emailfile), {XATTR_QUEUEID: sendmail_queue_id}, emailfile, glue=',')
		# Show button to save sent email in 'Sent/' folder
		btn_save_sent.show_all()
		# Save recipient to the auto addressbook.
		for recipient_addressline in recipients_addr:
			gemlv.addressbook.add(section='gemlv.auto', address_line=recipient_addressline)
	else:
		set_dialog_icon_name(dlg, gtk.STOCK_DIALOG_ERROR)
		dlg.set_markup(' '.join([_("Sendmail error: %s") % (status.code,), _("signal: %s") % (status.signal,) if status.signal!=0 else '']))
	btn_show_details.show()
	details_widget.set_text(resp)
	update_composer_status_message()
	gtk.threads_leave()

def act_show_details_on_send_panel(btn, dlg, details):
	# display sendemail output in details box
	if details.get_visible():
		btn.set_label(_("Show Details"))
		details.hide()
		dlg.set_resizable(False)
	else:
		btn.set_label(_("Hide Details"))
		dlg.set_resizable(True)
		details.show()

def sending_cancel(btn, pid, writer_fh):
	global StopSending
	StopSending = True
	os.kill(pid, signal.SIGINT)

def iterate_composer_headers():
	for hname, hval in get_composer_headers(None) + [(HDR_SUBJ, get_composer_subject())]:
		if len(hname) > 0 and len(hval) > 0:
			yield (hname, hval)

def make_msgid():
	# Don't leak hostname, IP, or time in generated Message-ID.
	return '<%s@%s>' % (uuid.uuid4().hex, uuid.uuid4().hex)


def build_newemail(with_attachment_data=True):
	
	# if there is not Message-ID yet but we want to add it to xattrs on successful sending:
	msgid = get_composer_header_last(HDR_MID)
	if msgid is None and win_comp.get_data('add-msgid-xattr-on-send'):
		add_composer_header(HDR_MID, make_msgid())
	
	result_eml = make_new_blank_email()
	
	for hname, _hval in iterate_composer_headers():
		del result_eml.headers[hname]
	
	for hname, hval in iterate_composer_headers():
		result_eml.headers.append(gemlv.email.Header(hname, MimeDecoded(hval)))
	
	text = composer_text_buffer.get_text_all()
	enc = analyze_for_optimal_encoding(text)
	text = text.encode(enc)
	part_body = result_eml.parts[0]
	part_body.header[HDR_CTE].encoded = enc
	part_body.payload_encoded = text
	
	if with_attachment_data:
		for part in NewEmail.parts[1:]:
			result_eml.attach(part)
	else:
		# clone each MIME parts (except the first one which is part_body) without scalar payload
		latest_parts = [result_eml]
		for depth, index, part in NewEmail.iterate_parts_recursively():
			if depth == 0: continue  # this is the main email object
			if depth == 1 and index == 0: continue  # this is the email body part
			if part.content_type == MIMETYPE_DN:
				# attach disposition notification part directly, it is not come from a file.
				latest_parts[depth-1].attach(part)
				continue
			# TODO: what to do with forwarded envelopes here?
			thin_part = make_thin_mime_part(part)
			latest_parts[depth-1].attach(thin_part)
			if len(latest_parts) <= depth: latest_parts.append(thin_part)
			latest_parts[depth] = thin_part
	
	return result_eml

def make_thin_mime_part(eml):
	"""
	Create a MIME message without payload, but set content metadata in MIME headers.
	It is intended only for the user's personal use, not to send away,
	because it records the local filesystem path where the attachments came from.
	"""
	thin_eml = gemlv.email.Email(MIMEBase(eml.content_type.main, eml.content_type.sub))
	# remove default core headers, all core and custom headers will be copied later.
	for header_name in thin_eml.headers.keys:
		del thin_eml.headers[header_name]
	# copy all headers from the original email.
	for header in eml.headers.items:
		thin_eml.headers.append(header)
	thin_eml.preamble = eml.preamble
	thin_eml.epilogue = eml.epilogue
	# record where this file was attached from, if it's known
	if hasattr(eml, 'origin_path'):
		thin_eml.header['Content-Location'].decoded = 'file://' + urllib2.quote(eml.origin_path.encode('utf-8'))
	# intentionally skip payload.
	return thin_eml

def make_protected_headers_part(eml):
	protected_headers_part = gemlv.email.Email(MIMEText(''))
	protected_headers_part.content_type = MIMETYPE_HEADERS
	protected_headers_part.set_charset('UTF-8')
	protected_headers_part.header[HDR_CT].param['protected-headers'].encoded = 'v1'
	protected_headers_part.header[HDR_CD].encoded = 'inline'
	protected_headers_part.header[HDR_CD].param['filename'].decoded = 'rfc822-headers.txt'
	protected_headers_part.header[HDR_CTE].encoded = 'quoted-printable'
	for header in eml.headers.items:
		# sign main email headers, except base technical ones 
		# and other headers not being in the recipients' interest
		if header.name not in DontLeakHeaders and not header.name.startswith('Content-') and header.name not in CoreTechnicalHeaders:
			protected_headers_part.append_encoded_payload('%s: %s\n' % (header.name, header.value.decoded.encode('quoted-printable')))
	return protected_headers_part

def build_newemail_to_send():
	email_to_send = build_newemail()
	del email_to_send.headers[HDR_XSD]
	del email_to_send.headers[HDR_XQID]
	
	# set the Disposition-Notification-To header if the user has not set it.
	if toggle_rqdn.get_active() and email_to_send.header[HDR_DNT].decoded == '':
		for addr in filter(None, get_composer_headers(['From', 'Reply-To'])):
			email_to_send.header[HDR_DNT].decoded = addr
			break
	
	# crypto-sign
	if toggle_sign.get_active():
		signed_email = gemlv.email.Email(MIMEMultipart(NewEmail.content_type.sub))
		signed_email.header[HDR_CT].param['protected-headers'].decoded = 'v1'
		signature_part = gemlv.email.Email(MIMEBase('application', 'pgp-signature'))
		
		# make a MIME part containing the email's headers as a mean to sign headers as well.
		protected_headers_part = make_protected_headers_part(email_to_send)
		signed_email.attach(protected_headers_part)
		# copy over the email's headers to the attached signed email. this is another way to sign headers.
		for header in email_to_send.headers.items:
			if header.name not in DontLeakHeaders and not header.name.startswith('Content-') and header.name not in CoreTechnicalHeaders:
				signed_email.headers.append(header)
		
		# move all attachments over to the signed email.
		for part in email_to_send.parts:
			signed_email.attach(part)
		email_to_send.parts.clear()
		# change the root MIME email type to indicate that it is (including) a signed email.
		email_to_send.content_type = 'multipart/signed'
		email_to_send.header[HDR_CT].param['protocol'].decoded = 'application/pgp-signature'
		
		# produce signature
		data_to_sign = signed_email.as_string()
		# workaround missing newline between boundaries, https://bugs.python.org/issue14983
		if signed_email.content_type.main == 'multipart' and data_to_sign[-1] != '\n':
			data_to_sign += '\n'
			# there is no trailing '\n' after the closing boundary;
			# this adds a '\n' at the end of the raw multipart/* part:
			signed_email.epilogue = ''
		signature = generate_signature(email_to_send, data_to_sign)
		signature_part.payload_encoded = signature
		signature_part.header[HDR_CD].decoded = 'attachment'
		signature_part.header[HDR_CD].param['filename'].decoded = 'signature.pgp.asc'
		email_to_send.attach(signed_email)
		email_to_send.attach(signature_part)
	
	# gpg encryption
	if toggle_encrypt.get_active():
		crypt_meta_part = gemlv.email.Email(MIMEBase('application', 'pgp-encrypted'))
		crypt_meta_part.payload_encoded = 'Version: 1\n'
		crypt_email = gemlv.email.Email(MIMEBase(MIMETYPE_OCTETSTREAM.main, MIMETYPE_OCTETSTREAM.sub))
		crypt_email.header[HDR_CD].value.encoded = 'attachment'
		crypt_email.header[HDR_CD].param['filename'].decoded = 'encrypted_message.pgp.asc'
		if not toggle_sign.get_active():
			protected_headers_part = make_protected_headers_part(email_to_send)
			email_to_send.prepend_part(protected_headers_part)
		crypt_email.payload_encoded = gpg_encrypt_email(email_to_send)
		email_to_send.parts.clear()
		email_to_send.content_type = 'multipart/encrypted'
		email_to_send.header[HDR_CT].param['protocol'].decoded = 'application/pgp-encrypted'
		email_to_send.attach(crypt_meta_part)
		email_to_send.attach(crypt_email)
		for hname in HeadersObfuscate:
			if hname in email_to_send.headers:
				del email_to_send.headers[hname]
				email_to_send.header[hname] = '...'
	
	add_autocrypt_headers(email_to_send)
	
	return email_to_send

def gpg_encrypt_email(eml):
	recipients = []
	hidden_recipients = []
	for array, hnames in (recipients, ['From', 'To', 'Cc']), (hidden_recipients, ['Bcc']):
		for hname in hnames:
			array.extend([al.email for al in getaddresslines(eml.headers[hname].decoded)])
	extra_args = []
	for r in hidden_recipients:
		extra_args.extend(['--hidden-recipient', r])
	email_to_encrypt = gemlv.email.Email(email.message_from_string(eml.as_string()))
	for hname in DontLeakHeaders:
		del email_to_encrypt.headers[hname]
	try:
		crypt = gpg.encrypt(email_to_encrypt.as_string(), recipients, always_trust=True, extra_args=extra_args)
	except Exception as e:
		save_exception_traceback(e, traceback.format_exc())
		display_error(_("Encryption error"), str(e))
		raise
	if not crypt.ok:
		raise GnuPGEncryptError(crypt)
	return crypt.data

def add_autocrypt_headers(eml):
	try:
		email_identity = find_signature_author_address(eml)
	except GnuPGSignError:
		return
	keydata = None
	try:
		keydata = gpg_export_pubkey('<'+email_identity+'>')
	except GnuPGError:
		pass
	if keydata:
		hvalue = 'addr=%s; prefer-encrypt=mutual; keydata= %s' % (email_identity, re.sub('(.{%d})'%email.Header.MAXLINELEN, '\\1\n ', keydata).rstrip())
		eml.header['Autocrypt'].value.encoded = hvalue

def find_signature_author_address(email_root):
	"""
	Find out with which identity (email address) the email should be signed with.
	"""
	addr = getaddresslines(email_root.headers['From'].decoded)
	if len(addr) != 1:
		raise GnuPGSignError(_("No 'From' address (or more of them) given to match a GPG key to crypto-sign with."))
	author_address = addr[0].email
	return author_address

def generate_signature(email_root, data_to_sign):
	return gpg_sign_data(data_to_sign.replace('\n', '\r\n'), '<'+find_signature_author_address(email_root)+'>')

def propose_and_confirm_a_filename_to_save_edit():
	subj = get_composer_subject()
	proposed_filename = ''
	if not win_comp.get_data('email-sent') or not subj:
		proposed_filename += _("Draft")
	if subj:
		if proposed_filename: proposed_filename += ' - '
		proposed_filename += subj
	proposed_filename = basenameify(proposed_filename)
	proposed_filename += '.eml'
	return choose_save_file(find_free_filename(directory=FileChooserLastFolder, nice_name=proposed_filename), ask_overwrite=True)

def act_save_edit(save_as=False):
	filename = win_comp.get_data('saved-to-file')
	if filename is None or save_as:
		filename = propose_and_confirm_a_filename_to_save_edit()
	if filename is not None:
		eml_to_save = build_newemail()
		# NOTE: do not ask overwrite, because either the file chooser dialog asked it previously,
		# or we're updating an earlier saved file.
		if save_to_file(eml_to_save, filename, ask_overwrite=False) == True:
			win_comp.set_data('saved-to-file', filename)
			on_after_save_draft()

def on_save_sent(*X):
	"""invoked by "Save" button on the "Email is Sent" dialog."""
	global FileChooserLastFolder
	lastfolder = FileChooserLastFolder
	origin_email_file = win_main.get_data('email-file')
	if origin_email_file:
		inbox_folder = os.path.dirname(origin_email_file)
	else:
		inbox_folder = os.getcwd()
	sent_folder = os.path.join(inbox_folder, 'Sent')
	FileChooserLastFolder = sent_folder
	act_save_edit(save_as=True)
	FileChooserLastFolder = lastfolder

def on_after_save_draft():
	set_unsaved(False)
	composer_text_buffer.set_modified(False)
	update_window_title(win_comp, win_comp.get_data('saved-to-file'), get_composer_subject())
	update_composer_status_message()

def update_composer_status_message():
	if NewEmail is None: return
	status_msgs = [_("Size: %s") % (human_size(NewEmail.size_approx),)]
	x_sent_date_last = get_composer_header_last(HDR_XSD)
	if x_sent_date_last:
		try:
			dt = email.utils.parsedate_tz(x_sent_date_last)
			x_sent_date_last = time.strftime('%c', time.localtime(email.utils.mktime_tz(dt)))
		except TypeError: pass
		status_msgs.append(_("Sent on %s") % (x_sent_date_last,))
	tb_comp_label.set_labels(status_msgs)

def update_composer_toolbar_toggle_buttons():
	ninja_toggle(toggle_unimportant, False)
	ninja_toggle(toggle_unimportant, False)
	ninja_toggle(toggle_rqdn, False)
	
	for hname, hval in iterate_composer_headers():
		if hname == 'Importance':
			if hval.lower().find('low')>-1:
				ninja_toggle(toggle_unimportant, True)
			if hval.lower().find('high')>-1:
				ninja_toggle(toggle_important, True)
		if hname == HDR_GDR:
			ninja_toggle(toggle_rqdn, True)

def update_window_title(window, filename, subject_text):
	window.set_title('%s - %s' % (subject_text or os.path.basename(filename or '') or _("Unsaved"), PROGNAME))

def update_addressbook_highlights(abook_model=None):
	if abook_model is None:
		abook_model = win_comp.get_data('addressbook-model')
		if abook_model is None: return
	added_recipients = get_composer_all_recipients_emails()
	for item in abook_model:
		item_emailaddresses = getaddresslines([item[0]])
		try:
			item[1] = (PMU_ADDRESSBOOK_ADDED_ADDRESS if item_emailaddresses[0].email in added_recipients else PMU_ADDRESSBOOK_NOT_ADDED_ADDRESS) % (glib.markup_escape_text(item[0]),)
		except IndexError:
			pass

class AddressBrowser(gtk.Window):
	__gsignals__ = {
		'items-add': (gobject.SIGNAL_RUN_LAST, gobject.TYPE_BOOLEAN, (gobject.TYPE_PYOBJECT,)),
		'items-edit': (gobject.SIGNAL_RUN_LAST, gobject.TYPE_BOOLEAN, (gobject.TYPE_PYOBJECT,)),
		'close': (gobject.SIGNAL_RUN_LAST, gobject.TYPE_BOOLEAN, ()),
	}
	
	def __init__(self, modal_window=False, single_select=False):
		super(self.__class__, self).__init__()
		box = gtk.VBox(False, 3)
		entry = gtk.Entry()
		scroll = gtk.ScrolledWindow()
		self.mod = gtk.ListStore(str, str)
		self.listfilter = self.mod.filter_new()
		self.treeview = gtk.TreeView(self.listfilter)
		self.selection = self.treeview.get_selection()
		box_buttons = gtk.HBox(True, 2)
		self.b_add = gemlvtk.StockButton(stock=gtk.STOCK_ADD)
		self.b_edit = gemlvtk.StockButton(stock=gtk.STOCK_EDIT)
		b_close = gemlvtk.StockButton(stock=gtk.STOCK_CLOSE)
		
		self.set_modal(modal_window)
		winname = 'addressbook'
		self.set_default_size(int(Props['ui/%(winname)s/width'%{'winname':winname}] or 280), int(Props['ui/%(winname)s/height'%{'winname':winname}] or 400))
		self.set_data('ui-unit-name', winname)
		self.connect('configure-event', on_window_configure)
		self.set_border_width(4)
		
		self.selection.set_mode(gtk.SELECTION_SINGLE if single_select else gtk.SELECTION_MULTIPLE)
		# disable Add button if none selected
		self.selection.connect('changed', lambda selection, b_add: b_add.set_sensitive(bool(len(selection.get_selected_rows()[1])>0)), self.b_add)
		scroll.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
		self.treeview.set_headers_visible(False)
		self.treeview.set_rules_hint(True)
		self.treeview.insert_column_with_attributes(0, '', gtk.CellRendererText(), markup=1)
		# show only rows which match to the text typed by the user (substring match)
		self.listfilter.set_visible_func(lambda mo, it, entry: mo[it][0] is not None and mo[it][0].find(entry.get_text())>-1, entry)
		self.b_add.set_sensitive(False)
		
		entry.set_icon_from_stock(1, gtk.STOCK_FIND)
		entry.connect('changed', lambda _x: self.listfilter.refilter())
		self.treeview.connect('button-press-event', self.handle_dblclick)
		self.connect('delete-event', self.click_close)
		gemlvtk.add_key_binding(self, 'Escape', self.click_close)
		b_close.connect('clicked', self.click_close)
		self.b_add.connect('clicked', self.click_add)
		self.b_edit.connect('clicked', self.click_edit)
		
		self.add(box)
		box.pack_start(entry, False, True)
		box.pack_start(scroll, True, True)
		scroll.add_with_viewport(self.treeview)
		box.pack_start(box_buttons, False, True)
		box_buttons.pack_start(self.b_add, True, False)
		box_buttons.pack_start(self.b_edit, True, False)
		box_buttons.pack_start(b_close, True, False)
		self.show_all()
	
	def click_close(self, *_x):
		self.emit('close')
		self.destroy()
	
	def close(self):
		self.click_close()
	
	def click_add(self, *_x):
		self.emit('items-add', self.get_selection())
	
	def click_edit(self, *_x):
		self.emit('items-edit', self.get_selection())
	
	def get_selection(self):
		return map(lambda x: self.mod[self.mod.get_iter(x)][0], self.selection.get_selected_rows()[1])
	
	def handle_dblclick(self, _x, evt):
		if evt.button == 1 and evt.type == gtk.gdk._2BUTTON_PRESS:
			flt_pathinfo = self.treeview.get_path_at_pos(int(evt.x), int(evt.y))
			if flt_pathinfo is not None:
				iterator_path = self.listfilter.convert_path_to_child_path(flt_pathinfo[0])
				iterator = self.mod.get_iter(iterator_path)
				self.emit('items-add', [self.mod[iterator][0]])
			return True
	
	@property
	def addresslist_model(self):
		return self.mod
	
	@property
	def button_add(self):
		return self.b_add

	@property
	def button_edit(self):
		return self.b_edit

def act_addressbook():
	if win_comp.get_data('addressbook-window'):
		win_comp.get_data('addressbook-window').present()
		return True
	
	def on_items_add(addressbrowser, items):
		clear_composer_headers('To', '')
		add_composer_headers('To', items)
	
	def on_edit(addressbrowser, _items):
		addressbrowser.close()
		run_async(cliArgs.opener, [gemlv.addressbook.get_singlefile_path()], None)
		run_async(cliArgs.opener, [gemlv.addressbook.get_directory_path()], None)
	
	def on_close(addressbrowser):
		win_comp.remove_data('addressbook-window')
		win_comp.remove_data('addressbook-mod')
	
	win = AddressBrowser(modal_window=False)
	addresslist = win.addresslist_model
	win_comp.set_data('addressbook-window', win)
	win_comp.set_data('addressbook-model', addresslist)

	win.set_title(_("Addressbook"))
	win.set_transient_for(win_comp)
	
	if not win_comp.get_visible():
		win.button_add.hide()
	
	if win_comp.get_visible():
		win.connect('items-add', on_items_add)
	win.connect('items-edit', on_edit)
	win.connect('close', on_close)
	
	gemlv.addressbook.load(
		callback = lambda addr, addresslist: addresslist.append([addr, glib.markup_escape_text(addr)]), 
		error_handler = lambda e: display_error(e), 
		userdata = addresslist, gettext = _)
	update_addressbook_highlights(addresslist)
	
	return True

def act_attach():
	filenames = choose_open_files(custom_accept_button_stock='mail-attachment')
	if len(filenames) != 0:
		for filename in filenames:
			attach_path(filename, filename)
		update_composer_status_message()

def byte_is_identical_qp(b):
	if b == '\r' or b == '\n':
		return True
	if ord(b) < ord(' ') or ord(b) > ord('~') or b == '=':
		return False
	return True

def analyze_for_optimal_encoding(buf):
	"Choose the transfer encoding from Base64 and Quoted-Printable, which produces smaller encoded data for a given clear data."
	# TODO: support yEnc
	
	approx_encoded_size_b64 = len(buf) * 1.37
	approx_encoded_size_qp = sum(map(lambda b: 1 if byte_is_identical_qp(b) else 3, buf))
	# add an extra equal mark and a linefeed for each 76th output byte
	approx_encoded_size_qp += 2 * (approx_encoded_size_qp / 76)
	
	if approx_encoded_size_b64 < approx_encoded_size_qp:
		return 'base64'
	else:
		return 'quoted-printable'

def on_composer_attachments_row_changed(model, itpath, iterator):
	hid = model.get_data('row-changed-signal-handler-id')
	model.handler_block(hid)
	part = model[iterator][COL_ATTACHMENTS_EML]
	model[iterator][COL_ATTACHMENTS_SIZE_LABEL] = human_size(part.size_decoded_approx)
	model.handler_unblock(hid)

def attach_blob(data, parent_iter=None, check_unique_file=True):
	mime = get_mime_by_data(data)
	basename = 'file%s' % (get_extension_by_mime(mime),)
	
	part = gemlv.email.Email(MIMEBase(mime.main, mime.sub))
	attachment_email = gemlv.email.Email(email.message_from_string(data))
	if mime == MIMETYPE_EMAIL or attachment_email.is_multipart():
		part.attach(attachment_email)
	else:
		enc = analyze_for_optimal_encoding(data[0:4096*3])
		part.header[HDR_CTE].decoded = enc
		# TODO: in background thread?
		part.payload_encoded = data.encode(enc)
	if check_unique_file and not check_unique_attachment(part):
		display_info_box_async(_("This file is already attached"))
		return False
	attach__internal(parent_iter=parent_iter, basename=basename, part=part, mime=mime)
	return True


def attach_path(original_path, root_attachment_path, parent_iter=None, check_unique_file=True):
	root_attachment_path = os.path.abspath(root_attachment_path)
	attachment_path = original_path
	mime = None
	isalink = False
	try:
		if os.path.islink(original_path):
			symlink_target_raw = os.readlink(original_path)
			symlink_target_abs = read_symlink_target_abs(os.path.abspath(original_path))
			visited_paths = [symlink_target_abs]
			while True:
				if is_safe_symlink(symlink_target_abs, root_attachment_path):
					# it's a symlink pointing to a (maybe transitive) target which is inside the base directory we are attaching recursively at the moment.
					# attach it as a symlink.
					mime = MIMETYPE_SYMLINK
					isalink = True
					# generate a symlink target to point directly to the first safe transitive target.
					symlink_content = make_relative_symlink(symlink_target_abs, original_path)
					break
				if not os.path.exists(symlink_target_abs):
					# it's a broken symlink. attach it as a symlink pointing to the nonexistent target.
					mime = MIMETYPE_SYMLINK
					isalink = True
					symlink_content = symlink_target_raw
					break
				if os.path.islink(symlink_target_abs):
					# it's a symlink, let's follow.
					symlink_target_abs_prev = symlink_target_abs
					symlink_target_raw = os.readlink(symlink_target_abs)
					symlink_target_abs = read_symlink_target_abs(symlink_target_abs)
					if symlink_target_abs in visited_paths:
						# it's a loopy symlink. attach it as a symlink pointing to the last transitive target before the cycle.
						mime = MIMETYPE_SYMLINK
						isalink = True
						symlink_content = make_relative_symlink(symlink_target_abs_prev, original_path)
						break
					visited_paths.append(symlink_target_abs)
				else:
					# it's a symlink (transitively) pointing not to a 'safe' file (in sense 
					# of not being within the directory currently being attached),
					# neither to an other symlink but something which exists (likely a normal file or a directory),
					# so attach the resolved 'unsafe' file instead of the original symlink.
					attachment_path = symlink_target_abs
					# TODO: what should happen with unsafe files which linked multiple times?
					break
		
		content_disposition_params = {}
		with BasicReuseable(os.lstat(attachment_path)) as s:
			content_disposition_params['modification_date'] = email.utils.formatdate(s.st_mtime, True)
			if not isalink:
				# record the POSIX permission bits including the SUID/SGID octet, if the recipient party
				# deems this octet unsafe to set on a file, may she ignore it.
				content_disposition_params['posix_mode'] = '%05o' % (s.st_mode & 07777,)
	except OSError as e:
		display_error(e)
		return False
	
	if mime is None:
		mime = get_mime_by_filepath(attachment_path)
	
	if os.path.isdir(attachment_path) and not isalink:
		part = gemlv.email.Email(MIMEMultipart('related'))
	else:
		if isalink:
			part = gemlv.email.Email(MIMETYPE_SYMLINK)
			part.header[HDR_CTE].decoded = 'quoted-printable'
			part.payload_encoded = symlink_content.encode('quoted-printable')
		else:
			part = gemlv.email.Email(MIMEBase(mime.main, mime.sub))
			part.origin_path = attachment_path
			
			# Check whether this file is an email file.
			attachment_email = email.message_from_file(open(attachment_path, 'r'))
			if mime == MIMETYPE_EMAIL or attachment_email.is_multipart():
				# File being attached is an Email (according to mime type or by detected multipart)
				# TODO: remove sensitive headers?
				attachment_email = gemlv.email.Email(attachment_email)
				attachment_email.origin_path = attachment_path
				part.attach(attachment_email)
			else:
				del attachment_email
				part.payload_encoded = ''
				enc = None
				# Load file into memory
				try:
					fh = open(attachment_path, 'r')
				except (IOError, OSError) as e:
					display_error(e)
					return False
				while True:
					# Encode n*3 bytes at once to avoid base64 paddings.
					buf = fh.read(4096*3)
					if buf == '': break
					if enc is None:
						enc = analyze_for_optimal_encoding(buf)
						part.header[HDR_CTE].decoded = enc
					part.append_encoded_payload(buf.encode(enc))
				fh.close()
	
	basename = os.path.basename(original_path)
	
	if check_unique_file and not check_unique_attachment(part):
		display_info_box_async(_("This file is already attached:"), basename)
		# returning True indicates that the caller can proceed attaching additional file,
		# because there was not an error in the attachment, since this file is already attached.
		return True
	
	iterator = attach__internal(parent_iter=parent_iter, content_disposition_params=content_disposition_params, basename=basename, part=part, mime=mime)
	
	if os.path.isdir(attachment_path) and not isalink:
		for entry in os.listdir(attachment_path):
			if not attach_path(os.path.join(attachment_path, entry), root_attachment_path, iterator, check_unique_file=False):
				return False
	return True

def attach__internal(parent_iter=None, content_disposition_params={}, basename=None, part=None, mime=None):
	assert 'attachment' not in content_disposition_params
	assert 'filename' not in content_disposition_params
	
	# find that multipart MIME part which is closest to parent_iter
	while True:
		if parent_iter is None:
			parent_part = NewEmail
			break
		else:
			parent_part = Attachments[parent_iter][COL_ATTACHMENTS_EML]
			if parent_part.is_multipart():
				break
			parent_iter = Attachments.iter_parent(parent_iter)
	
	part.header[HDR_CD].params.decoded = [('attachment', ''), ('filename', basename)] + content_disposition_params.items()
	parent_part.attach(part)
	set_unsaved()
	
	iterator = Attachments.append(parent_iter, [part, glib.markup_escape_text(basename), gemlvtk.get_stock_icon_by_mime(mime.main, mime.sub), None, '', calc_attachment_checksum(part)])
	if parent_iter is not None:
		panel_attachments.expand_row(Attachments.get_path(parent_iter), False)
	
	if mime == MIMETYPE_EMAIL or len(part.parts) > 0:
		attachment_email = part.parts[0]
		try:
			amid = attachment_email.header[HDR_MID].decoded
			if amid:
				# Add Message-ID to main email's References.
				composer_append_to_list_header(HDR_REF, [amid])
				part.headers.append(gemlv.email.Header(HDR_MID, amid))
			# Add parts to the attachments panel which are already attached to this email file.
			add_already_attached_parts(iterator, attachment_email)
		except Exception as e:
			# can not look into message/rfc822 file as it was an email
			warnx(str(e))
	
	return iterator

def calc_attachment_checksum(part):
	if part.is_multipart():
		return None
	data = part.payload_decoded
	if data == '':
		return None
	return hashlib.md5(data).hexdigest()

def check_unique_attachment(mimepart):
	"""
	Compare mimepart checksum to the other attachments in NewEmail.
	Return true if no attachment matched or mimepart is an empty MIME part, false otherwise.
	"""
	
	checksum = calc_attachment_checksum(mimepart)
	if checksum is None: return True
	result = {'checksum': checksum, 'unique': True}
	
	def compare_checksums(ts_model, ts_path, ts_iter, result):
		cksum = ts_model[ts_path][COL_ATTACHMENTS_CHECKSUM]
		if cksum == result['checksum']:
			result['unique'] = False
			# terminate foreach() loop:
			return True
	
	Attachments.foreach(compare_checksums, result)
	return result['unique']

def add_already_attached_parts(root_iter, eml, callback=lambda x: True):
	if callback(eml):
		name = eml.filename or '[%s]' % eml.content_type
		icon = gemlvtk.get_stock_icon_by_mime(eml.content_type.main, eml.content_type.sub)
		iterator = Attachments.append(root_iter, [eml, glib.markup_escape_text(name), icon, None, '', calc_attachment_checksum(eml)])
		for subpart in eml.parts:
			add_already_attached_parts(iterator, subpart, callback=callback)

def drop_attachment_acceptable(targets):
	acceptable_types = MIMETYPE_URILIST, MIMETYPE_OCTETSTREAM
	for expect_type in acceptable_types:
		if expect_type in targets:
			return expect_type
	return False

def drop_attachment_motion(wdg, context, x, y, time):
	#warnx('Dropping %s' % (context.targets,))
	if drop_attachment_acceptable(context.targets):
		wdg.drag_highlight()
		context.drag_status(gtk.gdk.ACTION_COPY, time)
	else:
		context.drag_abort(time)
	return True

def drop_attachment_drop(wdg, context, x, y, time):
	target = drop_attachment_acceptable(context.targets)
	accept = bool(target)
	context.drop_reply(accept, time)
	if accept:
		wdg.drag_get_data(context, target, time)
		wdg.drag_unhighlight()
	else:
		display_error(_("Can not manage any of these types:"), repr(context.targets))
		context.finish(accept, False, time)
	return accept

def drop_attachment_data(wdg, context, x, y, data, intid, time):
	success = False
	if data.get_length() > -1:
		typ = data.get_data_type()
		parent_iter = context.get_data('treeview-drop-dest-iterator')
		if typ == MIMETYPE_URILIST:
			success = None
			for uri in data.get_uris():
				filepath = file_uri_to_path(uri)
				if filepath is not None:
					if not attach_path(filepath, filepath, parent_iter):
						success = False
						break
				else:
					display_error(_("Unrecognized URI:"), uri)
			if success is None:
				# All uri are attached successfuly.
				success = True
		elif typ == MIMETYPE_OCTETSTREAM:
			# TODO: get filename from somewhere
			success = bool(attach_blob(data.data, parent_iter))
	context.finish(success, False, time)
	update_composer_status_message()
	return True

def drop_attachment_reorder_data(wdg, context, x, y, data, intid, time):
	treestore, iterator_path = data.tree_get_row_drag_data()
	context.set_data('treeview-iterator-path', iterator_path)
	return False

def drop_attachment_reorder_drop(wdg, context, x, y, time):
	if 'GTK_TREE_MODEL_ROW' in context.targets:
		success = False
		subject_path = context.get_data('treeview-iterator-path')
		if subject_path is not None:
			drop_info = wdg.get_dest_row_at_pos(x, y)
			if drop_info is not None:
				relative_iterator_path, relation = drop_info
				relative_iterator = Attachments.get_iter(relative_iterator_path)
				relative_part = Attachments[relative_iterator][COL_ATTACHMENTS_EML]
				if relation in [gtk.TREE_VIEW_DROP_BEFORE, gtk.TREE_VIEW_DROP_AFTER]:
					parent_iter = Attachments.iter_parent(relative_iterator)
					if parent_iter is None:
						parent_part = NewEmail
					else:
						parent_part = Attachments[parent_iter][COL_ATTACHMENTS_EML]
					if relation == gtk.TREE_VIEW_DROP_BEFORE:
						newindex = parent_part.parts.index(relative_part)
					elif relation == gtk.TREE_VIEW_DROP_AFTER:
						newindex = parent_part.parts.index(relative_part) + 1
				elif relation in [gtk.TREE_VIEW_DROP_INTO_OR_BEFORE, gtk.TREE_VIEW_DROP_INTO_OR_AFTER]:
					parent_part = relative_part
					newindex = 0
				if parent_part.is_multipart():
					# Reorder subject_part attachment.
					subject_part = Attachments[subject_path][COL_ATTACHMENTS_EML]
					old_parent_iter = Attachments.iter_parent(Attachments.get_iter(subject_path))
					if old_parent_iter is None:
						old_parent_part = NewEmail
					else:
						old_parent_part = Attachments[old_parent_iter][COL_ATTACHMENTS_EML]
					if old_parent_part == parent_part:
						idx = old_parent_part.parts.index(subject_part)
						if idx < newindex:
							newindex -= 1
					old_parent_part.parts.remove(subject_part)
					parent_part.parts.insert(newindex, subject_part)
					success = True
		context.finish(success, False, time)
		event_is_handled = not success
		return event_is_handled
	else:
		# We assume this is an external drop.
		# Save TreeView-relative coordinates.
		context.set_data('treeview-drop-dest-iterator', get_iterator_from_pos(wdg, x, y))
	# Report the event is unhandled.
	return False

def rename_attachment(cellrenderer, iterator, new_text, colnum):
	assert colnum == COL_ATTACHMENTS_LABEL_MARKUP
	eml = Attachments[iterator][COL_ATTACHMENTS_EML]
	eml.header[HDR_CD].param['filename'].decoded = new_text
	Attachments[iterator][colnum] = glib.markup_escape_text(new_text)
	return True

def on_keypress_attachments(tv, evt):
	if evt.keyval == gtk.gdk.keyval_from_name('Delete'):
		sel = panel_attachments.get_selection()
		for itpath in reversed(sel.get_selected_rows()[1]):
			try:
				iterator = Attachments.get_iter(itpath)
			except ValueError:
				# Child was deleted in meantime.
				continue
			if Attachments[iterator][COL_ATTACHMENTS_EML].content_type == MIMETYPE_DN:
				# Disallow removing MDN part as it would lose to be an MDN anymore
				win_comp.get_window().beep()
				continue
			part = Attachments[iterator][COL_ATTACHMENTS_EML]
			if part.content_type == MIMETYPE_EMAIL:
				composer_substract_from_list_header(HDR_REF, [part.header[HDR_MID].decoded])
			parent_iter = Attachments.iter_parent(iterator)
			if parent_iter is None:
				parent_part = NewEmail
			else:
				parent_part = Attachments[parent_iter][COL_ATTACHMENTS_EML]
			parent_part.parts.remove(part)
			del Attachments[iterator]
		update_composer_status_message()
		return True
	return False

def on_panel_parts_button_press_event(wdg, event):
	# https://stackoverflow.com/a/57470492/1676943
	if event.type != gtk.gdk.BUTTON_PRESS or event.button != 1: return
	if (event.state & gtk.gdk.CONTROL_MASK): return
	path = wdg.get_path_at_pos(int(event.x), int(event.y))
	if not path: return
	path = path[0]
	selection = wdg.get_selection()
	if selection.path_is_selected(path):
		selection.unselect_path(path)
		event.state |= gtk.gdk.CONTROL_MASK
		return

def set_dnd_drag_targets():
	itpaths = selection_parts.get_selected_rows()[1]
	if len(itpaths) == 1:
		mime = Parts[itpaths[0]][COL_PARTS_EML].content_type
		targets = [(mime, gtk.TARGET_OTHER_APP, 1), ('XdndDirectSave0', gtk.TARGET_OTHER_APP, 2), (MIMETYPE_OCTETSTREAM, gtk.TARGET_OTHER_APP, 3)]
	else:
		targets = [(MIMETYPE_URILIST, gtk.TARGET_OTHER_APP, 0)]
	panel_parts.drag_source_set_target_list(targets)

def drag_part_begin(wdg, context):
	dragged_parts = []
	itpaths = selection_parts.get_selected_rows()[1]
	for itpath in itpaths:
		part = Parts[itpath][COL_PARTS_EML]
		filename = part_filename_by_iteratorpath(itpath, add_extension=True, add_subject=True)
		dragged_parts.append((part, filename))
	
	if len(dragged_parts) > 1:
		context.set_icon_stock(gtk.STOCK_DND_MULTIPLE, 0, 0)
	else:
		dragged_part, filename = dragged_parts[0][:]
		atom_xds = gtk.gdk.atom_intern('XdndDirectSave0')
		atom_filename = gtk.gdk.atom_intern(MIMETYPE_TEXT)
		# Put dragged file's name into XWindow property (XDirectSave standard)
		context.source_window.property_change(atom_xds, atom_filename, 8, gtk.gdk.PROP_MODE_REPLACE, str(filename))
		context.set_data('atom-xds', atom_xds)
		context.set_data('atom-xds-filename', atom_filename)
		
	context.set_data('dragged-parts', dragged_parts)

def drag_part_data(wdg, context, dnd_data, intid, time):
	targettype = dnd_data.get_target()
	warnx("Dropping %d %s" % (intid, targettype,))  # @notranslate
	dragged_parts = context.get_data('dragged-parts')
	
	if targettype == MIMETYPE_URILIST:
		uris_text = ''
		# save attachments to temporary files, where the remote app will copy from
		# TODO: IDEA: detect email-attachment fuse filesystem where user can access attachments through and give URIs pointing in it.
		tmp_dir_path = mkdtemp(prefix = PROGNAME + '-DnD_')
		context.set_data('tmp-dir-path', tmp_dir_path)
		for dragged_part, filename in dragged_parts:
			savefile = os.path.join(tmp_dir_path, filename)
			save_to_file(dragged_part, savefile, ask_overwrite=False, consider_preamble=False)
			uris_text += 'file://%s\r\n' % (urllib2.quote(savefile.encode('utf-8')),)
		warnx('drag-and-drop uri-list:\n'+uris_text+'---')
		atom = gtk.gdk.atom_intern(MIMETYPE_URILIST)
		dnd_data.set(atom, 8, uris_text)
	else:
		dragged_part = dragged_parts[0][0]
		if targettype == MIMETYPE_OCTETSTREAM:
			if dragged_part.is_multipart():
				filedata = dragged_part.as_string()
			else:
				filedata = dragged_part.payload_decoded
			atom = gtk.gdk.atom_intern(MIMETYPE_OCTETSTREAM)
			dnd_data.set(atom, 8, filedata)
		elif targettype == 'XdndDirectSave0':
			typ, fmt, dest_filename = context.source_window.property_get(context.get_data('atom-xds'), context.get_data('atom-xds-filename'))
			if dest_filename is not None:
				xds_return_code = 'F'
				# TODO
				# Don't handle XDirectSave.
				# We pretended to support it just to have the remote app read our filename.
#				# TODO: support GIO
#				filepath = file_uri_to_path(dest_filename)
#				if filepath is not None:
#					saved = save_to_file(part0, filepath)
#					xds_return_code = 'S' if saved else 'E'
				# Fail XDirectSave, remote app should ask us for other target type.
				dnd_data.set(dnd_data.target, 8, xds_return_code)
		else:
			warnx("Unknown drop target: "+targettype)

def drag_part_end(wdg, context):
	atom = context.get_data('atom-xds')
	if atom is not None:
		context.source_window.property_delete(atom)
	tmp_dir_path = context.get_data('tmp-dir-path')
	if tmp_dir_path:
		recursive_rm(tmp_dir_path)

def act_dispos_notif():
	if open_composer(reason=COMPOSE_MDN):
		NewEmail.content_type = 'multipart/report'
		NewEmail.header[HDR_CT].param['report-type'].decoded = 'disposition-notification'
		
		win_comp.set_data('is-an-mdn', True)
		win_comp.set_data('add-msgid-xattr-on-send', [XATTR_MDNSENT])
		add_composer_agent_headers()
		pndr_box = add_composer_header(HDR_PNDR, 'yes')
		pndr_box.readonly = True
		pndr_box.removable = False
		toggle_rqdn.set_sensitive(False)
		
		dnt_addresses = TheEmail.headers[HDR_DNT].decoded
		my_addressline = guess_my_addressline()
		
		if dnt_addresses:
			for al in getaddresslines(dnt_addresses):
				add_composer_header('To', al.addressline)
		else:
			add_composer_header('To', str(guess_reply_addressline()))
		lang = TheEmail.header['Accept-Language'].decoded
		if lang:
			savelang = os.environ['LANGUAGE']
			os.environ['LANGUAGE'] = lang
		Ltxt_subj = _("Disposition Notification: {subject}")
		Ltxt_body = _("The message was sent on {date} to {me} with subject \"{subject}\" "
			"delivered on {delivery_date} and has been displayed. "
			"This is no guarantee that the message has been read or understood.")
		if lang:
			os.environ['LANGUAGE'] = savelang
		prms = {
			'date': TheEmail.header['Date'].decoded or '[somewhen]',
			'me': my_addressline.email or '[someone]',
			'subject': TheEmail.header[HDR_SUBJ].decoded,
			'delivery_date': TheEmail.header['Delivery-Date'].decoded or '[somewhen]',
		}
		subject_text = Ltxt_subj.format(**prms)
		message_text = list2text(textwrap.wrap(Ltxt_body.format(**prms), 79))
		set_composer_subject(subject_text)
		set_composer_text(message_text)
		
		dn_part = gemlv.email.Email(MIMEBase(MIMETYPE_DN.main, MIMETYPE_DN.sub))
		dn_fields = ['Disposition: manual-action/MDN-sent-manually; displayed']
		dn_fields += ['Final-Recipient: RFC822;%(finalrecipient)s' % {'finalrecipient': my_addressline.email}]
		if TheEmail.header[HDR_OR].nonempty:
			origrcpt = TheEmail.header[HDR_OR].decoded
			dn_fields += ['%(fieldname)s: RFC822;%(recipient)s' % {'fieldname': HDR_OR, 'recipient': origrcpt}]
		if TheEmail.header[HDR_MID].nonempty:
			messageid = TheEmail.header[HDR_MID].decoded
			dn_fields += ['Original-Message-ID: %s' % (messageid)]
		dn_part.payload_encoded = list2text(dn_fields)
		NewEmail.attach(dn_part)
		# TODO: set Disposition Notification name according to Accept-Language
		Attachments.append(None, [dn_part, glib.markup_escape_text(_("Disposition Notification")), 'mail-mark-read', None, '', calc_attachment_checksum(dn_part)])
		
		on_after_save_draft()
		panel_edit_message.grab_focus()

def act_req_dispos_notif():
	if toggle_rqdn.get_active():
		box_gdr = set_composer_header(HDR_GDR, 'Yes')
		box_gdr.readonly = True
		
		if not filter(None, get_composer_headers(['From', 'Reply-To'])):
			display_error(_(MSG_NO_ADDRESS_FOR_DNT))
		box_dnt = set_composer_header(HDR_DNT, '')
	else:
		clear_composer_headers(HDR_GDR)
		clear_composer_headers(HDR_DNT)

def turn_clicked_signal(ti, on):
	hid = ti.get_data('clicked-handler')
	if on:
		ti.handler_unblock(hid)
	else:
		ti.handler_block(hid)

def ninja_toggle(ti, on):
	turn_clicked_signal(ti, False)
	ti.set_active(on)
	turn_clicked_signal(ti, True)

def on_toggled(wdg):
	if wdg in [toggle_unimportant, toggle_important]:
		return on_toggled_importance(wdg)

def on_toggled_importance(wdg):
	if wdg.get_active():
		if wdg == toggle_important:
			toggle_unimportant.set_active(False)
		elif wdg == toggle_unimportant:
			toggle_important.set_active(False)
		return True
	return False

def act_importance():
	n = 1
	if toggle_important.get_active(): n = 2
	elif toggle_unimportant.get_active(): n = 0
	reset_composer_headers('Importance', [] if n == 1 else [Importances[n]])
	reset_composer_headers('Priority', [] if n == 1 else [Priorities[n]])

def act_edit_external():
	menubutton_send.set_sensitive(False)
	panel_edit_message.set_sensitive(False)
	menubutton_edit_external.set_sensitive(False)
	
	err = None
	fd, tmppath = mkstemp(prefix = PROGNAME + '-', suffix = '.txt')
	try:
		filehandler = os.fdopen(fd, 'w')
		filehandler.write(composer_text_buffer.get_text_all())
		set_xattrs(filehandler, {XATTR_CHARSET: 'UTF-8', XATTR_TYPE: MIMETYPE_TEXT}, tmppath)
		filehandler.close()
	except IOError as e:
		save_exception_traceback(e, traceback.format_exc())
		err = e
	except OSError as e:
		save_exception_traceback(e, traceback.format_exc())
		e.filename = tmppath
		err = e
	if err is not None:
		display_error(e)
		os.unlink(tmppath)
		on_edit_external_done(None)
		return
	thread = ExecThreadRunner(cliArgs.opener, cliArgs.opener_args + [tmppath], [cb_edit_external, tmppath])
	thread.start()

def cb_edit_external(status, filepath):
	if main_thread_alive():
		gtk.threads_enter()
		filehandler = None
		try:
			filehandler = open(filepath, 'r')
		except IOError as e:
			display_error(e)
			on_edit_external_done(None)
		else:
			on_edit_external_done(''.join(filehandler.readlines()))
			filehandler.close()
		try:
			os.unlink(filepath)
		except OSError as e:
			display_error(e)
		gtk.threads_leave()
	else:
		try:
			os.unlink(filepath)
		except OSError as e:
			warnx(str(e))

def on_edit_external_done(data):
	if data is not None:
		set_composer_text(data)
	menubutton_send.set_sensitive(True)
	panel_edit_message.set_sensitive(True)
	menubutton_edit_external.set_sensitive(True)

def set_unsaved(unsaved=True):
	win_comp.set_data('is-saved', not unsaved)
	win_comp.set_data('is-auto-saved', not unsaved)
	if unsaved:
		win_comp.set_data('email-sent', False)
	
	s = menubutton_save_draft.get_label()
	endmark = '*'
	endmark_re = re.escape(endmark)
	if unsaved:
		s = re.sub('(%s)?$' % (endmark_re), endmark, s)
	else:
		s = re.sub(endmark_re + '$', '', s)
	menubutton_save_draft.set_label(s)

def on_edit_message(tb):
	if tb.get_modified():
		set_unsaved()



### Main ###

PROGNAME = 'gemlv'
VERSION = '0.4'
USERAGENT = PROGNAME + '/' + VERSION
locale.setlocale(locale.LC_ALL, '')
gettext.textdomain(PROGNAME)
_ = gettext.gettext
setproctitle.setproctitle(PROGNAME)
MSG_NO_ADDRESS_FOR_DNT = "Set a From or Reply-To address to have Disposition Notification."
Importances = ('low','normal','high')
Priorities = ('non-urgent','normal','urgent')
Precedences = ('list', 'junk', 'bulk')
VALIDATION_RESULT_PASS, VALIDATION_RESULT_INVALID, VALIDATION_RESULT_NOTICE = 1, 0, 2
VAL_EMAIL = [{
		'require': r'(?i)' + RE_EMAIL_PERMISSIVE  + '$',
		'fail-result': VALIDATION_RESULT_INVALID,
	},
	{
		'require': r'^(?i)' + RE_EMAIL + '$',
		'fail-result': VALIDATION_RESULT_NOTICE,
	}]
VAL_ADDRESSES = [{
		# note: no left-anchor
		'require-repetative': r'(?i)' + RE_EMAIL_PERMISSIVE + '>?\s*(?:,\s*|$)',
		'fail-result': VALIDATION_RESULT_INVALID,
	},{
		'require-repetative': r'^(?i)' + RE_ADDRESS,
		'fail-result': VALIDATION_RESULT_NOTICE,
	}]
VAL_ADDRESS = [{
		# note: no left-anchor
		'require': r'(?i)' + RE_EMAIL_PERMISSIVE + '>?$',
		'fail-result': VALIDATION_RESULT_INVALID,
	},{
		'require': r'^(?i)' + RE_ADDRESS + '$',
		'fail-result': VALIDATION_RESULT_NOTICE,
	}]
VAL_AGE = [{
	'require': r'^\d+[smhdwy]$',
	}]
VAL_DATE = [{
	'require': r'^[a-zA-Z]+,\s*([12]\d|3[01]|0?[1-9])\s+[a-zA-Z]+\s+\d{4}\s+([01]\d|2[0-3])(:([0-5]\d)){2}\s+[+-]\d{4}(\s+\([A-Z]+\))?$',
	}]
VAL_IMPORTANCE = [{
	'require': '^(%s)$' % '|'.join('[%c%c]%s' % (x[0].upper(), x[0], x[1:]) for x in Importances),
	}]
VAL_PRIORITY = [{
	'require': '^(?i)(%s)$' % '|'.join(Priorities),
	}]
VAL_PRECEDENCE = [{
	'require': '^(?i)(%s)$' % '|'.join(Precedences),
	}]
COMPOSE_NEW, COMPOSE_REPLY, COMPOSE_REPLY_ALL, COMPOSE_REPLY_LIST, COMPOSE_FORWARD_MSG, COMPOSE_FORWARD_BODY, COMPOSE_MDN, COMPOSE_UNSUB = range(8)
TheEmail = None
PartPrimary = None
PartSecondary = None
FileChooserLastFolder = os.getcwd()
OriginatorHeaders = ['From', 'Sender', 'Return-Path', 'X-Sender', 'X-X-Sender', 'Reply-To']
SenderHeaders = ['From', 'Reply-To', 'Organization']
RecipientHeaders = ['To', 'Cc', 'Bcc']
DateTimeHeaders = ['Date', 'Reply-By', 'Expires', 'Deliver-At-Date']
PopularHeaders = [HDR_SUBJ]
AdvancedHeaders = [
	HDR_REF, 'In-Reply-To', HDR_DNT,
	'Generate-Delivery-Report', 'Prevent-NonDelivery-Report',
	'Priority', 'Importance', 'Precedence',
	'Newsgroups', 'Followup-To', 'Thread-Topic',
	'Content-Language', 'Accept-Language',
	'Deliver-At-Age', 'Deliver-At-Date', 'Reply-By', 'Expires',
	'User-Agent', 'X-Mailer',
]
# sensitive headers are stripped on opening an email for edit
# TODO: strip sensitive headers before send
SensitiveHeaders = [
	# TODO: other sensitive headers
	'X-getmail-retrieved-from-mailbox',
	'X-GMAIL-LABELS',
	# headers Clawsmail uses in draft emails:
	'X-Claws-*', 'S', 'SCF', 'RMID',
]
CoreTechnicalHeaders = [
	HDR_CT,
	HDR_CTE,
	HDR_CD,
	'Mime-Version',
]
TechnicalHeaders = [] \
	+ CoreTechnicalHeaders
	# TODO: other technical headers
EditExcludedHeaders = [
	'Auto-Submitted',
	'Delivered-To',  # sensitive?
	'DKIM-Signature',
	'Domainkey-Signature',
	'Message-ID',
	'Received',
	'Received-*',
	'X-Originating-IP',
	#'X-MS-*',
	#'X-*',
	] \
	+ SensitiveHeaders \
	+ TechnicalHeaders

AddressbookHeaders = [
	'From',
	'Reply-To',
	HDR_DNT,
	'To',
	'Cc',
	'Bcc',
]
HeaderValidators = {
	'From': VAL_ADDRESS,
	'Reply-To': VAL_ADDRESS,
	HDR_DNT: VAL_ADDRESS,
	'To': VAL_ADDRESSES,
	'Cc': VAL_ADDRESSES,
	'Bcc': VAL_ADDRESSES,
	'Deliver-At-Age': VAL_AGE,
	'Importance': VAL_IMPORTANCE,
	'Priority': VAL_PRIORITY,
	'Precedence': VAL_PRECEDENCE,
}
for h in DateTimeHeaders:
	HeaderValidators[h] = VAL_DATE
AutocompletionListSizeLimitOnEmptyInput = 10
AutocompletionHeaders = {
	'Importance': Importances,
	'Priority': Priorities,
	'Precedence': Precedences,
}
# obfuscate these headers on encrypted messages:
HeadersObfuscate = [
	HDR_SUBJ,
	'Thread-Topic',
]
DontLeakHeaders = [
	'Bcc',
]
MultiRecipientsMailtoFields = ['to', 'cc', 'bcc']  # in addition to rfc2368, gemlv deems Bcc to be safe too
AcceptableMailtoFields = MultiRecipientsMailtoFields + ['subject', 'keywords', 'body']

NewEmail = None

class PropertyStoreClass(object): pass
UserConfig = PropertyStoreClass()
UserConfig.show_importance_headers = False


Timers = {}
Timers2 = {}  # TODO: move timer* to timer2*
Props = PropertyTree()
gpg = gnupg.GPG(use_agent=True)
gpg.encoding = 'utf-8'
class GnuPGError(Exception):
	def __init__(self, x):
		if isinstance(x, (gnupg.Crypt, gnupg.Sign, gnupg.Verify, gnupg.ExportResult)):
			for k, v in x.__dict__.iteritems(): setattr(self, k, v)
			if hasattr(x, 'stderr'): self.message = x.stderr
		else:
			self.message = x
class GnuPGSignError(GnuPGError): pass
class GnuPGEncryptError(GnuPGError): pass
GnuPG_stripped_UIDs_keyring = {}


### Parse Arguments ###

argparser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
argparser.add_argument('--compose', action='store_true', help=_("Write a new Email"))
argparser.add_argument('--from', metavar='ADDRESS', help=_("New Email's writer's name and address"))
argparser.add_argument('--to', metavar='ADDRESS', action='append', help=_("New Email's Recipients, repeatable"))
argparser.add_argument('--cc', metavar='ADDRESS', action='append', help=_("Carbon Copy Recipients, repeatable"))
argparser.add_argument('--bcc', metavar='ADDRESS', action='append', help=_("Blind Carbon Copy Recipients, repeatable"))
argparser.add_argument('--subject', metavar='STRING', help=_("Subject"))
argparser.add_argument('--message', metavar='STRING', help=_("Message body"))
argparser.add_argument('--mailto', metavar='URL', help=_("Full 'mailto:' link"))
argparser.add_argument('--attach', '--attachment', metavar='FILE', action='append', help=_("Attachment file's path, repeatable"))
argparser.add_argument('--localedir', metavar='DIR', help=_("L10n base directory"))
argparser.add_argument('--opener', metavar='COMMAND', default='mimeopen-gui', help=_("File opener command"))
argparser.add_argument('--header', metavar='STRING', action='append', help=_("Add custom header(s) to the new Email"))
argparser.add_argument('FILE', nargs='?', help=_("Raw Email file for read or continue editing"))
sysargv = sys.argv[1:]
if os.path.basename(sys.argv[0]).find('compose') > -1 and '--compose' not in sysargv:
	sysargv.insert(0, '--compose')
if os.path.basename(sys.argv[0]).find('mailto') > -1:
	sysargv.insert(0, '--compose')
	sysargv.insert(1, '--mailto')
cliArgs = argparser.parse_args(args=sysargv)
del sysargv
if not cliArgs.compose and not cliArgs.FILE:
	warnx(_("Either compose mode or FILE is needed."))
	os._exit(1)

if cliArgs.localedir:
	gettext.bindtextdomain(PROGNAME, os.path.abspath(cliArgs.localedir))

openerargs = cliArgs.opener.split()
cliArgs.opener, cliArgs.opener_args = openerargs[0], openerargs[1:]

if xattr is None:
	warnx(_("Notice: no module xattr loaded"))
if hasattr(magic, 'open'):
	Magic = magic.open(magic.MAGIC_MIME_TYPE)
	Magic.load()
else:
	class magic0(object):
		def file(self, path):
			return magic.from_file(path, mime=True)
	Magic = magic0()

signal.signal(signal.SIGTERM, sighandler)
gtk.gdk.threads_init()


### Build GUI ###

gemlvtk.add_gtk_icon_to_stock('mail-attachment', _("Attach"))

win_main = gemlvtk.Window()
win_main.set_default_size(int(Props['ui/view/width'] or 832), int(Props['ui/view/height'] or 450))
win_main.connect('configure-event', on_window_configure)
start_evt = win_main.connect('map-event', win_main_show)
win_main.connect('delete-event', lambda a,b: act_quit())
gemlvtk.add_key_binding(win_main, '<Control>q', lambda a,b,c,d: act_quit())
gemlvtk.add_key_binding(win_main, '<Control>s', lambda a,b,c,d: act_save())
gemlvtk.add_key_binding(win_main, '<Control>o', lambda a,b,c,d: act_open())
gemlvtk.add_key_binding(win_main, '<Control>n', lambda a,b,c,d: act_compose())
gemlvtk.add_key_binding(win_main, '<Control><Shift>r', lambda a,b,c,d: act_reply(COMPOSE_REPLY))
gemlvtk.add_key_binding(win_main, '<Control>r', lambda a,b,c,d: act_reply(COMPOSE_REPLY_ALL))
gemlvtk.add_key_binding(win_main, '<Control>f', lambda a,b,c,d: act_reply(COMPOSE_FORWARD_MSG))
gemlvtk.add_key_binding(win_main, '<Control><Shift>f', lambda a,b,c,d: act_reply(COMPOSE_FORWARD_BODY))
gemlvtk.add_key_binding(win_main, '<Control>u', lambda a,b,c,d: act_view_source())
gemlvtk.add_key_binding(win_main, '<Control>h', lambda a,b,c,d: show_view_headers(not panel_view_header.get_data('all-headers')))
gemlvtk.add_key_binding(win_main, '<Control>a', lambda *_x: act_addressbook())

box_main = gtk.VBox(False, 5)
toolbar = gtk.Toolbar()
spanel_view_header = gtk.ScrolledWindow()
panel_view = gtk.VPaned()
panel_view_upper = gtk.VBox()
panel_view_headerbox = gtk.HBox()
panel_view_header = gtk.Label()
panel_view_avatar = gtk.VBox()
panel_view_subject = gtk.Label(' ')
spanel_view_subject = gemlvtk.Scrollable(panel_view_subject)
panel_body = gtk.HPaned()
spanel_parts = gtk.ScrolledWindow()
Parts = gtk.TreeStore(gobject.TYPE_PYOBJECT, str, str, gtk.gdk.Pixbuf, gobject.TYPE_PYOBJECT)  # update COL_PARTS_* constants if changed
panel_parts = gtk.TreeView(Parts)
selection_parts = panel_parts.get_selection()
panel_right = gtk.VBox()
lbl_content_location = gtk.Label()
panel_btnbox = gtk.Frame()
panel_btnbox2 = gtk.VBox()
panel_btnbox3 = gtk.HBox()
lbl_right = gtk.Label()
btnbox_right = gtk.VBox(True, 10)
btn_open = gemlvtk.StockButton(stock=gtk.STOCK_OPEN)
btn_save = gemlvtk.StockButton(stock=gtk.STOCK_SAVE)
btn_save_struct = gemlvtk.StockButton(label=_("Keep Structure"), stock=gtk.STOCK_SAVE)
panel_content_image = gtk.Frame()
spanel_content = gtk.ScrolledWindow()
panel_content = gtk.TextView()
tb_controls = gtk.Toolbar()
menubutton_filters = gtk.MenuToolButton(gtk.STOCK_ZOOM_FIT)
menu_filters = gtk.Menu()

win_main.add(box_main)
box_main.pack_start(toolbar, False, True)
box_main.pack_start(panel_view, True, True)
panel_view.pack1(panel_view_upper, False, True)
panel_view_upper.pack_start(panel_view_headerbox, True, True)
panel_view_headerbox.pack_start(spanel_view_header, True, True)
panel_view_headerbox.pack_start(panel_view_avatar, False, False)
panel_view_avatar.pack_start(gtk.Image(), False, False)
spanel_view_header.add_with_viewport(panel_view_header)
panel_view_upper.pack_start(spanel_view_subject, False, True)
panel_view.pack2(panel_body, True, True)
panel_body.pack1(spanel_parts, True, True)
panel_body.pack2(panel_right, True, True)
spanel_parts.add_with_viewport(panel_parts)
panel_right.pack_start(lbl_content_location, False, True)
panel_right.pack_start(panel_btnbox, True, True)
panel_btnbox.add(panel_btnbox2)
panel_btnbox2.pack_start(panel_btnbox3, True, False)
panel_btnbox3.pack_start(lbl_right, True, False)
panel_btnbox3.pack_start(btnbox_right, True, False)
btnbox_right.pack_start(btn_open, False, False)
btnbox_right.pack_start(btn_save, False, False)
btnbox_right.pack_start(btn_save_struct, False, False)
panel_right.pack_start(panel_content_image, True, True)
panel_content_image.add(gtk.Image())
panel_right.pack_start(spanel_content, True, True)
spanel_content.add_with_viewport(panel_content)
panel_right.pack_start(tb_controls, False, True)

win_main.set_icon_name('emblem-mail')
win_main.set_geometry_hints(min_width=100, min_height=250)
toolbar.set_style(gtk.TOOLBAR_BOTH)
panel_view.set_position(int(Props['ui/view/headers/height'] or 124))
panel_view.connect('notify::position', lambda paned, pos: timer2_once(1.5, lambda: Props.__setitem__('ui/view/headers/height', paned.get_position())))
spanel_view_header.set_policy(gtk.POLICY_NEVER, gtk.POLICY_AUTOMATIC)
spanel_view_header.connect('size-allocate', resize_panel_view_header)
panel_view_header.set_line_wrap(True)
panel_view_header.set_padding(4, 2)
panel_view_header.set_alignment(0, 0)
panel_view_header.set_justify(gtk.JUSTIFY_LEFT)
panel_view_header.set_selectable(True)
panel_view_header.connect('populate-popup', populate_header_menu)
panel_view_header.connect('scroll-event', on_scroll_on_button_font, panel_view_header, gtk.gdk.CONTROL_MASK)
panel_view_avatar.children()[0].set_padding(6, 1)
panel_view_subject.set_selectable(True)
panel_view_subject.set_padding(5, 4)
panel_view_subject.set_alignment(0, 0)
panel_view_subject.set_justify(gtk.JUSTIFY_LEFT)
panel_body.set_position(int(Props['ui/view/attachments/width'] or 175))
panel_body.connect('notify::position', lambda paned, pos: timer2_once(1.5, lambda: Props.__setitem__('ui/view/attachments/width', paned.get_position())) if paned.get_position()>0 else True)
spanel_parts.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
spanel_content.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
panel_parts.set_headers_visible(False)
panel_parts.drag_source_set(gtk.gdk.BUTTON1_MASK, [], gtk.gdk.ACTION_COPY)
panel_parts.connect('button-press-event', on_panel_parts_button_press_event)
panel_parts.connect('drag-begin', drag_part_begin)
panel_parts.connect('drag-data-get', drag_part_data)
panel_parts.connect('drag-end', drag_part_end)
selection_parts.set_mode(gtk.SELECTION_MULTIPLE)
selection_parts.connect('changed', on_select_parts)
lbl_content_location.set_alignment(0, 0)
lbl_content_location.set_padding(2, 5)
lbl_right.set_alignment(0, 0)
lbl_right.set_justify(gtk.JUSTIFY_LEFT)
lbl_right.set_selectable(True)
btn_open.connect('clicked', lambda wdg: act_open())
btn_save.connect('clicked', lambda wdg: act_save())
btn_save_struct.connect('clicked', lambda wdg: act_save_struct())
panel_content_image.connect('size-allocate', on_allocate_panel_content_image)
panel_content.set_editable(False)
panel_content.set_wrap_mode(getattr(gtk, 'WRAP_'+((Props['ui/view/body/wrapmode'] or 'WORD').upper().replace('-', '_'))))
panel_content.connect('notify::wrap-mode', lambda tv, wrapmode: timer2_once(1.5, lambda: Props.__setitem__('ui/view/body/wrapmode', tv.get_wrap_mode().value_nick)))
panel_content.connect('scroll-event', on_scroll_on_button_font, panel_content, gtk.gdk.CONTROL_MASK)
tb_controls.set_icon_size(gtk.ICON_SIZE_MENU)
tb_controls.set_style(gtk.TOOLBAR_ICONS)
menubutton_filters.set_homogeneous(False)
menubutton_filters.set_menu(menu_filters)
menubutton_filters.set_arrow_tooltip_text(_("Filters"))


toolbuttons = [
	(_("Compose"), gtk.STOCK_EDIT, None, act_compose, None),
	(_("Send MDN"), 'mail-reply-sender', _("Send a Message Disposition Notification"), act_dispos_notif, None),
	(_("Reply"), 'mail-reply-sender', _("Reply")+'\n'+_("Right click:")+' '+_("Send a Message Disposition Notification"), (act_reply, COMPOSE_REPLY), act_dispos_notif),
	(_("Reply to All"), 'mail-reply-all', None, (act_reply, COMPOSE_REPLY_ALL), None),
	(_("Reply to List"), 'mail-reply-all', None, (act_reply, COMPOSE_REPLY_LIST), None),
	(_("Forward"), 'mail-forward', _("Forward envelope")+'\n'+_("Right click:")+' '+_("Forward letter"), (act_reply, COMPOSE_FORWARD_MSG), (act_reply, COMPOSE_FORWARD_BODY)),
	(None, None, None, 'separator', None),
	(_("Unsubscribe"), 'stop', None, act_unsubscribe, None),
	(_("Report Spam"), 'mail-mark-junk', None, act_report_spam, None),
	(_("Report Ham"), 'mail-mark-notjunk', None, (act_report_spam, False), None),
	(None, None, None, 'space', None),
	(None, gtk.STOCK_CLOSE, None, act_quit, None),
]
x, menubutton_mdn, x, x, menubutton_replytolist, x, x_, menubutton_unsubscribe, menubutton_spam, menubutton_ham, x_, menubutton_quit \
= load_toolitems(toolbar, toolbuttons)
l = menubutton_mdn.get_label()
menubutton_mdn.set_data('saved-label', l)
menubutton_mdn.set_markup(PMU_WARN + l + PMU_WARN_CLOSE)
setup_treeview__icon_label(panel_parts)

def ToolItemDeclaration_wrap(tv):
	return (_("Wrap"), gtk.STOCK_JUSTIFY_LEFT, _("Soft / Hard / No Wrap")+'\n'+_("Right click:")+' '+_("No / Soft / Hard Wrap"), (act_wrap, tv), (act_wrap, tv, -1))
def ToolItemDeclaration_font(tv):
	return (None, gtk.STOCK_SELECT_FONT, _("Change Font")+'\n'+_("Right click:")+' '+_("monospace")+'\n'+_("Scroll: zoom +/-"), (act_font, tv), (act_font_switch, tv))

toolbuttons = [
	(None, 'emblem-generic', _("Unimportant"), None, None),
	(None, 'emblem-important', _("Important"), None, None),
	(None, 'mail-reply-sender', _("Replied"), None, None),
	(None, 'mail-forward', _("Forwarded"), None, None),
	(None, 'mail-mark-read', _("MDN is sent"), None, None),
	(None, 'mail-mark-junk', _("Spam"), None, None),
	(None, 'mail-signed-verified', _("Valid signature"), show_signature_info, None),
	(None, 'dialog-warning', _("Invalid signature"), show_signature_info, None),
	(None, None, None, 'space', None),
	(None, gtk.STOCK_OPEN, None, act_open, None),
	(None, gtk.STOCK_SAVE, _("Save")+'\n'+_("Right click:")+' '+_("Save with keeping structure"), act_save, act_save_struct),
	(None, None, None, 'separator', None),
	(_("Unfilter"), menubutton_filters, _("Filter / Unfilter"), act_view_source, None),
	ToolItemDeclaration_wrap(panel_content),
	ToolItemDeclaration_font(panel_content),
]
stck_unimp, stck_imp, stck_repl, stck_fwd, stck_mdn, stck_spam, stck_sign_good, stck_sign_bad, x_, btn_open2, btn_save2, x_, x, x, btn_font \
= load_toolitems(tb_controls, toolbuttons)
btn_font.connect('scroll-event', on_scroll_on_button_font, panel_content, None)


### Build Composer GUI ###

win_comp = gemlvtk.Window()
win_comp.set_default_size(int(Props['ui/composer/width'] or win_main.get_default_size()[0]), int(Props['ui/composer/height'] or win_main.get_default_size()[1]))
win_comp.connect('configure-event', on_window_configure)
win_comp.connect('delete-event', lambda a,b: act_close_edit())
gemlvtk.add_key_binding(win_comp, '<Control>'+('q' if cliArgs.compose else 'w'), lambda a,b,c,d: act_close_edit())
gemlvtk.add_key_binding(win_comp, '<Control>s', lambda a,b,c,d: act_save_edit())
gemlvtk.add_key_binding(win_comp, '<Control><Shift>s', lambda a,b,c,d: act_save_edit(True))
gemlvtk.add_key_binding(win_comp, 'F4', lambda a,b,c,d: act_edit_external())
gemlvtk.add_key_binding(win_comp, '<Control>h', lambda a,b,c,d: act_tgl_comp_hdr())
gemlvtk.add_key_binding(win_comp, '<Control>a', lambda *_x: act_addressbook())

box_compose = gtk.VBox()
tb_compose = gtk.Toolbar()
panel_compose = gtk.VPaned()
panel_upper = gtk.HPaned()
spanel_comp_header = gtk.ScrolledWindow()
menu_add_header = gtk.Menu()
panel_comp_header = gtk.VBox(False, 0)
UnionHeadersStore = gtk.ListStore(str)
spanel_attachments = gtk.ScrolledWindow()
Attachments = gtk.TreeStore(gobject.TYPE_PYOBJECT, str, str, gtk.gdk.Pixbuf, str, str)  # update COL_ATTACHMENTS_* constants if changed
Attachments.set_data('row-changed-signal-handler-id', Attachments.connect('row-changed', on_composer_attachments_row_changed))
panel_attachments = gtk.TreeView(Attachments)
panel_edit = gtk.VBox()
panel_subject = gtk.HBox(False, 5)
panel_subject.set_border_width(4)
entry_subject = gtk.Entry()
frame_edit = gtk.Frame()
spanel_edit_message = gtk.ScrolledWindow()
composer_text_buffer = TextBuffer()
panel_edit_message = gtk.TextView(composer_text_buffer)
tb_comp_controls = gtk.Toolbar()

win_comp.add(box_compose)
box_compose.pack_start(tb_compose, False, True)
box_compose.pack_start(panel_compose, True, True)
panel_compose.pack1(panel_upper, True, True)
panel_upper.pack1(spanel_comp_header, True, True)
spanel_comp_header.add_with_viewport(panel_comp_header)
panel_upper.pack2(spanel_attachments, False, True)
spanel_attachments.add_with_viewport(panel_attachments)
panel_attachments.set_headers_visible(False)
panel_compose.pack2(panel_edit, True, True)
panel_edit.pack_start(panel_subject, False, True)
panel_subject.pack_start(gtk.Label(_("Subject")), False, True)
panel_subject.pack_start(entry_subject, True, True)
panel_edit.pack_start(frame_edit, True, True)
frame_edit.add(spanel_edit_message)
spanel_edit_message.add(panel_edit_message)
box_compose.pack_start(tb_comp_controls, False, True)

win_comp.set_icon_name('mail-message-new')
win_comp.set_geometry_hints(min_width=132, min_height=200)
tb_compose.set_style(gtk.TOOLBAR_BOTH)
spanel_comp_header.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_ALWAYS)
spanel_comp_header.connect('button-press-event', open_comp_hdr_menu)
panel_comp_header.set_border_width(4)
spanel_attachments.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
spanel_attachments.drag_dest_set(0, [], 0)
#spanel_attachments.drag_dest_set(gtk.DEST_DEFAULT_MOTION | gtk.DEST_DEFAULT_HIGHLIGHT, [('text/uri-list', 0, 0), ('GTK_TEXT_BUFFER_CONTENTS', 0, 0)], gtk.gdk.ACTION_COPY)
spanel_attachments.connect('drag-motion', drop_attachment_motion)
spanel_attachments.connect('drag-drop', drop_attachment_drop)
spanel_attachments.connect('drag-data-received', drop_attachment_data)
panel_attachments.get_selection().set_mode(gtk.SELECTION_MULTIPLE)
panel_attachments.set_reorderable(True)
panel_attachments.connect('drag-data-received', drop_attachment_reorder_data)
panel_attachments.connect('drag-drop', drop_attachment_reorder_drop)
panel_attachments.connect('focus-out-event', lambda w, e: w.get_selection().unselect_all())
panel_attachments.connect('key-press-event', on_keypress_attachments)
panel_upper.set_position(int(Props['ui/composer/headers/width'] or (win_comp.get_default_size()[0] - 242)))
panel_upper.connect('notify::position', lambda paned, pos: timer2_once(1.5, lambda: Props.__setitem__('ui/composer/headers/width', paned.get_position())))
panel_compose.set_position(int(Props['ui/composer/headers/height'] or 125))
panel_compose.connect('notify::position', lambda paned, pos: timer2_once(1.5, lambda: Props.__setitem__('ui/composer/headers/height', paned.get_position())))
entry_subject.connect('changed', on_edit_subject)
spanel_edit_message.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
panel_edit_message.set_wrap_mode(getattr(gtk, 'WRAP_'+((Props['ui/composer/body/wrapmode'] or 'WORD').upper().replace('-', '_'))))
panel_edit_message.connect('notify::wrap-mode', lambda tv, wrapmode: timer2_once(1.5, lambda: Props.__setitem__('ui/composer/body/wrapmode', tv.get_wrap_mode().value_nick)))
composer_text_buffer.connect('modified-changed', on_edit_message)
composer_text_buffer.connect('changed', on_change_message)
panel_edit_message.connect('scroll-event', on_scroll_on_button_font, panel_edit_message, gtk.gdk.CONTROL_MASK)
panel_edit_message.connect('populate-popup', populate_composer_textview_menu)
frame_edit.set_shadow_type(gtk.SHADOW_IN)
tb_comp_controls.set_icon_size(gtk.ICON_SIZE_MENU)
tb_comp_controls.set_style(gtk.TOOLBAR_ICONS)

for name in SenderHeaders:
	mi = gtk.CheckMenuItem(_("Specify %s") % (_(name)))
	mi.set_data('chname', name)
	mi.connect('toggled', act_comp_hdr_menuitem)
	menu_add_header.append(mi)
mi = gemlvtk.StockMenuItem(stock_id=gtk.STOCK_ADD, label=_("Add Recipient"))
mi.connect('activate', act_comp_hdr_menuitem, 'To')
menu_add_header.append(mi)
menu_add_header.append(gtk.SeparatorMenuItem())
mi = gemlvtk.StockMenuItem(stock_id=gtk.STOCK_ADD, label=_("Add Custom Header"))
mi.connect('activate', act_comp_hdr_menuitem, '')
menu_add_header.append(mi)
menuitem_all_comp_hdr = gtk.CheckMenuItem(_("Show Custom Headers"))
menuitem_all_comp_hdr.connect('toggled', act_all_comp_hdr)
menu_add_header.append(menuitem_all_comp_hdr)
menu_add_header.show_all()

toolbuttons = [
	(_("Send"), 'mail-send', _("Send")+'\n'+_("Right click:")+' '+_("Save As in ready-to-send format"), act_send, act_send_to_file),
	(None, gtk.STOCK_SAVE, _("Save")+'\n'+_("Right click:")+' '+_("Save As..."), act_save_edit, (act_save_edit, True)),
	(_("Addressbook"), 'x-office-address-book', None, act_addressbook, None),
	(_("Attach Files"), 'mail-attachment', None, act_attach, None),
	(None, None, None, 'space', None),
	(None, gtk.STOCK_CLOSE, None, act_close_edit, None),
]
menubutton_send, menubutton_save_draft, x, x, x_, x \
= load_toolitems(tb_compose, toolbuttons)

# Add columns to Composer's Attachments panel
setup_treeview__icon_label(panel_attachments, label_edit_cb=rename_attachment)
tvc = gtk.TreeViewColumn()
cr_txt = gtk.CellRendererText()
cr_txt.set_alignment(1, 0)
tvc.pack_start(cr_txt, True)
tvc.add_attribute(cr_txt, 'text', COL_ATTACHMENTS_SIZE_LABEL)
panel_attachments.append_column(tvc)


for h in SenderHeaders + RecipientHeaders + PopularHeaders + AdvancedHeaders:
	UnionHeadersStore.append([h])

toolbuttons = [
	(None, gemlvtk.LabelsToolItem(), None, None, None),
	(None, None, None, 'space', None),
	(None, gemlvtk.StockToggleToolButton('dialog-password'), _("Encrypt"), None, None),
	(None, gemlvtk.StockToggleToolButton('mail-signed'), _("Crypto-Sign"), None, None),
	(None, gemlvtk.StockToggleToolButton('mail-mark-read'), _("Ask Disposition Notification"), act_req_dispos_notif, None),
	(None, None, None, 'separator', None),
	(_("Unimportant"), gemlvtk.StockToggleToolButton('emblem-generic'), _("Unimportant"), act_importance, None),
	(_("Important"), gemlvtk.StockToggleToolButton('emblem-important'), _("Important"), act_importance, None),
	(None, None, None, 'separator', None),
	(None, gtk.STOCK_EDIT, _("Edit with External Program"), act_edit_external, None),
	ToolItemDeclaration_wrap(panel_edit_message),
	ToolItemDeclaration_font(panel_edit_message),
]
tb_comp_label, x_, toggle_encrypt, toggle_sign, toggle_rqdn, x_, toggle_unimportant, toggle_important, x_, menubutton_edit_external, x, btn_font2 \
= load_toolitems(tb_comp_controls, toolbuttons)
toggle_rqdn.connect('toggled', on_toggled)
toggle_unimportant.connect('toggled', on_toggled)
toggle_important.connect('toggled', on_toggled)
btn_font2.connect('scroll-event', on_scroll_on_button_font, panel_edit_message, None)


if cliArgs.compose:
	setproctitle.setproctitle(PROGNAME+'-compose')
	open_composer(reason=COMPOSE_NEW)
	if cliArgs.FILE:
		# Open existing Email for edit.
		win_comp.set_data('saved-to-file', cliArgs.FILE)
		on_after_save_draft()
		try:
			edit_eml, fh = email_from_file(cliArgs.FILE)
			fh.close()
		except RuntimeError:
			sys.exit(1)
		
		# Import headers.
		supersedes = []
		for header in edit_eml.headers.items:
			if header.name == HDR_MID:
				supersedes.append(header.value.decoded)
			elif header.name == HDR_SUBJ:
				set_composer_subject(header.value.decoded)
			if any(wildcardmatch(header.name, exclude_header) for exclude_header in EditExcludedHeaders):
				# Do not include these headers in an incompleted email.
				warnx("Skip header '%s' in email editing." % (header.name,))
			else:
				add_composer_header(header.name, header.value.decoded)
		reset_composer_headers('Supersedes', [', '.join(supersedes)])
		
		body_found = False
		def detect_body_part(part):
			if not body_found and part.content_type == MIMETYPE_TEXT:
				set_composer_text(decode_readably(part.payload_decoded, part))
				# Prevent this part to be treated as attachment. This is the body part.
				return False
			# Attach this part.
			NewEmail.attach(part)
			# Allow this part to be appeared in attachments panel.
			return True
		
		# Import attachments.
		if edit_eml.is_multipart():
			for part in edit_eml.parts:
				add_already_attached_parts(None, part, detect_body_part)
		else:
			# Not a multipart email, set body to payload.
			set_composer_text(decode_readably(edit_eml.payload_decoded, edit_eml))
	else:
		# Open a clear composer window.
		add_composer_agent_headers()
		if not cliArgs.message:
			composer_text_buffer.clear()
			append_composer_text_default_user_signature()
			composer_text_buffer.place_cursor(composer_text_buffer.get_start_iter())
	
	if cliArgs.mailto:
		mailto = parse_mailto(cliArgs.mailto)
		add_composer_mailto(mailto)
	if getattr(cliArgs, 'from'):
		reset_composer_headers('From', [getattr(cliArgs, 'from')])
	if cliArgs.to:
		add_composer_headers('To', cliArgs.to)
	if cliArgs.cc:
		add_composer_headers('Cc', cliArgs.cc)
	if cliArgs.bcc:
		add_composer_headers('Bcc', cliArgs.bcc)
	if len(get_composer_headers(RecipientHeaders)) < 1:
		# Add an empty To header unless any recipient was given.
		add_composer_header('To')
	if cliArgs.subject:
		set_composer_subject(cliArgs.subject)
	if cliArgs.header:
		for header in cliArgs.header:
			if header.find(':') == -1: header += ':'
			hname, hval = re.split(': ?', header, 1)
			add_composer_headers(gemlv.email.Header(hname).name, [hval])
	if cliArgs.message:
		set_composer_text(cliArgs.message)
	if cliArgs.attach:
		for path in cliArgs.attach:
			attach_path(path, path)
		del path
	on_after_save_draft()
	if any(bool(x) for x in get_composer_headers(HDR_XSD)):
		win_comp.set_data('email-sent', True)
	panel_edit_message.grab_focus()
else:
	win_main.show_all()
	menubutton_mdn.hide()
	menubutton_replytolist.hide()
	menubutton_unsubscribe.hide()
	panel_view_avatar.hide()
	lbl_content_location.hide()
	panel_btnbox.hide()
	panel_content_image.hide()
	stck_unimp.hide()
	stck_imp.hide()
	stck_repl.hide()
	stck_fwd.hide()
	stck_mdn.hide()
	stck_spam.hide()
	stck_sign_good.hide()
	stck_sign_bad.hide()

gtk.main()
if Timers2.keys():
	warnx(_("Executing outstanding timers."))
timer2_flush()
if len(threading.enumerate()) > 1:
	warnx(_("Waiting background threads to complete."))

# TODO: make .set_label and .set_text consistent on gtk.Label()s

# FIXME: empty Supersedes; 2 Subject; dont send HDR_XSD/QUEUEID, dont load CORE HEADERS
