#!/usr/bin/env python

import os
import sys
import signal
import select
import fcntl
import gtk
import gobject
import glib
import pango
import gettext
import email
import re
from tempfile import mkstemp
from mimetypes import guess_extension
from fnmatch import fnmatch
import argparse
try:
	import xattr
except ImportError:
	sys.stderr.write(_("Notice: no module xattr loaded") + "\n")
	xattr = None


### helper classes, functions ###

class StockToolButton(gtk.ToolButton):
	def __init__(self, label=None, stock=None, tooltip=None):
		super(self.__class__, self).__init__()
		if stock is not None:
			if stock in gtk.stock_list_ids():
				if stock is not None: self.set_stock_id(stock)
			else:
				self.set_icon_name(stock)
		if label is not None:
			self.set_label(label)
		if tooltip is not None:
			self.set_tooltip_text(tooltip)
	def set_pixbuf(self, pxb):
		a = self.get_children()[0]
		a = a.get_children()[0]
		img, a = a.get_children()
		img.set_from_pixbuf(pxb)
		img.props.visible = True

class StockButton(gtk.Button):
	def __init__(self, label=None, stock=None, use_underline=True, icon_size=None):
		if stock is not None and stock in gtk.stock_list_ids():
			stock_tmp = stock
		else:
			stock_tmp = gtk.STOCK_ABOUT
		super(self.__class__, self).__init__(stock=stock_tmp, use_underline=use_underline)
		if label is not None:
			self.set_markup(label)
		if stock is None:
			self.set_icon('')
		elif stock not in gtk.stock_list_ids():
			self.set_icon(stock)
		if icon_size is not None:
			self.set_icon(stock, icon_size)
	def __get_children(self):
		align = self.get_children()[0]
		hbox = align.get_children()[0]
		return hbox.get_children()
	def set_label(self, label):
		_, lbl = self.__get_children()
		lbl.set_label(label)
	def set_markup(self, label):
		_, lbl = self.__get_children()
		lbl.set_markup(label)
	def set_icon(self, icon, size=gtk.ICON_SIZE_BUTTON):
		img, _ = self.__get_children()
		if type(icon) == str:
			if icon == '':
				img.props.visible = False
			else:
				img.set_from_icon_name(icon, size)
				img.props.visible = True
		else:
			img.set_from_pixbuf(icon)
			img.props.visible = True

class cfgparser:
	def __init__(self, name, **kvargs):
		self.var = {'regex': '^\s*([^;#].*)', 'split': [1],}
		for k in 'regex', 'splitgroups':
			if not self.var.has_key(k): self.var[k] = None
			if kvargs.has_key(k): self.var[k] = kvargs[k]
		suff = '.conf'
		self.filehandlers = []
		for t in (os.environ['HOME'], '.config', PROGNAME, name + suff), (os.path.sep, 'etc', PROGNAME, name + suff), (name + suff,),:
			n = os.path.join(*t)
			try:
				fh = open(n, 'r')
				self.filehandlers.append(fh)
			except IOError:
				pass
	
	def __iter__(self):
		return self
	
	def next(self):
		if len(self.filehandlers) == 0:
			raise StopIteration
		else:
			fh = self.filehandlers[0]
			while True:
				ln = fh.readline()
				if ln == '':
					fh.close()
					self.filehandlers.reverse()
					self.filehandlers.pop()
					self.filehandlers.reverse()
					if len(self.filehandlers) == 0:
						raise StopIteration
					fh = self.filehandlers[0]
					continue
				m = re.match(self.var['regex'], ln)
				if m:
					grps = []
					n = 0
					for grp in m.groups():
						n += 1
						if n in self.var['splitgroups']:
							if grp is None:
								grp = []
							else:
								grp = re.split('\s+', grp)
						grps.append(grp)
					return grps
	
	def __del__(self):
		for fh in self.filehandlers:
			fh.close()

class pipereader:
	def __init__(self, inputstr, cmd, args=[], exitdict=None):
		self.exitdict = exitdict
		args = args[:]
		args.insert(0, os.path.basename(cmd))
		child_read, parent_write, parent_read, child_write = get_pipe_handlers(2)
		pid = os.fork()
		if pid == 0:
			parent_read.close()
			parent_write.close()
			os.dup2(child_read.fileno(), sys.stdin.fileno())
			os.dup2(child_write.fileno(), sys.stdout.fileno())
			try:
				os.execvp(cmd, args)
			except OSError, e:
				sys.stderr.write(str(e))
			os._exit(127)
		else:
			child_read.close()
			child_write.close()
			parent_write.write(inputstr)
			parent_write.close()
			self.pid = pid
			self.reader = parent_read
	
	def __iter__(self):
		return self
	
	def next(self):
		s = self.reader.readline()
		if s == '':
			raise StopIteration
		else:
			return s
	
	def __del__(self):
		self.reader.close()
		_, status = os.waitpid(self.pid, 0)
		if self.exitdict is not None:
			sig = status & 0x7F
			core = status & 0x80 >> 7
			excode = status >> 8
			exitdict['status'] = excode
			exitdict['signal'] = sig
			exitdict['coredumped'] = core

class cyclelist(list):
	def __init__(self, lst, **kvargs):
		if type(lst) != type([]):
			raise TypeError('need list, %s found' % (str(type(lst))))
		if len(lst) < 1:
			raise ValueError('need non-empty list')
		super(self.__class__, self).__init__(lst)
		self.idx = 0
		if kvargs.has_key('at'):
			self.whirl(kvargs['at'])
	
	def whirl(self, val):
		for i in range(0, len(self)):
			if self[i] == val:
				self.idx = i
				return val
		return None
	
	def turn(self, n=1):
		self.idx = (self.idx + n) % len(self)
		return self[self.idx]
	
	def __getitem__(self, i):
		return super(self.__class__, self).__getitem__(i % len(self))

	def __setitem__(self, i, v):
		return super(self.__class__, self).__setitem__(i % len(self), v)
	
	def __str__(self):
		return str(self[self.idx])

def add_key_binding(widget, keyname, callback):
	accelgroup = gtk.AccelGroup()
	key, modifier = gtk.accelerator_parse(keyname)
	accelgroup.connect_group(key, modifier, gtk.ACCEL_VISIBLE, callback)
	widget.add_accel_group(accelgroup)

def display_error(e):
	text = None
	if isinstance(e, OSError) or isinstance(e, IOError):
		text = "%s (#%d)\n%s" % (e.strerror, e.errno, e.filename)
	elif isinstance(e, Exception):
		text = e.message
	elif type(e) == type([]):
		text = ''.join(e)
	if text is None:
		text = str(e)
	dlg = gtk.MessageDialog(None, gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_ERROR, gtk.BUTTONS_OK, text)
	dlg.set_title(_("Error"))
	dlg.run()
	dlg.destroy()

def question(msg, stock_yes=None):
	dlg = gtk.MessageDialog(None, gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_QUESTION, gtk.BUTTONS_YES_NO, msg)
	dlg.set_title(_("Question"))
	if stock_yes is not None:
		dlg.get_widget_for_response(gtk.RESPONSE_YES).hide()
		btn_yes = StockButton(label=stock_yes[0], stock=stock_yes[1])
		dlg.add_action_widget(btn_yes, gtk.RESPONSE_YES)
		btn_yes.show()
	resp = dlg.run()
	dlg.destroy()
	return (resp == gtk.RESPONSE_YES)

def choose_dialog(action, filename=None):
	global LastFolder
	selected = None
	
	btn_accept_stock = gtk.STOCK_SAVE
	if action == gtk.FILE_CHOOSER_ACTION_OPEN:
		btn_accept_stock = gtk.STOCK_OPEN
	dlg = gtk.FileChooserDialog(action=action, buttons=(gtk.STOCK_CANCEL, gtk.RESPONSE_REJECT, btn_accept_stock, gtk.RESPONSE_ACCEPT))
	if LastFolder is not None: dlg.set_current_folder(LastFolder)
	if filename is not None: dlg.set_current_name(filename)
	btn_cwd = StockButton(label=_("Working Dir"), stock=gtk.STOCK_JUMP_TO)
	dlg.add_action_widget(btn_cwd, gtk.RESPONSE_NO)
	btn_cwd.show()
	while True:
		resp = dlg.run()
		if resp == gtk.RESPONSE_ACCEPT:
			selected = dlg.get_filename()
			break
		elif resp == gtk.RESPONSE_NO:
			dlg.set_current_folder(os.getcwd())
		else:
			break
	LastFolder = dlg.get_current_folder()
	dlg.destroy()
	return selected

def choose_save_file(filename=None):
	return choose_dialog(gtk.FILE_CHOOSER_ACTION_SAVE, filename)

def choose_save_folder():
	return choose_dialog(gtk.FILE_CHOOSER_ACTION_SELECT_FOLDER)

def choose_open_file():
	return choose_dialog(gtk.FILE_CHOOSER_ACTION_OPEN)

def get_pipe_handlers(npairs):
	pipes = []
	for n in range(0, npairs):
		r, w = os.pipe()
		pipes.append(os.fdopen(r, 'r'))
		pipes.append(os.fdopen(w, 'w'))
	return pipes

def joinNone(glue, dflt, lst):
	lst2 = []
	for e in lst:
		lst2.append(dflt if e is None else e)
	return glue.join(lst2)

def which(cmd):
	def is_executable(p):
		return (os.path.isfile(p) and os.access(p, os.X_OK))
	
	ap, bn = os.path.split(cmd)
	if ap:
		if is_executable(cmd):
			return cmd
	else:
		for d in os.environ['PATH'].split(os.path.pathsep):
			p = os.path.join(d, cmd)
			if is_executable(p):
				return p
	return None

def run_async(cmd, args, postrun):
	args = args[:]
	args.insert(0, os.path.basename(cmd))
	pid1 = os.fork()
	if pid1 == 0:
		os.closerange(0, 255)
		pid2 = os.fork()
		if pid2 == 0:
			pid3 = os.fork()
			if pid3 == 0:
				os.execvp(cmd, args)
				os._exit(127)
			else:
				_, status = os.waitpid(pid3, 0)
				excode = status >> 8
				postrun[0](*postrun[1:])
				os._exit(excode)
		else:
			os._exit(0)
	else:
		os.waitpid(pid1, 0)

### private functions ###

def win_main_show(widget, event):
	win_main.disconnect(start_evt)
	panel_content.set_data('saved-font', get_current_font(panel_content))
	if args.FILE: load_file(args.FILE)

def load_file(filename):
	global Email
	fh = open(filename, 'r')
	Email = email.message_from_file(fh)
	fh.close()
	
	panel_header.set_markup(get_headers_markup(Email))
	clear_parts(Parts)
	if Email.is_multipart():
		pos = panel_body.get_data('saved-position')
		if pos is not None:
			panel_body.set_position(pos)
			panel_body.set_data('saved-position', None)
	else:
		panel_body.set_data('saved-position', panel_body.get_position())
		panel_body.set_position(0)
	
	load_parts(Email, Parts, Parts.get_iter_root())
	panel_parts.expand_all()
	if Email.is_multipart():
		if PartPrimary is not None:
			selection_parts.select_iter(PartPrimary)
		elif PartSecondary is not None:
			selection_parts.select_iter(PartSecondary)
		else:
			selection_parts.select_path((0,))
	else:
		selection_parts.select_path((0,))

def clear_parts(model):
	model.clear()

def load_parts(eml, model, parent):
	global PartPrimary
	global PartSecondary
	
	label = PMU_MIME + glib.markup_escape_text(eml.get_content_type()) + PMU_MIME_CLOSE
	filename = eml.get_filename()
	if filename is not None: label = glib.markup_escape_text(filename) + ' ' + label
	stock = get_stock_by_mime(eml.get_content_maintype(), eml.get_content_subtype())
	pixb = None
	
	iterator = model.append(parent, [eml, label, stock, pixb])
	if PartPrimary is None and eml.get_content_type() == 'text/plain':
		PartPrimary = iterator
	if PartSecondary is None and eml.get_content_type() == 'text/html':
		PartSecondary = iterator
	if type(eml.get_payload()) == type([]):
		for part in eml.get_payload():
			load_parts(part, model, iterator)

def clear_content(s=''):
	bufr = panel_content.get_buffer()
	bufr.set_text(s)
	panel_content.set_sensitive(False)
	return bufr

def decode_properly(s, eml):
	charset = eml.get_content_charset()
	if charset is None:
		s = s.decode('utf-8', 'replace')
	elif charset.lower() not in ['utf-8', 'utf_8', 'utf8']:
		s = s.decode(charset, 'replace')
	return s

def get_content_properly(eml):
	s = eml.get_payload(decode=1)
	if s is None:
		s = eml.as_string()
	return decode_properly(s, eml)

def set_content_text(s, eml=None):
	if s is None:
		s = get_content_properly(eml)
	elif eml is not None:
		s = decode_properly(s, eml)
	panel_content.get_buffer().set_text(s)
	panel_content.set_sensitive(True)

def load_part(eml, filt=None):
	if eml is None: return
	clear_content(_("Loading failed"))
	panel_content.set_data('view-unfiltered', False)

	if filt is None:
		filt = get_filter_by_mime(eml.get_content_maintype(), eml.get_content_subtype())
	
	if filt is None:
		if type(eml.get_payload()) == type([]) and not(eml.preamble is None and eml.epilogue is None):
			set_content_text(joinNone("\n", '', [eml.preamble, eml.epilogue]), eml)
		else:
			label = _("Content type: %s%s%s") % (PMU_MIME, glib.markup_escape_text(eml.get_content_type()), PMU_MIME_CLOSE)
			filename = eml.get_filename()
			if filename is not None: label = (_("Filename: %s%s%s") % (PMU_NAME, glib.markup_escape_text(filename), PMU_NAME_CLOSE)) + "\n" + label
			lbl_right.set_markup(label)
			
			panel_btnbox.show()
			btn_open.show()
			btn_save.set_label(gtk.stock_lookup(gtk.STOCK_SAVE)[1])
			spanel_content.hide()
	else:
		cmd, args = filt[:]
		if cmd == '':
			panel_content.set_data('view-unfiltered', True)
			set_content_text(None, eml)
			panel_btnbox.hide()
			spanel_content.show()
			panel_content.set_sensitive(True)
		else:
			bufr = panel_content.get_buffer()
			bufr.set_text('')
			for s in pipereader(get_content_properly(eml), cmd, args):
				bufr.insert(bufr.get_end_iter(), s)
			panel_content.set_sensitive(True)

def decode_header(s):
	chunks = []
	for chars, encoding in email.Header.decode_header(s):
		if encoding is None: encoding = 'utf-8'
		chunks.append(chars.decode(encoding, 'replace'))
	return ' '.join(chunks)

def get_one_header_main(hname, dflt=None):
	hval = get_part_by_itpath((0,))[hname]
	if hval is None:
		return dflt
	return decode_header(hval)

def get_headers_markup(eml):
	lns = []
	hdrs = [
		"X-X-Sender",
		"X-Sender",
		"Sender",
		"From",
		"Organization",
		"Reply-To",
		"To",
		"Cc",
		"Subject",
		"Date",
	]
	hdr_from = []
	for hname in hdrs:
		if eml[hname]:
			hvals = []
			for hval in eml.get_all(hname):
				hval = decode_header(hval)
				if hname == 'From':
					hdr_from.append(hval)
				elif hname == 'Reply-To':
					if hval in hdr_from: continue
				elif hname == 'Date':
					#hval = TODO timezone...
					pass
				hvals.append(hval)
			if len(hvals):
				lns.append(PMU_HEAD + _(hname) + PMU_HEAD_CLOSE + ': ' + ', '.join(map(glib.markup_escape_text, hvals)))
	return "\n".join(lns)

def get_filters_by_mime(main, sub, all=True):
	filters = []
	for m, s, cmd, args in cfgparser('filters', regex='^\s*([^;#][^\s/]*)/(\S+)\s+(\S+)\s*(.+)?', splitgroups=[4]):
		if fnmatch(main, m) and fnmatch(sub, s):
			e = None
			if cmd == '-':
				e = ('', None)
			elif which(cmd):
				e = (cmd, args)
			if e is not None:
				if all:
					filters.append(e)
				else:
					return e
	if all:
		return filters
	return None

def get_filter_by_mime(main, sub):
	return get_filters_by_mime(main, sub, all=False)

def get_stock_by_mime(main, sub):
	assoc_main = {
		'multipart': gtk.STOCK_DIRECTORY,
		'message': 'emblem-mail',
	}
	assoc_full = {
		'application/pgp-signature': 'mail-signed',
		'application/ics': 'x-office-calendar',
		'text/calendar': 'x-office-calendar',
	}
	full = main + '/' + sub

	if assoc_full.has_key(full):
		return assoc_full[full]
	elif assoc_main.has_key(main):
		return assoc_main[main]
	
	if full in ['text/html']:
		return main + '-' + sub
	elif main in ['audio', 'image', 'font', 'package', 'text', 'video']:
		return main + '-x-generic'

	return gtk.STOCK_FILE

def act_quit():
	# TODO ask to close edit
	gtk.main_quit()

def act_button(func):
	if type(func) != type(()):
		func = (func,)
	if func[0] is not None:
		func[0](*func[1:])

def on_click_button(btn, func):
	act_button(func)
	return False

def on_press_button(btn, evt, func):
	if evt.type == gtk.gdk.BUTTON_PRESS:
		if evt.button == 3 or (evt.button == 1 and evt.state & gtk.gdk.SHIFT_MASK):
			act_button(func)
	return False

def set_composer_text(s):
	bufr = panel_edit.get_buffer()
	bufr.set_text(s)
	bufr.place_cursor(bufr.get_start_iter())

def set_composer_headers(hname, hvals):
	clear_composer_headers(hname)
	for hval in hvals:
		add_composer_header(hname, hval)

def clear_composer_headers(hname):
	for wdg in panel_comp_hdr.children():
		if hname is None or hdr_box_hname(wdg) == hname:
			panel_comp_hdr.remove(wdg)

def get_composer_headers(hname):
	hlist = []
	for chld in panel_comp_hdr.children():
		if hname is None or hdr_box_hname(chld) == hname:
			hlist.append((hname, hdr_box_hval(chld)))
	return hlist

def add_composer_header(hname, hval, after=None):
	box = new_comp_hdr_wdg(hname, hval)
	box.show_all()
	panel_comp_hdr.pack_start(box, False, True)
	if after is not None:
		for n in range(0, len(panel_comp_hdr.children())):
			if panel_comp_hdr.children()[n] == after:
				panel_comp_hdr.reorder_child(box, n)

def new_comp_hdr_wdg(hname, hval):
	box = gtk.HBox(False, 2)
	wdg_name = gtk.combo_box_entry_new_with_model(PopularHeadersStore, 1)
	wdg_value = gtk.Entry()
	wdg_add = StockButton('', gtk.STOCK_ADD, icon_size=gtk.ICON_SIZE_MENU)
	wdg_del = StockButton('', gtk.STOCK_REMOVE, icon_size=gtk.ICON_SIZE_MENU)
	box.pack_start(wdg_name, False, True)
	box.pack_start(wdg_value, True, True)
	box.pack_start(wdg_add, False, False)
	box.pack_start(wdg_del, False, False)
	#TODO wdg_value.set_completion()
	wdg_add.connect('clicked', lambda x, box: add_composer_header(hdr_box_hname(box), hdr_box_hval(box), box), box)
	wdg_del.connect('clicked', lambda x, box: box.parent.remove(box) if len(box.parent.children())>1 else None, box)
	hdr_box_hname(box, hname)
	hdr_box_hval(box, hval)
	return box

def hdr_box_hname(box, hname=None):
	cbe = box.children()[0]
	if hname is None:
		it = cbe.get_active_iter()
		if it is not None:
			return cbe.get_model().get_value(it, 0)
		else:
			return cbe.get_data('cname')
	else:
		cbe.set_data('cname', hname)
		cbe.children()[0].set_text(_(hname))

def hdr_box_hval(box, hval=None):
	ent = box.children()[1]
	if hval is None:
		return ent.get_text()
	else:
		ent.set_text(hval)

def open_composer(headers, body):
	if not win_comp.get_visible():
		win_comp.show_all()
		win_comp.set_data('email-saved', True)
		clear_composer_headers(None)
		for hname, hval in headers:
			add_composer_header(hname, hval)
		set_composer_text(body)
		win_comp.set_focus(panel_edit)
	else:
		win_comp.present()

def quote_message_plain():
	#TODO
	return "> "

def get_user_signature():
	try:
		sign = ''.join(open(os.path.join(os.environ['HOME'], '.signature'), 'r').readlines())
	except:
		sign = ''
	return sign

def act_compose():
	open_composer([('Subject', '')], "\n\n" + get_user_signature())

def act_reply(recip):
	headers = []
	if recip == 'one':
		headers.append(('To', "felado"))
	elif recip == 'all':
		headers.append(('To', "mindenki"))
	open_composer(headers, "\n\n" + get_user_signature() + "\n" + _("Quote:\n") + quote_message_plain())

def act_mark_spam():
	pass

def act_wrap(i=1):
	modes = cyclelist([gtk.WRAP_WORD, gtk.WRAP_WORD_CHAR, gtk.WRAP_NONE], at=panel_content.get_wrap_mode())
	panel_content.set_wrap_mode(modes.turn(i))

def get_extension_by_mime(mime):
	if mime is None:
		e = None
	else:
		e = guess_extension(mime)
	if e is None:
		e = '.dat'
	return e

def act_open():
	eml = get_part_by_itpath()
	if eml is None: return
	mime = eml.get_content_type()
	fd, tmppath = mkstemp(prefix = PROGNAME + '-', suffix = get_extension_by_mime(mime))
	try:
		save_to_filedescriptor(eml, fd)
		fh = os.fdopen(fd)
		set_xattr_charset(fh, eml.get_content_charset(), tmppath)
		fh.close()
	except OSError, e:
		os.unlink(tmppath)
		e.filename = tmppath
		display_error(e)
		return
	run_async('mimeopen-gui', [tmppath], [os.unlink, tmppath])

def calc_attachment_name(part, n=None):
	name = part.get_filename()
	if name is None:
		name = "%s_attachment%s%s" % (get_one_header_main('Subject', _("Email")), '' if n is None else '-'+str(n), get_extension_by_mime(part.get_content_type()))
	return name

def act_save():
	itpaths = selection_parts.get_selected_rows()[1]
	if len(itpaths) == 1:
		itpath = itpaths[0]
		eml = get_part_by_itpath(itpath)
		savefile = choose_save_file(calc_attachment_name(eml))
		if savefile is not None:
			save_to_file(eml, savefile)
	elif len(itpaths) > 1:
		savedir = choose_save_folder()
		if savedir is not None:
			for n in range(0, len(itpaths)):
				eml = get_part_by_itpath(itpaths[n])
				savefile = os.path.join(savedir, calc_attachment_name(eml, n))
				save_to_file(eml, savefile)

def set_xattr_charset(fh, charset, filename='-'):
	if xattr is not None:
		try:
			if charset is None:
				xattr.removexattr(fh, XATTR_CHARSET)
			else:
				xattr.setxattr(fh, XATTR_CHARSET, charset)
		except IOError, e:
			sys.stderr.write((_("Notice: can not set xattr '%s' on '%s': %s") % (XATTR_CHARSET, filename, str(e))) + "\n")
			pass

def save_to_file(eml, filename):
	if os.path.exists(filename):
		if not question(_("This file already exists:\n%s\nOverwrite?") % (os.path.basename(filename)), (None, gtk.STOCK_SAVE)):
			return None
	try:
		fh = open(filename, 'w')
		save_to_filedescriptor(eml, fh.fileno())
		set_xattr_charset(fh, eml.get_content_charset(), filename)
		fh.close()
		return True
	except IOError, e:
		display_error(e)
	except OSError, e:
		e.filename = filename
		display_error(e)
	return False

def save_to_filedescriptor(eml, fd):
	s = eml.get_payload(decode=1)
	if s is None:
		s = eml.as_string()
	written = os.write(fd, s)
	if written != len(s):
		raise OSError(5, 'Write Error')

def act_view_source():
	if panel_content.get_data('view-unfiltered'):
		filt = None
	else:
		filt = ('', None)
	load_part(get_part_by_itpath(), filt)

def get_current_font(txtv):
	pctx = txtv.get_pango_context()
	fdsc = pctx.get_font_description()
	s = fdsc.to_string()
	m = re.match('\s(\d+)(\s|$)', s)
	if m: pt = int(m.group(1))
	else: pt = 12
	return {'family': fdsc.get_family().lower(), 'string': s.lower(), 'size': pt, 'desc': fdsc,}

def act_font_switch():
	font = get_current_font(panel_content)
	if font['family'] != 'monospace':
		panel_content.set_data('saved-font', font)
		f = panel_content.get_data('saved-font-monospace')
		if f is None: f = 'monospace 12'
		else: f = f['string']
	else:
		f = panel_content.get_data('saved-font')['string']
	change_font(f)

def act_font():
	dlg = gtk.FontSelectionDialog(_("Select Font"))
	dlg.set_font_name(panel_content.get_data('saved-font')['string'])
	dlg.set_modal(True)
	dlg.run()
	font_name = dlg.get_font_name()
	dlg.destroy()
	change_font(font_name)
	font = get_current_font(panel_content)
	if font['family'] == 'monospace':
		key = 'saved-font-monospace'
	else:
		key = 'saved-font'
	panel_content.set_data(key, font)

def change_font(s):
	panel_content.modify_font(pango.FontDescription(s))

def on_select_parts(selection):
	itpaths = selection.get_selected_rows()[1]
	if len(itpaths) > 1:
		panel_btnbox.show()
		lbl_right.set_markup(_("Multiple (%s) selected attachments") % (len(itpaths)))
		btn_open.hide()
		btn_save.set_label(_("Save All"))
		spanel_content.hide()
		btn_open2.set_sensitive(False)
		btn_save2.set_sensitive(True)
		menubutton_filters.set_sensitive(False)
	else:
		panel_btnbox.hide()
		spanel_content.show()
		if len(itpaths) == 1:
			btn_open2.set_sensitive(True)
			btn_save2.set_sensitive(True)
			itpath = itpaths[0]
			eml = get_part_by_itpath(itpath)
			load_part(eml)
			menubutton_filters.set_sensitive(True)
			populate_filters_menu(eml)
		else:
			btn_open2.set_sensitive(False)
			btn_save2.set_sensitive(False)
			clear_content()
			menubutton_filters.set_sensitive(False)

def act_show_headers(chkmi):
	if chkmi.active:
		s = ''
		for hname, hval in Email._headers:
			hval = decode_header(hval)
			s += PMU_HEAD + glib.markup_escape_text(hname) + PMU_HEAD_CLOSE + ': ' + glib.markup_escape_text(hval) + "\n"
		panel_header.set_markup(s)
	else:
		panel_header.set_markup(get_headers_markup(Email))
	panel_header.set_data('all-headers', chkmi.active)

def populate_header_menu(label, menu):
	menu.append(gtk.SeparatorMenuItem())
	mi = gtk.CheckMenuItem(_("All Headers"))
	mi.set_active(panel_header.get_data('all-headers') == True)
	mi.connect('toggled', act_show_headers)
	menu.append(mi)
	menu.show_all()

def populate_filters_menu(eml):
	for mi in menu_filters.children():
		menu_filters.remove(mi)
	uniqfilt = {}
	for filt in get_filters_by_mime(eml.get_content_maintype(), eml.get_content_subtype()):
		if filt[0] == '': continue
		if uniqfilt.has_key(filt[0]) and uniqfilt[filt[0]] == filt[1]: continue
		uniqfilt[filt[0]] = filt[1]
		mi = gtk.MenuItem(filt[0])
		mi.connect('activate', lambda mi, eml, filt: load_part(eml, filt), eml, filt)
		menu_filters.append(mi)
	menu_filters.show_all()
	disable_filters_menu(True if len(menu_filters.children()) == 0 else False)

def disable_filters_menu(b=True):
	menubutton_filters.children()[0].children()[1].set_sensitive(not b)

def get_part_by_itpath(itpath = None):
	if itpath is None:
		try:
			itpath = selection_parts.get_selected_rows()[1][0]
		except IndexError:
			return None
	model = Parts
	return model.get_value(model.get_iter(itpath), 0)

def load_toolitems(toolbar, toolitems):
	for label, stock, tip, fnc_left, fnc_right in toolitems:
		if type(fnc_left) == str:
			tbi = gtk.SeparatorToolItem()
			if fnc_left == 'space':
				tbi.set_draw(False)
				tbi.set_expand(True)
			elif fnc_left == 'separator':
				tbi.set_draw(True)
				tbi.set_expand(False)
		elif isinstance(stock, gtk.ToolItem):
			tbi = stock
			if tip is not None:
				tbi.set_tooltip_text(tip)
			tbi.connect('clicked', on_click_button, fnc_left)
		else:
			stocklabel = None
			s = gtk.stock_lookup(stock)
			if s:
				stocklabel = re.sub('_', '', s[1])
			if label is not None:
				label = _(label)
			else:
				label = stocklabel
			if tip is not None:
				tip = _(tip)
			else:
				if label is not None:
					tip = label
				else:
					tip = stocklabel
			tbi = StockToolButton(label=label, stock=stock, tooltip=tip)
			tbi.set_data('stock', stock)
			tbi.connect('clicked', on_click_button, fnc_left)
			tbi.child.connect('button-press-event', on_press_button, fnc_right)
		toolbar.insert(tbi, -1)

def setup_treeview__icon_label(tv):
	tvc = gtk.TreeViewColumn()
	tv.append_column(tvc)
	cr_pix = gtk.CellRendererPixbuf()
	cr_txt = gtk.CellRendererText()
	tvc.pack_start(cr_pix, False)
	tvc.pack_start(cr_txt, True)
	tvc.add_attribute(cr_txt, 'markup', 1)
	tvc.add_attribute(cr_pix, 'icon-name', 2)
	tvc.add_attribute(cr_pix, 'pixbuf', 3)


def act_send():
	pass

def act_save_edit():
	pass

def act_attach():
	filename = choose_open_file()
	if filename:
		basename = os.path.basename(filename)
		stock = get_stock_by_mime('', '')
		pixb = None
		Attachments.append(['', basename, stock, pixb])

def drop_attachment_motion(wdg, context, x, y, time):
	wdg.drag_highlight()
	context.drag_status(gtk.gdk.ACTION_COPY, time)
	return True

def drop_attachment_accept(wdg, context, x, y, time):
	accepted = False
	for desired in ['application/octet-stream', 'COMPOUND_TEXT', 'text/uri-list']:
		if desired in context.targets:
			wdg.drag_get_data(context, desired, time)
			accepted = True
			break
	context.drop_reply(accepted, time)
	wdg.drag_unhighlight()
	return True

def drop_attachment(wdg, context, x, y, data, info, time):
	if data.get_length() > -1:
		typ = data.get_data_type()
		print typ
		if typ == 'COMPOUND_TEXT':
			print data.get_text()
		elif typ == 'application/octet-stream':
			print data.get_()
		elif typ == 'text/uri-list':
			print data.get_uris()
		else:
			context.finish(False, False, time)
			return True
		context.finish(True, False, time)
	else:
		context.finish(False, False, time)
	return True

def act_edit_external():
	pass

def act_close_edit():
	if not win_comp.get_data('email-sent') and not win_comp.get_data('email-saved'):
		if not question(_("Message is not saved.\nClose anyway?"), (None, gtk.STOCK_QUIT if args.compose else gtk.STOCK_CLOSE)):
			return True
	if args.compose:
		act_quit()
	else:
		win_comp.hide()
		return True



### Main ###

PROGNAME = 'gemlv'
_ = gettext.gettext
PMU_MIME = '<i><span color="gray30">'
PMU_MIME_CLOSE = '</span></i>'
PMU_NAME = '<b>'
PMU_NAME_CLOSE = '</b>'
PMU_HEAD = '<b>'
PMU_HEAD_CLOSE = '</b>'
Email = None
PartPrimary = None
PartSecondary = None
LastFolder = os.getcwd()
PopularHeaders = ["From", "To", "Cc", "Bcc", "Subject", "Priority"]
XATTR_CHARSET = 'user.mime_encoding'

argparser = argparse.ArgumentParser()
argparser.add_argument('--compose', action='store_true', help=_("Write a new Email"))
argparser.add_argument('--to', metavar='ADDRESSES', help=_("New Email's Recipients, comma-separated list"))
argparser.add_argument('--subject', metavar='STRING', help=_("Subject"))
argparser.add_argument('--message', metavar='STRING', help=_("Message body"))
argparser.add_argument('FILE', nargs='?', help=_("Raw Email file for read or continue editing"))
args = argparser.parse_args()
if args.to is not None: args.to = re.split('\s*,\s*', args.to)
if not args.compose and not args.FILE:
	sys.stderr.write(_("Either compose mode or FILE is needed.") + "\n")
	os._exit(1)


### Build GUI ###

win_main = gtk.Window()
win_main.set_default_size(800, 450)
start_evt = win_main.connect('map-event', win_main_show)
win_main.connect('delete-event', lambda a,b: act_quit())
add_key_binding(win_main, '<Control>q', lambda a,b,c,d: act_quit())
add_key_binding(win_main, '<Control>s', lambda a,b,c,d: act_save())
add_key_binding(win_main, '<Control>o', lambda a,b,c,d: act_open())
add_key_binding(win_main, '<Control>n', lambda a,b,c,d: act_compose())
add_key_binding(win_main, '<Control><Shift>r', lambda a,b,c,d: act_reply('one'))
add_key_binding(win_main, '<Control>r', lambda a,b,c,d: act_reply('all'))
add_key_binding(win_main, '<Control>f', lambda a,b,c,d: act_reply(''))
add_key_binding(win_main, '<Control>u', lambda a,b,c,d: act_view_source())

box_main = gtk.VBox(False, 5)
toolbar = gtk.Toolbar()
spanel_header = gtk.ScrolledWindow()
panel_header = gtk.Label()
panel_body = gtk.HPaned()
spanel_parts = gtk.ScrolledWindow()
Parts = gtk.TreeStore(gobject.TYPE_PYOBJECT, str, str, gtk.gdk.Pixbuf)
panel_parts = gtk.TreeView(Parts)
selection_parts = panel_parts.get_selection()
panel_right = gtk.VBox()
lbl_right = gtk.Label()
panel_btnbox = gtk.HBox()
btnbox_right = gtk.VBox(True, 10)
btn_open = StockButton(stock=gtk.STOCK_OPEN)
btn_save = StockButton(stock=gtk.STOCK_SAVE)
spanel_content = gtk.ScrolledWindow()
panel_content = gtk.TextView()
tb_controls = gtk.Toolbar()
menubutton_filters = gtk.MenuToolButton(gtk.STOCK_ZOOM_FIT)
menu_filters = gtk.Menu()

win_main.add(box_main)
box_main.pack_start(toolbar, False, True)
box_main.pack_start(spanel_header, False, True)
spanel_header.add_with_viewport(panel_header)
box_main.pack_start(panel_body, True, True)
panel_body.pack1(spanel_parts, True, True)
panel_body.pack2(panel_right, True, True)
spanel_parts.add_with_viewport(panel_parts)
panel_right.pack_start(panel_btnbox, True, False)
panel_btnbox.pack_start(lbl_right, True, False)
panel_btnbox.pack_start(btnbox_right, True, False)
btnbox_right.pack_start(btn_open, False, False)
btnbox_right.pack_start(btn_save, False, False)
panel_right.pack_start(spanel_content, True, True)
spanel_content.add_with_viewport(panel_content)
panel_right.pack_start(tb_controls, False, True)

toolbar.set_style(gtk.TOOLBAR_BOTH)
spanel_header.set_size_request(-1, 104)
spanel_header.set_policy(gtk.POLICY_NEVER, gtk.POLICY_AUTOMATIC)
panel_header.set_padding(4, 2)
panel_header.set_alignment(0, 0)
panel_header.set_justify(gtk.JUSTIFY_LEFT)
panel_header.set_selectable(True)
panel_header.set_line_wrap(True)
panel_header.connect('populate-popup', populate_header_menu)
panel_body.set_position(175)
spanel_parts.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
spanel_content.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
panel_parts.set_headers_visible(False)
selection_parts.set_mode(gtk.SELECTION_MULTIPLE)
selection_parts.connect('changed', on_select_parts)
lbl_right.set_alignment(0, 0)
lbl_right.set_justify(gtk.JUSTIFY_LEFT)
btn_open.connect('clicked', lambda wdg: act_open())
btn_save.connect('clicked', lambda wdg: act_save())
panel_content.set_editable(False)
panel_content.set_wrap_mode(gtk.WRAP_WORD)
tb_controls.set_icon_size(gtk.ICON_SIZE_MENU)
tb_controls.set_style(gtk.TOOLBAR_ICONS)
menubutton_filters.set_homogeneous(False)
menubutton_filters.set_menu(menu_filters)
menubutton_filters.set_arrow_tooltip_text(_("Filters"))


toolbuttons = [
	("Compose", gtk.STOCK_EDIT, None, act_compose, None),
	("Reply", 'mail-reply-sender', None, (act_reply, 'one'), None),
	("Reply To All", 'mail-reply-all', None, (act_reply, 'all'), None),
	("Forward", 'mail-forward', None, (act_reply, ''), None),
	(None, None, None, 'separator', None),
	("Report Spam", 'mail-mark-junk', None, act_mark_spam, None),
	(None, None, None, 'space', None),
	(None, gtk.STOCK_QUIT, None, act_quit, None),
]
load_toolitems(toolbar, toolbuttons)
setup_treeview__icon_label(panel_parts)

toolbuttons = [
	(None, None, None, 'space', None),
	(None, gtk.STOCK_OPEN, None, act_open, None),
	(None, gtk.STOCK_SAVE, None, act_save, None),
	(None, None, None, 'separator', None),
	("Unfilter", menubutton_filters, "Filter / Unfilter", act_view_source, None),
	("Wrap", gtk.STOCK_JUSTIFY_LEFT, "Soft / Hard / No Wrap\nRight click: No / Soft / Hard Wrap", act_wrap, (act_wrap, -1)),
	(None, gtk.STOCK_SELECT_FONT, "Change Font\nRight click: monospace", act_font, act_font_switch),
]
load_toolitems(tb_controls, toolbuttons)
for tbi in tb_controls.get_children():
	s = tbi.get_data('stock')
	if s == gtk.STOCK_OPEN:
		btn_open2 = tbi
	elif s == gtk.STOCK_SAVE:
		btn_save2 = tbi


win_comp = gtk.Window()
win_comp.set_default_size(*win_main.get_default_size())
win_comp.connect('delete-event', lambda a,b: act_close_edit())
add_key_binding(win_comp, '<Control>'+('q' if args.compose else 'w'), lambda a,b,c,d: act_close_edit())
add_key_binding(win_comp, '<Control>s', lambda a,b,c,d: act_save_edit())
add_key_binding(win_comp, '<Control>o', lambda a,b,c,d: act_attach())

box_compose = gtk.VBox(False, 5)
tb_compose = gtk.Toolbar()
panel_compose = gtk.VPaned()
panel_upper = gtk.HPaned()
spanel_comp_hdr = gtk.ScrolledWindow()
panel_comp_hdr = gtk.VBox(False, 2)
PopularHeadersStore = gtk.ListStore(str, str)
spanel_attachments = gtk.ScrolledWindow()
Attachments = gtk.ListStore(str, str, str, gtk.gdk.Pixbuf)
panel_attachments = gtk.TreeView(Attachments)
frame_edit = gtk.Frame()
spanel_edit = gtk.ScrolledWindow()
panel_edit = gtk.TextView()
tb_comp_controls = gtk.Toolbar()

win_comp.add(box_compose)
box_compose.pack_start(tb_compose, False, True)
box_compose.pack_start(panel_compose, True, True)
panel_compose.pack1(panel_upper, True, True)
panel_upper.pack1(spanel_comp_hdr, True, True)
spanel_comp_hdr.add_with_viewport(panel_comp_hdr)
panel_upper.pack2(spanel_attachments, False, True)
spanel_attachments.add_with_viewport(panel_attachments)
panel_attachments.set_headers_visible(False)
panel_compose.pack2(frame_edit, True, True)
frame_edit.add(spanel_edit)
spanel_edit.add(panel_edit)
box_compose.pack_start(tb_comp_controls, False, True)

tb_compose.set_style(gtk.TOOLBAR_BOTH)
panel_upper.set_position(win_comp.get_default_size()[0]-150)
spanel_comp_hdr.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
panel_comp_hdr.set_border_width(4)
spanel_attachments.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
panel_attachments.drag_dest_set(0, [], 0)
panel_attachments.connect('drag-motion', drop_attachment_motion)
panel_attachments.connect('drag-drop', drop_attachment_accept)
panel_attachments.connect('drag-data-received', drop_attachment)
panel_compose.set_position(125)
spanel_edit.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
frame_edit.set_shadow_type(gtk.SHADOW_IN)
tb_comp_controls.set_icon_size(gtk.ICON_SIZE_MENU)
tb_comp_controls.set_style(gtk.TOOLBAR_ICONS)

toolbuttons = [
	("Send", 'mail-send', None, act_send, None),
	(None, gtk.STOCK_SAVE, None, act_save_edit, None),
	("Attach File", 'mail-attachment', None, act_attach, None),
	(None, None, None, 'space', None),
	(None, gtk.STOCK_QUIT if args.compose else gtk.STOCK_CLOSE, None, act_close_edit, None),
]
load_toolitems(tb_compose, toolbuttons)
setup_treeview__icon_label(panel_attachments)

for h in PopularHeaders:
	PopularHeadersStore.append([h, _(h)])

toolbuttons = [
	(None, None, None, 'space', None),
	(None, gtk.STOCK_EDIT, "Edit with External Program", act_edit_external, None),
]
load_toolitems(tb_comp_controls, toolbuttons)


if args.compose:
	open_composer([], "\n\n" + get_user_signature())
	if args.FILE:
		# TODO load email
		pass
	if args.to:
		set_composer_headers('To', args.to)
	if args.subject:
		set_composer_headers('Subject', [args.subject])
	if not get_composer_headers('Subject'):
		set_composer_headers('Subject', [''])
	if args.message:
		set_composer_text(args.message)
else:
	win_main.show_all()
	panel_btnbox.hide()
gtk.main()
