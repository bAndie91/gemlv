#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os
import sys
import signal
import select
import fcntl
import gtk
import gobject
import glib
import pango
import gettext
import email
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email.mime.message import MIMEMessage
from email.header import make_header
import re
from tempfile import mkstemp
from mimetypes import guess_extension
import magic
from fnmatch import fnmatch
import argparse
try:
	import xattr
except ImportError:
	xattr = None
import urlparse
import pwd
import threading
import time
import hashlib
import urllib2
import ctypes
from ctypes.util import find_library
try:
	import textwrap
except ImportError:
	class textwrap(object):
		def wrap(self, text, width):
			return text


### helper classes, functions ###

class StockToggleToolButton(gtk.ToggleToolButton):
	def __init__(self, stock=None):
		super(self.__class__, self).__init__(stock)
		if stock not in gtk.stock_list_ids():
			self.set_icon_name(stock)

class StockMenuItem(gtk.ImageMenuItem):
	def __init__(self, stock_id=None, accel_group=None, label=None):
		super(self.__class__, self).__init__(stock_id=stock_id, accel_group=accel_group)
		if label is not None:
			self.set_label(label)

class StockToolButton(gtk.ToolButton):
	def __init__(self, label=None, stock=None, tooltip=None):
		super(self.__class__, self).__init__()
		if stock is not None:
			if stock in gtk.stock_list_ids():
				if stock is not None: self.set_stock_id(stock)
			else:
				self.set_icon_name(stock)
		if label is not None:
			self.set_label(label)
		if tooltip is not None:
			self.set_tooltip_text(tooltip)
	def set_pixbuf(self, pxb):
		a = self.get_children()[0]
		a = a.get_children()[0]
		img, a = a.get_children()
		img.set_from_pixbuf(pxb)
		img.props.visible = True
	def __get_children(self):
		align = self.get_children()[0]
		hbox = align.get_children()[0]
		return hbox.get_children()
	def set_markup(self, markup):
		x, lbl = self.__get_children()
		lbl.set_markup(markup)

class StockButton(gtk.Button):
	def __init__(self, label=None, stock=None, use_underline=True, icon_size=None):
		if stock is not None and stock in gtk.stock_list_ids():
			stock_tmp = stock
		else:
			stock_tmp = gtk.STOCK_ABOUT
		super(self.__class__, self).__init__(stock=stock_tmp, use_underline=use_underline)
		if label is not None:
			self.set_markup(label)
		if stock is None:
			self.set_icon('')
		elif stock not in gtk.stock_list_ids():
			self.set_icon(stock)
		if icon_size is not None:
			self.set_icon(stock, icon_size)
	def __get_children(self):
		align = self.get_children()[0]
		hbox = align.get_children()[0]
		return hbox.get_children()
	def set_label(self, label):
		x, lbl = self.__get_children()
		lbl.set_label(label)
	def set_markup(self, label):
		x, lbl = self.__get_children()
		lbl.set_markup(label)
	def set_icon(self, icon, size=gtk.ICON_SIZE_BUTTON):
		img, x = self.__get_children()
		if type(icon) == str:
			if icon == '':
				img.props.visible = False
			else:
				img.set_from_icon_name(icon, size)
				img.props.visible = True
		else:
			img.set_from_pixbuf(icon)
			img.props.visible = True

class cfgparser(object):
	def __init__(self, name, **kvargs):
		self.var = {'regex': '^\s*([^;#].*)', 'split': [1],}
		for k in 'regex', 'splitgroups':
			if not self.var.has_key(k): self.var[k] = None
			if kvargs.has_key(k): self.var[k] = kvargs[k]
		suff = '.conf'
		self.filehandlers = []
		for t in (os.environ['HOME'], '.config', PROGNAME, name + suff), (os.path.sep, 'etc', PROGNAME, name + suff), (name + suff,),:
			n = os.path.join(*t)
			try:
				fh = open(n, 'r')
				self.filehandlers.append(fh)
			except IOError:
				pass
	
	def __iter__(self):
		return self
	
	def next(self):
		if len(self.filehandlers) == 0:
			raise StopIteration
		else:
			fh = self.filehandlers[0]
			while True:
				ln = fh.readline()
				if ln == '':
					fh.close()
					self.filehandlers.reverse()
					self.filehandlers.pop()
					self.filehandlers.reverse()
					if len(self.filehandlers) == 0:
						raise StopIteration
					fh = self.filehandlers[0]
					continue
				m = re.search(self.var['regex'], ln)
				if m:
					grps = []
					n = 0
					for grp in m.groups():
						n += 1
						if n in self.var['splitgroups']:
							if grp is None:
								grp = []
							else:
								grp = re.split('\s+', grp)
						grps.append(grp)
					return grps
	
	def __del__(self):
		for fh in self.filehandlers:
			fh.close()

class pipereader(object):
	def __init__(self, inputstr, cmd, args=[], exitdict=None):
		self.exitdict = exitdict
		args = args[:]
		args.insert(0, os.path.basename(cmd))
		child_read, parent_write, parent_read, child_write = get_pipe_handlers(2)
		pid = os.fork()
		if pid == 0:
			parent_read.close()
			parent_write.close()
			os.dup2(child_read.fileno(), sys.stdin.fileno())
			os.dup2(child_write.fileno(), sys.stdout.fileno())
			os.closerange(3, 255)
			try:
				os.execvp(cmd, args)
			except OSError, e:
				sys.stderr.write(str(e))
			os._exit(127)
		else:
			child_read.close()
			child_write.close()
			parent_write.write(inputstr)
			parent_write.close()
			self.pid = pid
			self.reader = parent_read
	
	def __iter__(self):
		return self
	
	def next(self):
		s = self.reader.readline()
		if s == '':
			raise StopIteration
		else:
			return s
	
	def __del__(self):
		self.reader.close()
		status = WaitExecStatus(self.pid)
		if self.exitdict is not None:
			self.exitdict.update(status.__dict__)

class cyclelist(list):
	def __init__(self, lst, **kvargs):
		if type(lst) != type([]):
			raise TypeError('need list, %s found' % (str(type(lst))))
		if len(lst) < 1:
			raise ValueError('need non-empty list')
		super(self.__class__, self).__init__(lst)
		self.idx = 0
		if kvargs.has_key('at'):
			self.whirl(kvargs['at'])
	
	def whirl(self, val):
		for i in range(0, len(self)):
			if self[i] == val:
				self.idx = i
				return val
		return None
	
	def turn(self, n=1):
		self.idx = (self.idx + n) % len(self)
		return self[self.idx]
	
	def __getitem__(self, i):
		return super(self.__class__, self).__getitem__(i % len(self))

	def __setitem__(self, i, v):
		return super(self.__class__, self).__setitem__(i % len(self), v)
	
	def __str__(self):
		return str(self[self.idx])


class TIMEVAL(ctypes.Structure):
	_fields_ = [('tv_sec', ctypes.c_long), ('tv_usec', ctypes.c_long)]

def futimes(fd, times):
	if len(times) < 2:
		raise OSError
	stdlib = find_library('c')
	libc = ctypes.CDLL(stdlib)
	TIMEVALS = TIMEVAL * 2
	if libc.futimes(fd, TIMEVALS((times[0], 0), (times[1], 0))) == -1:
		raise OSError

def add_key_binding(widget, keyname, callback):
	accelgroup = gtk.AccelGroup()
	key, modifier = gtk.accelerator_parse(keyname)
	accelgroup.connect_group(key, modifier, gtk.ACCEL_VISIBLE, callback)
	widget.add_accel_group(accelgroup)

def get_current_window():
	for w in gtk.window_list_toplevels():
		if w.is_active():
			while True:
				par = w.get_transient_for()
				if par is None:
					return w
				else:
					w = par
	return None

def display_error(e):
	text = None
	if isinstance(e, OSError) or isinstance(e, IOError):
		text = '%s (#%d)\n%s' % (e.strerror, e.errno, e.filename)
	elif isinstance(e, Exception):
		text = e.message
	elif type(e) == type([]):
		text = ''.join(e)
	if text is None:
		text = str(e)
	dlg = gtk.MessageDialog(get_current_window(), gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_ERROR, gtk.BUTTONS_OK, text)
	dlg.set_title(_("Error"))
	dlg.run()
	dlg.destroy()

def question(msg, stock_yes=None, parent=None):
	dlg = gtk.MessageDialog(parent or get_current_window(), gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_QUESTION, gtk.BUTTONS_YES_NO)
	dlg.set_markup(msg)
	dlg.set_title(_("Question"))
	if stock_yes is not None:
		dlg.get_widget_for_response(gtk.RESPONSE_YES).hide()
		btn_yes = StockButton(label=stock_yes[0], stock=stock_yes[1])
		dlg.add_action_widget(btn_yes, gtk.RESPONSE_YES)
		btn_yes.show()
	resp = dlg.run()
	dlg.destroy()
	return (resp == gtk.RESPONSE_YES)

def set_dialog_icon_name(dlg, icon):
	img = dlg.get_content_area().children()[0].children()[0]
	img.set_from_icon_name(icon, gtk.ICON_SIZE_DIALOG)

def choose_dialog(action, filename=None):
	global LastFolder
	selected = None
	
	btn_accept_stock = gtk.STOCK_SAVE
	if action == gtk.FILE_CHOOSER_ACTION_OPEN:
		btn_accept_stock = gtk.STOCK_OPEN
	dlg = gtk.FileChooserDialog(parent=get_current_window(), action=action, buttons=(gtk.STOCK_CANCEL, gtk.RESPONSE_REJECT, btn_accept_stock, gtk.RESPONSE_ACCEPT))
	if LastFolder is not None: dlg.set_current_folder(LastFolder)
	if filename is not None: dlg.set_current_name(filename)
	btn_cwd = StockButton(label=_("Working Dir"), stock=gtk.STOCK_JUMP_TO)
	dlg.add_action_widget(btn_cwd, gtk.RESPONSE_NO)
	btn_cwd.show()
	while True:
		resp = dlg.run()
		if resp == gtk.RESPONSE_ACCEPT:
			selected = dlg.get_filename()
			break
		elif resp == gtk.RESPONSE_NO:
			dlg.set_current_folder(os.getcwd())
		else:
			break
	LastFolder = dlg.get_current_folder()
	dlg.destroy()
	return selected

def choose_save_file(filename=None):
	return choose_dialog(gtk.FILE_CHOOSER_ACTION_SAVE, filename)

def choose_save_folder():
	return choose_dialog(gtk.FILE_CHOOSER_ACTION_SELECT_FOLDER)

def choose_open_file():
	return choose_dialog(gtk.FILE_CHOOSER_ACTION_OPEN)

def get_pipe_handlers(npairs):
	pipes = []
	for n in range(0, npairs):
		r, w = os.pipe()
		pipes.append(os.fdopen(r, 'r'))
		pipes.append(os.fdopen(w, 'w'))
	return pipes

def set_blocking(fd, doblock):
	if type(fd) != int:
		fd = fd.fileno()
	fl = fcntl.fcntl(fd, fcntl.F_GETFL)
	if doblock:
		fl = fl & ~os.O_NONBLOCK
	else:
		fl = fl | os.O_NONBLOCK
	return fcntl.fcntl(fd, fcntl.F_SETFL, fl)

def which(cmd):
	def is_executable(p):
		return (os.path.isfile(p) and os.access(p, os.X_OK))
	
	ap, bn = os.path.split(cmd)
	if ap:
		if is_executable(cmd):
			return cmd
	else:
		for d in os.environ['PATH'].split(os.path.pathsep):
			p = os.path.join(d, cmd)
			if is_executable(p):
				return p
	return None

def mkdir(path):
	if os.path.exists(path) or path == '':
		return
	else:
		mkdir(os.path.dirname(path))
		os.mkdir(path)

def run_async(cmd, args, postrun):
	args = args[:]
	args.insert(0, os.path.basename(cmd))
	pid1 = os.fork()
	if pid1 == 0:
		os.closerange(0, 255)
		pid2 = os.fork()
		if pid2 == 0:
			pid3 = os.fork()
			if pid3 == 0:
				os.execvp(cmd, args)
				os._exit(127)
			else:
				status = WaitExecStatus(pid3)
				postrun[0](*postrun[1:])
				os._exit(status.code)
		else:
			os._exit(0)
	else:
		os.waitpid(pid1, 0)

class WaitExecStatus(object):
	def __init__(self, pid):
		x, status = os.waitpid(pid, 0)
		self.status = status >> 8
		self.code = self.status
		self.signal = status & 0x7F
		self.coredumped = status & 0x80 >> 7
	def __repr__(self):
		return 'status %s, signal %s%s' % (self.status, self.signal, ', core dumped' if self.coredumped else '')

class ExecThreadRunner(threading.Thread):
	def __init__(self, syscmd, sysargs, cb=None):
		assert isinstance(syscmd, str)
		assert isinstance(sysargs, list)
		assert isinstance(cb, list)
		assert len(cb) > 0
		super(self.__class__, self).__init__(target=self.execve, args=[syscmd, sysargs])
		self.callback = cb
	
	def execve(self, cmd, args):
		pid = os.fork()
		if pid == 0:
			os.closerange(0, 255)
			try:
				os.execvp(cmd, [cmd] + args)
			except OSError, e:
				sys.stderr.write(str(e))
			os._exit(127)
		else:
			return WaitExecStatus(pid)
	
	def run(self):
		result = self._Thread__target(*self._Thread__args, **self._Thread__kwargs)
		if self.callback is not None:
			self.callback[0](result, *self.callback[1:])

def main_thread_alive():
	alive = None
	for thr in threading.enumerate():
		if thr.name == 'MainThread':
			alive = thr.is_alive()
			break
	return alive

def get_header_parameter(text, param):
	for g1, g2 in re.findall('\\b' + re.escape(param) + '=(?:\x22([^\x22]+)\x22|([^\s;]+))', text or ''):
		if g1 != '': return g1
		if g2 != '': return g2
	return None

### private functions ###

def win_main_show(widget, event):
	win_main.disconnect(start_evt)
	panel_content.set_data('saved-font', get_current_font(panel_content))
	if cliArgs.FILE:
		load_file(cliArgs.FILE)

def get_email_addresses_in_main_headers(h):
	return map(lambda x: x[1], email.utils.getaddresses(Email.get_all(h) or []))

def load_file(filename):
	global Email
	global LeafParts
	try:
		fh = open(filename, 'r')
	except IOError, e:
		display_error(e)
		act_quit()
		return
	Email = email.message_from_file(fh)
	fh.close()
	
	senderaddr = None
	for h in OriginatorHeaders:
		addrs = get_email_addresses_in_main_headers(h)
		if len(addrs) > 0:
			senderaddr = addrs[0]
			break
	threading.Thread(target=load_gravatar, args=(senderaddr, panel_view_avatar)).start()
	
	if (Email[HDR_DNT] or '').strip():
		if get_xattr(cliArgs.FILE, XATTR_MDNSENT) is not None:
			menubutton_mdn.show()
	
	if get_listaddress_main() is not None:
		menubutton_replytolist.show()
	if (Email['List-Unsubscribe'] or '').strip():
		menubutton_unsubscribe.show()
	
	panel_view_header.set_markup(get_headers_markup(Email))
	panel_view_subject.set_markup(PMU_SUBJ + glib.markup_escape_text(re.sub('\n', '', get_one_header_main('Subject') or '')) + PMU_SUBJ_CLOSE)
	clear_parts(Parts)
	load_parts(Email, Parts, Parts.get_iter_root())
	panel_parts.expand_all()
	if Email.is_multipart():
		if PartPrimary is not None:
			selection_parts.select_iter(PartPrimary)
		elif PartSecondary is not None:
			selection_parts.select_iter(PartSecondary)
		else:
			selection_parts.select_path((0,))
	else:
		selection_parts.select_path((0,))

	if LeafParts > 1:
		pos = panel_body.get_data('saved-position')
		if pos is not None:
			panel_body.set_position(pos)
			panel_body.set_data('saved-position', None)
	else:
		panel_body.set_data('saved-position', panel_body.get_position())
		panel_body.set_position(0)

def clear_parts(model):
	global LeafParts
	LeafParts = 0
	model.clear()

def load_parts(eml, model, parent):
	global PartPrimary
	global PartSecondary
	global LeafParts
	
	label = PMU_MIME + glib.markup_escape_text(eml.get_content_type()) + PMU_MIME_CLOSE
	filename = eml.get_filename()
	if filename is not None: label = glib.markup_escape_text(filename) + ' ' + label
	stock = get_stock_by_mime(eml.get_content_maintype(), eml.get_content_subtype())
	pixb = None
	
	iterator = model.append(parent, [eml, label, stock, pixb])
	if PartPrimary is None and eml.get_content_type() == 'text/plain':
		PartPrimary = iterator
	if PartSecondary is None and eml.get_content_type() == 'text/html':
		PartSecondary = iterator
	if type(eml.get_payload()) == type([]):
		for part in eml.get_payload():
			load_parts(part, model, iterator)
	else:
		LeafParts += 1

def clear_content(s=''):
	bufr = panel_content.get_buffer()
	bufr.set_text(s)
	panel_content.set_sensitive(False)
	return bufr

def decode_readably(s, eml):
	charset = eml.get_content_charset()
	if charset is None: charset = 'utf-8'
	return s.decode(charset, 'replace')

def get_content_readably(eml):
	return decode_readably(get_content_any(eml), eml)

def get_content_any(eml):
	s = eml.get_payload(decode=1)
	if s is None: s = eml.as_string()
	return s

def set_content_text(s):
	bufr = panel_content.get_buffer()
	bufr.set_text(s)
	if s != '' and bufr.get_text(bufr.get_start_iter(), bufr.get_end_iter(), True) == '':
		return False
	panel_content.set_sensitive(True)
	return True

def load_part(eml, filt=None):
	if eml is None: return
	clear_content(_("Loading failed"))
	panel_content.set_data('view-unfiltered', False)
	ct_main, ct_sub = eml.get_content_maintype(), eml.get_content_subtype()
	
	if eml['Content-Location']:
		uri = eml['Content-Location']
		uri_esc = glib.markup_escape_text(uri)
		lbl_content_location.set_markup('%s <a href=\'%s\'>%s</a>' % (_("Read content elsewhere:"), uri_esc, uri_esc))
		lbl_content_location.show()
	else:
		lbl_content_location.hide()
	
	if filt is None:
		filt = get_filter_by_mime(ct_main, ct_sub)
	
	if filt is None:
		if type(eml.get_payload()) == type([]) and (eml.preamble is not None or eml.epilogue is not None):
			set_content_text(decode_readably('\n'.join([eml.preamble or '', eml.epilogue or '']), eml))
		else:
			if ct_main == 'image':
				loader = gtk.gdk.PixbufLoader()
				loader.write(eml.get_payload(decode=1))
				loader.close()
				pxb = loader.get_pixbuf()
				panel_content_image.set_data('last-alloc', None)
				panel_content_image.set_data('pixbuf', pxb)
				panel_content_image.show()
			else:
				label = _("Content type: %s%s%s") % (PMU_MIME, glib.markup_escape_text(eml.get_content_type()), PMU_MIME_CLOSE)
				filename = eml.get_filename()
				if filename is not None: label = (_("Filename: %s%s%s") % (PMU_NAME, glib.markup_escape_text(filename), PMU_NAME_CLOSE)) + '\n' + label
				lbl_right.set_markup(label)
				
				panel_btnbox.show()
				btn_open.show()
				btn_save.set_label(gtk.stock_lookup(gtk.STOCK_SAVE)[1])
			spanel_content.hide()
	else:
		cmd, args, binary = filt[:]
		if binary:
			content = get_content_any(eml)
		else:
			content = get_content_readably(eml)
		if cmd == '':
			panel_content.set_data('view-unfiltered', True)
			set_content_text(content) or clear_content(_("Loading failed"))
		else:
			bufr = panel_content.get_buffer()
			bufr.set_text('')
			for s in pipereader(content, cmd, args):
				bufr.insert(bufr.get_end_iter(), s)
			panel_content.set_sensitive(True)
		panel_btnbox.hide()
		panel_content_image.hide()
		spanel_content.show()

def on_allocate_panel_content_image(wdg, alloc):
	pxb = wdg.get_data('pixbuf')
	if pxb is not None:
		lastalloc = wdg.get_data('last-alloc')
		if lastalloc is None or alloc.width != lastalloc.width or alloc.height != lastalloc.height:
			wdg.set_data('last-alloc', alloc)
			B = wdg.get_border_width()
			W, H = alloc.width - B, alloc.height - B
			w0, h0 = pxb.get_width(), pxb.get_height()
			w = w0
			h = h0
			if W < w:
				w = W
				h = h0 * w / w0
			if H < h:
				h = H
				w = w0 * h / h0
			b = 5+B*2
			pxb = pxb.scale_simple(w - b, h - b, gtk.gdk.INTERP_BILINEAR)
			wdg.children()[0].set_from_pixbuf(pxb)

def resize_panel_view_header(wdg, rect=None):
	if not panel_view_header.get_data('all-headers'):
		if rect is None: rect = wdg.get_allocation()
		h, v = panel_view_header.get_padding()
		panel_view_header.set_size_request(rect.width - h - 4, -1)

def decode_header(s, unfold=False):
	chunks = []
	for chars, encoding in email.Header.decode_header(s):
		if encoding is None:
			if unfold:
				chars = re.sub('\r?\n\s*', ' ', chars)
			encoding = 'utf-8'
		chunks.append(chars.decode(encoding, 'replace'))
	return ' '.join(chunks)

def get_one_header_main(hname, unfold=True):
	hval = Email[hname]
	if hval is None: return hval
	return decode_header(hval, unfold=unfold)

def get_all_headers_main(hname):
	return map(decode_header, Email.get_all(hname) or [])

def get_mailtos(s, schemata=['mailto']):
	l = []
	uris = re.findall('<([^>]+)>', s)
	if len(uris) == 0:
		# For poorly behaved mail lists.
		uris = re.findall('^\s*(\S+)', s)
	for uri in uris:
		rslt = urlparse.urlsplit(uri)
		if '*' in schemata or rslt.scheme.lower() in schemata:
			q = dict((k.lower(), v if len(v)>1 else v[0]) for k, v in urlparse.parse_qs(rslt.query).iteritems())
			q['to'] = urlparse.unquote(rslt.path)
			q['uri'] = uri
			q['split'] = rslt
			l.append(q)
	return l

def load_gravatar(addr, container):
	if not isinstance(addr, str): return
	url = 'https://www.gravatar.com/avatar/%s?default=404&size=64&rating=G' % (hashlib.md5(addr.lower()).hexdigest())
	try:
		web = urllib2.urlopen(url)
	except urllib2.HTTPError:
		pass
	else:
		loader = gtk.gdk.PixbufLoader()
		try:
			loader.write(web.read())
			loader.close()
		except glib.GError, e:
			if e.code != 3:   # 'Unrecognized image file format'
				raise e
		else:
			pxb = loader.get_pixbuf()
			img = container.children()[0]
			img.set_from_pixbuf(pxb)
			container.show_all()

def get_listaddress_main():
	try:
		# Hopefully there is only one list address.
		listaddress = get_mailtos(','.join(get_all_headers_main('List-Post') or []))[0]['to']
	except IndexError:
		listaddress = None
	except KeyError:
		listaddress = None
	return listaddress

def get_headers_markup(eml):
	lns = []
	hdrs = [
		"Return-Path",
		"X-X-Sender",
		"X-Sender",
		"Sender",
		"From",
		"Organization",
		"Reply-To",
		"Importance",
		"X-Priority",
		"X-MSMail-Priority",
		"To",
		"Cc",
		"Date",
		"Reply-By",
		"Expires",
	]
	from_addresses = get_email_addresses_in_main_headers('From')
	for h in 'From', 'Sender', 'X-Sender', 'X-X-Sender':
		if eml[h] is not None:
			hdrs.remove('Return-Path')
			break
	
	for hname in hdrs:
		hvals_mu = []
		for hval in eml.get_all(hname) or []:
			hval = decode_header(hval)
			if hname != 'From' and hname in OriginatorHeaders:
				# do not display Sender or Reply-To fields if they equal to From
				addr = email.utils.parseaddr(hval)[1]
				if addr in from_addresses: continue
			if hname in RecipientHeaders or hname in OriginatorHeaders:
				list_mu = []
				for realname, addr in email.utils.getaddresses([hval]):
					realname = decode_header(realname)
					addr_mu = glib.markup_escape_text(addr)
					mu = '<a href=\'mailto:%s\'>%s</a>' % (addr_mu, addr_mu)
					if realname: mu = realname + ' ' + mu
					list_mu.append(mu)
				hval_mu = ', '.join(list_mu)
			elif hname in DateTimeHeaders:
				# display Date field in local timezone
				try:
					timestamp = email.utils.mktime_tz(email.utils.parsedate_tz(hval))
				except TypeError:
					timestamp = None
				else:
					hval = email.utils.formatdate(timestamp, True)
				hval_mu = glib.markup_escape_text(hval)
				if timestamp is not None and timestamp < time.time():
					if hname == 'Reply-By':
						wrn = _("Overdue")
					elif hname == 'Expires':
						wrn = _("(Expired)")
					try: hval_mu += ' ' + PMU_WARN + wrn + PMU_WARN_CLOSE
					except NameError: pass
			else:
				hval_mu = glib.markup_escape_text(hval)
			if len(hval_mu):
				hvals_mu.append(hval_mu)
		if len(hvals_mu):
			lns.append(PMU_HEAD + _(hname) + PMU_HEAD_CLOSE + ': ' + ', '.join(hvals_mu))
	return '\n'.join(lns)

def get_filters_by_mime(main, sub, all=True):
	filters = []
	for m, s, marks, cmd, args in cfgparser('filters', regex='^\s*([^;#][^\s/]*)/(\S+)\s+([!\$]*)(\S+)\s*(.+)?', splitgroups=[5]):
		if fnmatch(main, m) and fnmatch(sub, s):
			isbin = marks.find('!')>-1
			isshell = marks.find('$')>-1
			e = None
			if cmd == '-':
				e = ('', None, isbin)
			else:
				if isshell:
					e = ('sh', ['-c', ' '.join([cmd]+args)], isbin)
				else:
					if which(cmd):
						e = (cmd, args, isbin)
			if e is not None:
				if all:
					filters.append(e)
				else:
					return e
	if all:
		return filters
	return None

def get_filter_by_mime(main, sub):
	return get_filters_by_mime(main, sub, all=False)

def get_stock_by_mime(main, sub):
	assoc_main = {
		'multipart': gtk.STOCK_DIRECTORY,
		'message': 'emblem-mail',
	}
	assoc_full = {
		'application/pgp-signature': 'mail-signed',
		'application/ics': 'x-office-calendar',
		'text/calendar': 'x-office-calendar',
		'inode/directory': gtk.STOCK_DIRECTORY,
		'inode/x-empty': 'document-new',
	}
	full = main + '/' + sub
	
	if full == 'multipart/digest':
		return 'emblem-mail'
	if assoc_full.has_key(full):
		return assoc_full[full]
	elif assoc_main.has_key(main):
		return assoc_main[main]
	
	if full in ['text/html']:
		return main + '-' + sub
	elif main in ['audio', 'image', 'font', 'package', 'text', 'video']:
		return main + '-x-generic'

	return gtk.STOCK_FILE

def sighandler(sign, frame):
	if sign == signal.SIGTERM:
		glib.idle_add(sig_term, priority=glib.PRIORITY_HIGH)

def sig_term():
	act_quit()
	return False

def act_quit():
	if win_comp.get_visible():
		act_close_edit()
	if win_comp.get_visible():
		return True
	win_main.hide()
	win_comp.hide()
	gtk.main_quit()
	return False

def act_close_edit():
	if not win_comp.get_data('email-sent') and not win_comp.get_data('is-saved'):
		if not question(_("Message is not saved.\nClose anyway?"), (None, gtk.STOCK_QUIT if cliArgs.compose else gtk.STOCK_CLOSE)):
			return True
	win_comp.hide()
	if cliArgs.compose:
		win_main.hide()
		gtk.main_quit()
		return False
	else:
		toggle_rqdn.set_sensitive(True)
		return True

def act_button(func):
	if type(func) != type(()):
		func = (func,)
	if func[0] is not None:
		func[0](*func[1:])

def on_click_button(btn, func):
	act_button(func)
	return False

def on_press_button(btn, evt, func):
	if evt.type == gtk.gdk.BUTTON_PRESS:
		if evt.button == 3 or (evt.button == 1 and evt.state & gtk.gdk.SHIFT_MASK):
			act_button(func)
	return False

def open_comp_hdr_menu(widget, event):
	if event.button == 3 or (event.button == 1 and event.state & gtk.gdk.SHIFT_MASK):
		menu_add_header.popup(None, None, None, event.button, event.time)
		return True

def act_comp_hdr_menuitem(mi, hname=None):
	if hname is None:
		hname = mi.get_data('chname')
	if hname == '':
		menuitem_all_comp_hdr.set_active(True)
	on = mi.active if isinstance(mi, gtk.CheckMenuItem) else None
	box = add_composer_header__direct(hname)
	if on == False:
		box.cancel()
	else:
		glib.idle_add(box.scrollfocus, priority=glib.PRIORITY_DEFAULT_IDLE)
	return True

def act_all_comp_hdr(mi):
	show_advanced_comp_hdr(mi.active)

def show_advanced_comp_hdr(show=True):
	clear_composer_headers('', '')
	for n in range(0, len(panel_comp_header.children())):
		box = panel_comp_header.children()[n]
		if box.hntype == compose_header_box.HNTYPE_CUSTOM:
			if show:
				box.show()
			else:
				box.hide()

def add_composer_header__direct(hname, hval=None):
	box = None
	for thisbox in panel_comp_header.children():
		if thisbox.hntype == compose_header_box.HNTYPE_LABEL and thisbox['name'] == hname:
			box = thisbox
			if hval is not None: box['value'] = hval
			break
	if box is None:
		if hval is None: hval = ''
		box = compose_header_box(hname, hval)
		panel_comp_header.pack_start(box, False, True)
		if box.hntype == compose_header_box.HNTYPE_MENU:
			for n in range(0, len(panel_comp_header.children())):
				if panel_comp_header.children()[n].hntype == compose_header_box.HNTYPE_CUSTOM:
					panel_comp_header.reorder_child(box, n)
					break
				n += 1
	box.focus()
	box.show_all()
	return box

def add_composer_header(hname, hval=None):
	box = add_composer_header__direct(hname, hval)
	box.tick_my_menuitem(1)
	return box

def add_composer_headers(hname, hvals):
	for hval in hvals:
		box = add_composer_header__direct(hname, hval)
		box.tick_my_menuitem(1)

def set_composer_headers(hname, hvals):
	clear_composer_headers(hname)
	for hval in hvals:
		add_composer_header(hname, hval)

def clear_composer_headers(hname, content=None):
	for box in panel_comp_header.children():
		if (hname is None or box['name'] == hname) and (content is None or content == box['value']):
			box.cancel(manual=False)

class compose_header_box(gtk.HBox):
	HNTYPE_LABEL, HNTYPE_MENU, HNTYPE_CUSTOM = range(3)
	
	def __init__(self, chname, val, hntype=None):
		assert isinstance(chname, str)
		assert isinstance(val, str) or isinstance(val, unicode)
		plus = True
		minus = True
		
		super(self.__class__, self).__init__(False, 2)
		if hntype is None:
			if chname in SenderHeaders:
				hntype = self.HNTYPE_LABEL
			elif chname in RecipientHeaders:
				hntype = self.HNTYPE_MENU
			else:
				hntype = self.HNTYPE_CUSTOM
		
		self.hntype = hntype
		if self.hntype == self.HNTYPE_CUSTOM:
			self.wdg_name = gtk.combo_box_entry_new_with_model(UnionHeadersStore, 0)
			self.wdg_name.connect('changed', self.on_name_changed)
		elif self.hntype == self.HNTYPE_MENU:
			self.wdg_name = gtk.Button()
			self.wdg_name.set_relief(gtk.RELIEF_NONE)
			self.wdg_name.connect('button-release-event', self.popup_rcpt_menu)
			self.wdg_name.connect('button-press-event', self.propagate_button_press_event)
		elif self.hntype == self.HNTYPE_LABEL:
			plus = False
			self.wdg_name = gtk.Label()
		self.pack_start(self.wdg_name, False, True)
		
		self.wdg_value = gtk.Entry()
		self.pack_start(self.wdg_value, True, True)
		self.wdg_value.connect('changed', self.on_value_changed)
		self.completer = gtk.EntryCompletion()
		self.wdg_value.set_completion(self.completer)
		self.completer.set_model(gtk.ListStore(str))
		self.completer.set_minimum_key_length(0)
		self.completer.set_text_column(0)
		
		self.btn_datetime = StockButton('', 'x-office-calendar', icon_size=gtk.ICON_SIZE_MENU)
		self.btn_datetime.set_relief(gtk.RELIEF_NONE)
		self.pack_start(self.btn_datetime, False, False)
		self.btn_datetime.connect('clicked', self.pick_datetime)
		self.btn_datetime.connect('button-press-event', self.propagate_button_press_event)
		
		if plus:
			self.btn_add = StockButton('', gtk.STOCK_ADD, icon_size=gtk.ICON_SIZE_MENU)
			self.pack_start(self.btn_add, False, False)
			self.btn_add.set_relief(gtk.RELIEF_NONE)
			self.btn_add.connect('clicked', self.duplicate)
			self.btn_add.connect('button-press-event', self.propagate_button_press_event)
		if minus:
			self.btn_del = StockButton('', gtk.STOCK_REMOVE, icon_size=gtk.ICON_SIZE_MENU)
			self.btn_del.set_relief(gtk.RELIEF_NONE)
			self.pack_start(self.btn_del, False, False)
			self.btn_del.connect('clicked', self.cancel)
			self.btn_del.connect('button-press-event', self.propagate_button_press_event)
		
		self['name'] = chname
		self['value'] = val
	
	def propagate_button_press_event(self, w, evt):
		self.parent.parent.parent.emit('button-press-event', evt)
	
	def pick_datetime(self, w):
		prompt_datetime(self.wdg_value)
	
	def showhide_pick_buttons(self):
		if self['name'] in DateTimeHeaders:
			self.btn_datetime.show()
		else:
			self.btn_datetime.hide()
	
	def on_name_changed(self, x=None):
		name = self['name']
		self.showhide_pick_buttons()
		if name in ValidatorHeaders.keys():
			self['validate'] = ValidatorHeaders[name]
		else:
			self['validate'] = None
		if name == HDR_DNT:
			ninja_toggle(toggle_rqdn, True)
		model = self.completer.get_model()
		model.clear()
		if type(self['validate']) == list:
			for text in self['validate']:
				model.append([text])
		self.on_changed()
	
	def on_value_changed(self, entry=None):
		if entry is None: entry = self.wdg_value
		bg_normal = entry.get_data('bg-normal')
		if not bg_normal:
			bg_normal = entry.get_style().base[gtk.STATE_NORMAL]
			entry.set_data('bg-normal', bg_normal)
		valid = self.validate()
		if valid:
			entry.modify_base(gtk.STATE_NORMAL, bg_normal)
			self['valid'] = True
		else:
			bg_invalid = gtk.gdk.Color('#FFA4A4')
			entry.modify_base(gtk.STATE_NORMAL, bg_invalid)
			self['valid'] = False
			self.point_out()
		self.on_changed()
		return False

	def on_changed(self):
		name = self['name']
		val = self['value']
		if name == 'Importance':
			ninja_toggle(toggle_unimportant, val.lower().find('low')>-1)
			ninja_toggle(toggle_important, val.lower().find('high')>-1)
		set_unsaved()
	
	def validate(self):
		if not self['validate']:
			return True
		text = self['value']
		if text == '':
			return True
		if type(self['validate']) == list:
			return (text in self['validate'] or '' in self['validate'])
		if self['validate'].has_key('require'):
			if not re.search(self['validate']['require'], text):
				return False
		if self['validate'].has_key('repetative'):
			remainder = text
			while True:
				m = re.match(self['validate']['repetative'], remainder)
				if m is not None:
					remainder = remainder[m.end():]
					if remainder == '':
						break
				else:
					return False
			if remainder != '':
				return False
		if self['validate'].has_key('all'):
			for regexp in self['validate']['all']:
				if not re.search(regexp, text):
					return False
		if self['validate'].has_key('one'):
			one = False
			for regexp in self['validate']['one']:
				if re.search(regexp, text):
					one = True
					break
			if not one:
				return False
		if self['validate'].has_key('deny'):
			for regexp in self['validate']['deny']:
				if re.search(regexp, text):
					return False
		return True
	
	def point_out(self):
		if self.hntype == self.HNTYPE_CUSTOM:
			menuitem_all_comp_hdr.set_active(True)
		self.focus()
		glib.idle_add(self.scrollfocus, priority=glib.PRIORITY_DEFAULT_IDLE)
	
	def popup_rcpt_menu(self, wdg, evt):
		if evt.button == 1:
			wdg.set_relief(gtk.RELIEF_NORMAL)
			mnu = gtk.Menu()
			mnu.connect('deactivate', self.popup_rcpt_menu_disappear, wdg)
			for chname in RecipientHeaders:
				mi = gtk.MenuItem(label=_(chname))
				mi.set_data('name', chname)
				mi.connect('activate', self.popup_rcpt_menuitem_activated, wdg)
				mnu.append(mi)
			mnu.show_all()
			mnu.popup(None, None, self.bottomleft, evt.button, evt.time, wdg)
			return True
		return False
	
	def popup_rcpt_menuitem_activated(self, mi, wdg):
		self['name'] = mi.get_data('name')
		self.popup_rcpt_menu_disappear(mi.parent, wdg)
	
	def popup_rcpt_menu_disappear(self, mnu, wdg):
		wdg.set_relief(gtk.RELIEF_NONE)
		self.focus()
	
	def bottomleft(self, mnu, wdg):
		X, Y = self.window.get_origin()
		x, y, w, h = wdg.get_allocation()
		mx = X + x
		my = Y + y + h
		return (mx, my, True)
	
	def show_all(self):
		super(self.__class__, self).show_all()
		if self.hntype == self.HNTYPE_CUSTOM and not menuitem_all_comp_hdr.get_active():
			self.hide()
		self.showhide_pick_buttons()
	
	def duplicate(self, evtwdg=None):
		newbox = self.__class__(self['name'], self['value'], hntype=self.hntype)
		self.parent.pack_start(newbox, False, True)
		newbox.show_all()
		newbox.focus()
		for n in range(0, len(self.parent.children())):
			if self.parent.children()[n] == self:
				self.parent.reorder_child(newbox, n)
	
	def cancel(self, evtwdg=None, manual=True):
		if self['name'] and self['value']:
			set_unsaved()
		if self.hntype == self.HNTYPE_LABEL:
			self.hide()
			self.tick_my_menuitem(0)
			if not manual:
				self['value'] = ''
		else:
			if manual and self.hntype == self.HNTYPE_MENU:
				n = 0
				for x in self.parent.children():
					if x.hntype == self.HNTYPE_MENU: n += 1
					if n > 1: break
				if n < 2: return False
			# FIXME
			if self['name'] == 'Importance':
				if self['value'].lower().find('low')>-1:
					ninja_toggle(toggle_unimportant, False)
				if self['value'].lower().find('high')>-1: 
					ninja_toggle(toggle_important, False)
			# FIXME
			if self['name'] == HDR_DNT:
				ninja_toggle(toggle_rqdn, False)
			self.parent.remove(self)
	
	def tick_my_menuitem(self, on):
		for mi in menu_add_header.children():
			if mi.get_data('chname') == self['name']:
				mi.set_active(on)
				break
	
	def focus(self):
		if not self.wdg_value.has_focus():
			self.wdg_value.grab_focus()
			self.wdg_value.set_position(-1)
	
	def scrollfocus(self):
		if self.get_visible():
			scrwin = self.parent.parent
			cntnr = scrwin.child
			vadj = scrwin.get_vadjustment()
			wdg = win_comp.get_focus()
			
			if wdg is not None:
				wleft, wtop = wdg.translate_coordinates(cntnr, 0, 0)
				wbottom = wtop + wdg.get_allocation().height
				top = vadj.value
				bottom = top + vadj.page_size
				if wtop < top:
					vadj.value = wtop
				elif wbottom > bottom:
					vadj.value = wbottom - vadj.page_size
	
	def __getitem__(self, key):
		if key == 'name':
			if self.hntype == self.HNTYPE_CUSTOM:
				it = self.wdg_name.get_active_iter()
				if it is not None:
					return self.wdg_name.get_model().get_value(it, 0)
				else:
					return self.wdg_name.children()[0].get_text()
			else:
				return self.wdg_name.get_data('name')
		elif key == 'value':
			return self.wdg_value.get_text()
		elif key == 'readonly':
			return not self.wdg_value.get_sensitive()
		elif key in ['validate', 'valid']:
			return self.wdg_value.get_data(key)
		else:
			raise IndexError()
	
	def __setitem__(self, key, newvalue):
		if key == 'name':
			old = self[key]
			self.wdg_name.set_data('name', newvalue)
			if self.hntype == self.HNTYPE_CUSTOM:
				self.wdg_name.children()[0].set_text(newvalue)
			else:
				self.wdg_name.set_data('name', newvalue)
				self.wdg_name.set_label(_(newvalue))
			if old != newvalue:
				self.on_name_changed()
		elif key == 'value':
			self.wdg_value.set_text(newvalue)
		elif key == 'readonly':
			self.wdg_name.set_sensitive(not newvalue)
			self.wdg_value.set_sensitive(not newvalue)
		elif key == 'validate':
			self.wdg_value.set_data(key, newvalue)
			self.on_value_changed()
		elif key == 'valid':
			assert isinstance(newvalue, bool)
			self.wdg_value.set_data(key, newvalue)
		else:
			raise IndexError()


class Clock(gtk.HBox):
	def __init__(self):
		super(self.__class__, self).__init__()
		self.spin_hour = gtk.SpinButton()
		self.spin_minute = gtk.SpinButton()
		self.spin_second = gtk.SpinButton()
		self.spin_hour.set_range(0, 23)
		self.spin_minute.set_range(0, 59)
		self.spin_second.set_range(0, 59)
		self.spin_hour.set_increments(1, 6)
		self.spin_minute.set_increments(1, 15)
		self.spin_second.set_increments(1, 15)
		self.spin_hour.set_wrap(True)
		self.spin_minute.set_wrap(True)
		self.spin_second.set_wrap(True)
		self.spin_hour.set_numeric(True)
		self.spin_minute.set_numeric(True)
		self.spin_second.set_numeric(True)
		self.select_time()
		self.pack_start(self.spin_hour, False, False)
		self.pack_start(gtk.Label(':'), False, False)
		self.pack_start(self.spin_minute, False, False)
		self.pack_start(gtk.Label(':'), False, False)
		self.pack_start(self.spin_second, False, False)
		self.show_all()
	
	def select_time(self, ts=None):
		t = time.localtime(ts)
		self.spin_hour.set_value(t.tm_hour)
		self.spin_minute.set_value(t.tm_min)
		self.spin_second.set_value(t.tm_sec)
	
	def get_time(self):
		return (self.spin_hour.get_value_as_int(), self.spin_minute.get_value_as_int(), self.spin_second.get_value_as_int())

def prompt_datetime(entry):
	def select_datetime(ts=None):
		y, m, d, x, x, x, x, x, x = time.localtime(ts)
		calendar.select_month(m-1, y)
		calendar.select_day(d)
		clock.select_time(ts)
	dlg = gtk.MessageDialog(get_current_window(), gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_OTHER, gtk.BUTTONS_OK_CANCEL, _("Select Date and Time in local TimeZone"))
	calendar = gtk.Calendar()
	clock = Clock()
	dt = email.utils.parsedate_tz(entry.get_text())
	if dt is not None:
		select_datetime(email.utils.mktime_tz(dt))
	cbox = dlg.get_content_area()
	cbox.pack_start(calendar, True, True)
	cbox.pack_start(clock, True, True)
	btn_now = StockButton(_("Now"), gtk.STOCK_JUMP_TO)
	btn_now.connect('clicked', lambda x: select_datetime())
	abox = dlg.get_action_area()
	abox.pack_start(btn_now, False, False)
	dlg.show_all()
	resp = dlg.run()
	if resp == gtk.RESPONSE_OK:
		y, m, d = calendar.get_date()
		H, M, S = clock.get_time()
		entry.set_text(email.utils.formatdate(time.mktime((y, m+1, d, H, M, S, -1, -1, -1)), True))
	dlg.destroy()

def get_composer_headers(hname, even_if_hidden=False):
	hlist = []
	for hbox in panel_comp_header.children():
		if even_if_hidden or hbox.get_visible():
			if hname is None:
				hlist.append((hbox['name'], hbox['value']))
			elif type(hname) == type([]) and hbox['name'] in hname:
				hlist.append(hbox['value'])
			elif hbox['name'] == hname:
				hlist.append(hbox['value'])
	return hlist

def set_composer_subject(s):
	entry_subject.set_text(s)

def get_composer_subject():
	return entry_subject.get_text()

def on_edit_subject(wdg):
	set_unsaved()

def set_composer_text(s):
	bufr = panel_edit_message.get_buffer()
	bufr.set_text(s)
	bufr.place_cursor(bufr.get_start_iter())

def get_composer_text():
	bufr = panel_edit_message.get_buffer()
	return bufr.get_text(bufr.get_start_iter(), bufr.get_end_iter(), True)

def open_composer():
	if win_comp.get_visible():
		act_close_edit()
	if win_comp.get_visible():
		win_comp.set_urgency_hint(True)
		win_comp.present()
		win_comp.set_urgency_hint(False)
		return False
	
	global NewEmail
	NewEmail = MIMEMultipart('mixed')
	win_comp.set_data('preserve-headers', map(lambda x: x[0], NewEmail._headers))
	NewEmail.preamble = PREAMBLE
	part0 = MIMEText('')
	part0.set_charset('UTF-8')
	part0.replace_header(HDR_CTE, '')
	NewEmail.attach(part0)
	Attachments.clear()
	
	win_comp.show_all()
	panel_edit_message.set_data('saved-font', get_current_font(panel_edit_message))
	menuitem_all_comp_hdr.set_active(False)
	clear_composer_headers(None)
	add_composer_From_hidden()
	for h in SenderHeaders:
		add_composer_header(h).cancel()
	set_composer_subject('')
	set_composer_text('')

	win_comp.set_data('is-an-mdn', False)
	win_comp.set_data('set-xattr-on-send', [])
	win_comp.set_data('saved-to-file', None)
	on_after_save_draft()
	return True

def quote_message_plain():
	if PartPrimary is not None:
		return re.sub('(^|\n)(.)', '\\1> \\2', get_content_readably(Parts[PartPrimary][0]))
	return '>'

def get_gecos_name():
	return re.sub(',.*,.*,.*', '', pwd.getpwuid(os.getuid()).pw_gecos)

def get_user_signature():
	try:
		sign = ''.join(open(os.path.join(os.environ['HOME'], '.signature'), 'r').readlines())
		sign = re.sub('\n?$', '\n', sign)
	except:
		sign = '--\n' + get_gecos_name() + '\n'
	return sign

def filter_out_addresses(noaddrs, hvals):
	filtered = []
	for realname, addr in email.utils.getaddresses(hvals):
		if addr not in noaddrs:
			filtered.append(email.utils.formataddr((realname, addr)))
	return filtered

def add_composer_agent_headers():
	add_composer_header('User-Agent', USERAGENT)
	add_composer_header('X-Mailer', USERAGENT)

def add_composer_mailto(mailto):
	for h in 'To', 'Cc', 'Bcc':
		k = h.lower()
		if mailto.has_key(k):
			add_composer_headers(h, mailto[k] if hasattr(mailto[k], '__iter__') else [mailto[k]])
	if mailto.has_key('subject'):
		set_composer_subject(mailto['subject'])
	if mailto.has_key('body'):
		set_composer_text(mailto['body'])

def guess_my_address():
	if Email is None: return None
	return get_one_header_main('Envelope-To') or get_one_header_main('Delivered-To')

def guess_reply_address():
	if Email is None: return None
	for h in ['Reply-To', 'From', 'Sender', 'X-Sender', 'X-X-Sender']:
		if Email[h] is not None:
			return get_one_header_main(h)
	return None

def add_composer_From_hidden():
	addr = guess_my_address()
	if addr is not None:
		name = get_gecos_name()
		box = add_composer_header('From', email.utils.formataddr((name, addr)))
		box.cancel()
		return True
	return False

def act_compose():
	if open_composer():
		add_composer_agent_headers()
		add_composer_header('To', '')
		set_composer_subject('')
		set_composer_text('\n\n' + get_user_signature())
		on_after_save_draft()
		panel_edit_message.grab_focus()

def act_reply(recip):
	if open_composer():
		add_composer_agent_headers()
		subj = get_one_header_main('Subject') or ''
		body = '\n\n' + get_user_signature()
		my_address = guess_my_address()

		if recip == '':
			win_comp.set_data('set-xattr-on-send', [XATTR_FORWARDED])
			fwdname = (subj or _("Email")) + '.eml'
			pre = _("Fwd: ")
			if not subj.lower().startswith(pre.lower()): subj = pre + subj
			set_composer_subject(subj)
			add_composer_header('To', '')
			references = get_one_header_main('References')
			if references is not None:
				add_composer_header('References', references)
			
			part = MIMEMessage(Email)
			part.add_header(HDR_CD, 'attachment', filename=fwdname)
			NewEmail.attach(part)
			Attachments.append(None, [part, fwdname, 'emblem-mail', None])
		else:
			win_comp.set_data('set-xattr-on-send', [XATTR_REPLIED])
			add_composer_header('Thread-Topic', get_one_header_main('Thread-Topic') or subj)
			pre = _("Re: ")
			if not subj.lower().startswith(pre.lower()): subj = pre + subj
			set_composer_subject(subj)
			body += '\n' + _("Quote:") + '\n\n' + quote_message_plain()

			messageid = get_one_header_main('Message-ID')
			references = get_one_header_main('References')
			if messageid is not None:
				add_composer_header('In-Reply-To', messageid)
				if references is not None:
					references = references + ' ' + messageid
				else:
					references = messageid
			if references is not None:
				add_composer_header('References', references)
			
			reply_fulladdress = guess_reply_address()
			reply_address = email.utils.parseaddr(reply_fulladdress)[1]
			listaddress = get_listaddress_main()
			
			if recip == 'one':
				add_composer_header('To', reply_fulladdress or '')
			elif recip == 'all':
				skip_addresses = [my_address, reply_address, '']
				rcpt_addresses = []
				
				if reply_address != '' and reply_address != my_address:
					add_composer_header('To', reply_fulladdress)
				for h in 'To', 'Cc':
					for addrspec in filter_out_addresses(skip_addresses, get_all_headers_main(h)):
						# get_all_headers_main() gives back realnames decoded
						add_composer_header(h, addrspec)
						rcpt_addresses.append(email.utils.parseaddr(addrspec)[1])
				if listaddress is not None and listaddress not in rcpt_addresses:
					add_composer_header('To', listaddress)
			elif recip == 'list':
				add_composer_header('To', listaddress)
		
		set_composer_text(body)
		on_after_save_draft()
		panel_edit_message.grab_focus()

def shorturl(url, maxlength=72):
	if len(url) > maxlength:
		return url[0:maxlength-1] + '…'
	else:
		return None

def act_unsubscribe():
	links = get_mailtos(','.join(Email.get_all('List-Unsubscribe')), schemata=['mailto', 'http', 'https', '*'])
	if len(links) == 1 and links[0]['split'].scheme == 'mailto':
		if open_composer():
			add_composer_mailto(links[0])
			on_after_save_draft()
	else:
		text = ''
		for link in links:
			uri = urlparse.unquote(link['uri'])
			escuri = glib.markup_escape_text(uri)
			if link['split'].scheme == 'mailto':
				linktext = link['to']
			else:
				short = shorturl(uri, 80)
				if short is None:
					linktext = escuri
				else:
					linktext = glib.markup_escape_text(short)
			text += '\n\n<a href=\'%s\'>%s</a>' % (escuri, linktext)
		dlg = gtk.MessageDialog(win_main, gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_OTHER, gtk.BUTTONS_CLOSE)
		dlg.set_title(_("Unsubscribe Methods"))
		dlg.set_markup(_("Select a link to unsubscribe") + text)
		try:
			label = dlg.get_content_area().children()[0].children()[1].children()[0]
			label.set_selectable(False)
			dlg.get_action_area().children()[0].grab_focus()
		except: pass
		dlg.run()
		dlg.destroy()

def scroll_textview(tv, rect, scrwin):
	vadj = scrwin.get_vadjustment()
	vadj.set_value(vadj.upper - vadj.page_size)

def act_report_spam(considered_as_spam = True):
	spamdirname = 'Spam'
	emailfile = os.path.abspath(cliArgs.FILE)
	curdir = os.path.dirname(emailfile)
	if os.path.basename(curdir) == spamdirname:
		isin_spam_folder = True
		inboxpath = os.path.dirname(curdir)
	else:
		isin_spam_folder = False
		inboxpath = curdir
	inboxname = os.path.basename(inboxpath)
	
	if considered_as_spam:
		razorwin = start_razor_window(_("Reporting Spam"), [['razor-report', '-d', '-f'], ['pyzor', '-d', 'report']])
		Lqtxt = _("Move it into <tt>%s</tt> folder?" % (spamdirname))
		btndesc = (_("Move in"), gtk.STOCK_DELETE)
		targetdir = os.path.join(curdir, spamdirname)
	else:
		razorwin = start_razor_window(_("Reporting Ham"), [['razor-revoke', '-d', '-f'], ['pyzor', '-d', 'whitelist']])
		Lqtxt = _("Move it out from <tt>%s</tt> folder into <tt>%s</tt>?") % (spamdirname, inboxname)
		btndesc = (_("Move out"), gtk.STOCK_UNDELETE)
		targetdir = inboxpath
	
	if (considered_as_spam and not isin_spam_folder) or (not considered_as_spam and isin_spam_folder):
		if question(Lqtxt, btndesc, parent=razorwin):
			try:
				mkdir(targetdir)
				os.rename(emailfile, os.path.join(targetdir, os.path.basename(emailfile)))
			except OSError, e:
				display_error(e)

def start_razor_window(title, cmdargses):
	win = gtk.Window()
	bgc = win.get_style().bg[gtk.STATE_NORMAL]
	vb = gtk.VBox(False, 6)
	hb = gtk.HBox()
	btn = StockButton(stock=gtk.STOCK_CLOSE)
	win.add(vb)
	panels = []
	for cmdargs in cmdargses:
		spanel = gtk.ScrolledWindow()
		panel = gtk.TextView()
		panels.append((panel, cmdargs))
		spanel.add(panel)
		vb.pack_start(spanel, True, True)

		spanel.set_size_request(420, 42)
		spanel.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
		panel.set_editable(False)
		panel.set_wrap_mode(gtk.WRAP_NONE)
		panel.modify_font(pango.FontDescription('monospace'))
		panel.modify_base(gtk.STATE_NORMAL, bgc)
		panel.connect('size-allocate', scroll_textview, spanel)
	vb.pack_start(hb, False, True)
	hb.pack_start(btn, True, False)
	
	win.set_transient_for(win_main)
	win.set_modal(True)
	win.set_border_width(4)
	win.set_title(title)
	h = win.connect('delete-event', lambda w, e: True)
	win.set_data('close-handler-id', h)
	win.set_data('close-button', btn)
	btn.set_sensitive(False)
	btn.connect('clicked', lambda w: win.destroy())
	win.show_all()
	
	wait_threads = []
	for panel, cmdargs in panels:
		buffer = panel.get_buffer()
		pipedesc_reader, pipedesc_writer = os.pipe()
		thrd_feed = threading.Thread(target=spam_feeder_thread, args=(pipedesc_writer,))
		thrd_feed.start()
		thrd = threading.Thread(target=runcmd_thread, args=(cmdargs, pipedesc_reader, buffer, win))
		wait_threads.append((thrd, buffer))
		thrd.start()
	win.set_data('threads', wait_threads)
	return win

def spam_feeder_thread(fd):
	os.write(fd, Email.as_string())
	os.close(fd)

def runcmd_thread(args, input_fd, out_buffer, win):
	reader, writer = get_pipe_handlers(1)
	pid = os.fork()
	if pid == 0:
		reader.close()
		os.dup2(input_fd, sys.stdin.fileno())
		os.dup2(writer.fileno(), sys.stdout.fileno())
		os.dup2(writer.fileno(), sys.stderr.fileno())
		os.closerange(3, 255)
		try:
			os.execvp(args[0], args)
		except OSError, e:
			sys.stderr.write(str(e))
		os._exit(127)
	
	writer.close()
	while True:
		ln = reader.readline()
		if ln == '': break
		gtk.threads_enter()
		out_buffer.insert(out_buffer.get_end_iter(), ln)
		gtk.threads_leave()
	reader.close()
	status = WaitExecStatus(pid)

	gtk.threads_enter()
	out_buffer.insert(out_buffer.get_end_iter(), _("exit code: %s") % (status.code))
	out_buffer.set_data('process-exit-status', status)
	glib.idle_add(lambda: close_razor_window_handler(win), priority=glib.PRIORITY_DEFAULT_IDLE)
	gtk.threads_leave()

def close_razor_window_handler(wnd):
	h = wnd.get_data('close-handler-id')
	if h is None:
		return True
	wait_threads = wnd.get_data('threads')
	if wait_threads is None:
		return True
	for thread, textbuffer in wait_threads:
		if thread.is_alive():
			return True
	wnd.connect('delete-event', lambda w, e: w.destroy())
	add_key_binding(wnd, 'Escape', lambda a,b,c,d: wnd.destroy())
	wnd.disconnect(h)
	wnd.set_data('close-handler-id', None)
	wnd.get_data('close-button').set_sensitive(True)
	return False

def get_extension_by_mime(mime):
	if mime is None:
		e = None
	elif mime.startswith('multipart/'):
		e = '.eml'
	else:
		e = guess_extension(mime)
	if e is None:
		e = '.dat'
	return e

def get_mime_by_filepath(path):
	t = Magic.file(os.path.realpath(path))
	if t is None or t.find('/')<1:
		return 'application/octet-stream'
	return t

def act_open():
	eml = get_part_by_itpath()
	if eml is None: return
	mime = eml.get_content_type()
	fd, tmppath = mkstemp(prefix = PROGNAME + '-', suffix = get_extension_by_mime(mime))
	try:
		save_to_filedescriptor(eml, fd)
		fh = os.fdopen(fd, 'r')
		set_xattrs(fh, {XATTR_CHARSET: eml.get_content_charset(), XATTR_TYPE: mime}, tmppath)
		fh.close()
	except OSError, e:
		os.unlink(tmppath)
		e.filename = tmppath
		display_error(e)
		return
	run_async('mimeopen-gui', [tmppath], [os.unlink, tmppath])

def calc_attachment_name(part, n=None):
	name = part.get_filename()
	if name is None:
		sfx = ''
		if n is not None: sfx = '-' + str(n)
		name = "%s - attachment%s%s" % (get_one_header_main('Subject') or _("Email"), sfx, get_extension_by_mime(part.get_content_type()))
	return name

def act_save_struct():
	itpaths = selection_parts.get_selected_rows()[1]
	savedir = choose_save_folder()
	if savedir is not None:
		for n in range(0, len(itpaths)):
			act_save_struct_inner(savedir, Parts.get_iter(itpaths[n]))

def act_save_struct_inner(savedir, iterator):
	part = Parts[iterator][0]
	oid = '-'.join(map(str, Parts.get_path(iterator)))
	myname = part.get_filename()
	if Parts.iter_has_child(iterator):
		if not myname:
			myname = 'multipart-%s' % (oid)
		mysavedir = os.path.join(savedir, myname)
		try:
			mkdir(mysavedir)
		except OSError, e:
			display_error(e)
		else:
			for nth in range(0, Parts.iter_n_children(iterator)):
				subiter = Parts.iter_nth_child(iterator, nth)
				act_save_struct_inner(mysavedir, subiter)
	else:
		if not myname:
			myname = 'part-%s%s' % (oid, get_extension_by_mime(part.get_content_type()))
		savefile = os.path.join(savedir, myname)
		save_to_file(part, savefile)

def act_save():
	itpaths = selection_parts.get_selected_rows()[1]
	if len(itpaths) == 1:
		itpath = itpaths[0]
		eml = get_part_by_itpath(itpath)
		savefile = choose_save_file(calc_attachment_name(eml))
		if savefile is not None:
			save_to_file(eml, savefile)
	elif len(itpaths) > 1:
		savedir = choose_save_folder()
		if savedir is not None:
			for n in range(0, len(itpaths)):
				eml = get_part_by_itpath(itpaths[n])
				basename = calc_attachment_name(eml, n)
				savefile = os.path.join(savedir, basename)
				save_to_file(eml, savefile)

def get_xattr(file_, attrname):
	if xattr is not None:
		try:
			return xattr.getxattr(file_, attrname)
		except IOError, e:
			if e.errno != os.errno.ENODATA:
				raise e
	return None

def set_xattrs(fh, attrs, filename='-'):
	if xattr is not None:
		for attrname, attrval in attrs.iteritems():
			try:
				if attrval is None:
					try:
						xattr.removexattr(fh, attrname)
					except IOError, e:
						if e.errno != os.errno.ENODATA:
							raise e
				else:
					xattr.setxattr(fh, attrname, attrval)
			except IOError, e:
				sys.stderr.write((_("Notice: can not set xattr '%s' on '%s': %s") % (attrname, filename, str(e))) + '\n')

def save_to_file(eml, filename, ask_overwrite=True):
	if ask_overwrite:
		if os.path.exists(filename):
			if not question(_("This file already exists:\n%s\nOverwrite?") % (os.path.basename(filename)), (None, gtk.STOCK_SAVE)):
				return None
	try:
		fh = open(filename, 'w')
		fd = fh.fileno()
		save_to_filedescriptor(eml, fd)
		if eml.get_content_maintype() == 'multipart':
			mimetype = 'message/rfc822'
		else:
			mimetype = eml.get_content_type()
		set_xattrs(fh, {XATTR_CHARSET: eml.get_content_charset(), XATTR_TYPE: mimetype}, filename)
		fh.flush()
		moddatetime = get_header_parameter(eml[HDR_CD], 'modification-date')
		if moddatetime:
			futimes(fd, (-1, email.utils.mktime_tz(email.utils.parsedate_tz(moddatetime))))
		fh.close()
		return True
	except IOError, e:
		display_error(e)
	except OSError, e:
		e.filename = filename
		display_error(e)
	return False

def save_to_filedescriptor(eml, fd):
	s = eml.get_payload(decode=1)
	if s is None:
		s = eml.as_string()
	written = os.write(fd, s)
	if written != len(s):
		raise OSError(5, 'Write Error')

def act_view_source():
	if panel_content.get_data('view-unfiltered'):
		filt = None
	else:
		filt = ('', None, False)
	load_part(get_part_by_itpath(), filt)

def act_wrap(tv, i=1):
	modes = cyclelist([gtk.WRAP_WORD, gtk.WRAP_WORD_CHAR, gtk.WRAP_NONE], at=panel_content.get_wrap_mode())
	tv.set_wrap_mode(modes.turn(i))

def get_current_font(txtv):
	pctx = txtv.get_pango_context()
	fdsc = pctx.get_font_description()
	s = fdsc.to_string()
	m = re.search('\s(\d+)(\s|$)', s)
	if m: pt = int(m.group(1))
	else: pt = 12
	return {'family': fdsc.get_family().lower(), 'string': s.lower(), 'size': pt, 'desc': fdsc,}

def act_font_switch(tv):
	font = get_current_font(tv)
	if font['family'] != 'monospace':
		tv.set_data('saved-font', font)
		f = tv.get_data('saved-font-monospace')
		if f is None: f = 'monospace 12'
		else: f = f['string']
	else:
		f = tv.get_data('saved-font')['string']
	change_font(tv, f)

def act_font(tv):
	dlg = gtk.FontSelectionDialog(_("Select Font"))
	dlg.set_transient_for(get_current_window())
	dlg.set_modal(True)
	dlg.set_font_name(tv.get_data('saved-font')['string'])
	if dlg.run() == gtk.RESPONSE_OK:
		font_name = dlg.get_font_name()
		change_font(tv, font_name)
		font = get_current_font(tv)
		if font['family'] == 'monospace':
			key = 'saved-font-monospace'
		else:
			key = 'saved-font'
		tv.set_data(key, font)
	dlg.destroy()

def change_font(tv, s):
	tv.modify_font(pango.FontDescription(s))

def on_select_parts(selection):
	itpaths = selection.get_selected_rows()[1]
	if len(itpaths) > 1:
		panel_btnbox.show()
		lbl_right.set_markup(_("Multiple (%s) selected attachments") % (len(itpaths)))
		btn_open.hide()
		btn_save.set_label(_("Save All"))
		panel_content_image.hide()
		spanel_content.hide()
		btn_open2.set_sensitive(False)
		btn_save2.set_sensitive(True)
		menubutton_filters.set_sensitive(False)
	else:
		panel_btnbox.hide()
		panel_content_image.hide()
		spanel_content.show()
		if len(itpaths) == 1:
			btn_open2.set_sensitive(True)
			btn_save2.set_sensitive(True)
			itpath = itpaths[0]
			eml = get_part_by_itpath(itpath)
			load_part(eml)
			menubutton_filters.set_sensitive(True)
			populate_filters_menu(eml)
		else:
			btn_open2.set_sensitive(False)
			btn_save2.set_sensitive(False)
			clear_content()
			menubutton_filters.set_sensitive(False)

def act_show_view_headers(chkmi):
	show_view_headers(chkmi.active)

def show_view_headers(show=True):
	if show:
		spanel_view_header.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
		panel_view_header.set_size_request(-1, -1)
		panel_view_header.set_line_wrap(False)
		s = ''
		for hname, hval in Email._headers:
			hval = decode_header(hval)
			s += PMU_HEAD + glib.markup_escape_text(hname) + PMU_HEAD_CLOSE + ': ' + glib.markup_escape_text(hval) + '\n'
		panel_view_header.set_markup(s)
	else:
		spanel_view_header.set_policy(gtk.POLICY_NEVER, gtk.POLICY_AUTOMATIC)
		resize_panel_view_header(spanel_view_header)
		panel_view_header.set_line_wrap(True)
		panel_view_header.set_markup(get_headers_markup(Email))
	panel_view_header.set_data('all-headers', show)

def populate_header_menu(label, menu):
	menu.append(gtk.SeparatorMenuItem())
	mi = gtk.CheckMenuItem(_("Show All Headers"))
	mi.set_active(panel_view_header.get_data('all-headers') == True)
	if panel_view_header.get_data('all-headers'): mi.set_active(True)
	mi.connect('toggled', act_show_view_headers)
	menu.append(mi)
	menu.show_all()

def populate_filters_menu(eml):
	for mi in menu_filters.children():
		menu_filters.remove(mi)
	uniqfilt = {}
	for filt in get_filters_by_mime(eml.get_content_maintype(), eml.get_content_subtype()):
		if filt[0] == '': continue
		if uniqfilt.has_key(filt[0]) and uniqfilt[filt[0]] == filt[1]: continue
		uniqfilt[filt[0]] = filt[1]
		lbl = filt[0]
		if lbl == 'sh':
			lbl = ' '.join(re.findall('(^\S+|\d*[<>]+(?:&\d+|\s*\S+)|[;\|&]+\s*\S+)', filt[1][1]))
		mi = gtk.MenuItem(lbl)
		mi.connect('activate', lambda mi, eml, filt: load_part(eml, filt), eml, filt)
		menu_filters.append(mi)
	menu_filters.show_all()
	disable_filters_menu(True if len(menu_filters.children()) == 0 else False)

def disable_filters_menu(b=True):
	menubutton_filters.children()[0].children()[1].set_sensitive(not b)

def get_part_by_itpath(itpath = None):
	if itpath is None:
		try:
			itpath = selection_parts.get_selected_rows()[1][0]
		except IndexError:
			return None
	model = Parts
	return model.get_value(model.get_iter(itpath), 0)

def load_toolitems(toolbar, toolitems):
	items = []
	for label, stock, tip, fnc_left, fnc_right in toolitems:
		hid = None
		if type(fnc_left) == str:
			tbi = gtk.SeparatorToolItem()
			if fnc_left == 'space':
				tbi.set_draw(False)
				tbi.set_expand(True)
			elif fnc_left == 'separator':
				tbi.set_draw(True)
				tbi.set_expand(False)
		elif isinstance(stock, gtk.ToolItem):
			tbi = stock
			if tip is not None:
				tbi.set_tooltip_text(_(tip))
			hid = tbi.connect('clicked', on_click_button, fnc_left)
		else:
			Lstocklabel = None
			st = gtk.stock_lookup(stock)
			if st:
				Lstocklabel = re.sub('_', '', st[1])
			if label is not None:
				Llabel = _(label)
			else:
				Llabel = Lstocklabel
			if tip is not None:
				Ltip = _(tip)
			else:
				if label is not None:
					Ltip = Llabel
				else:
					Ltip = Lstocklabel
			tbi = StockToolButton(label=Llabel, stock=stock, tooltip=Ltip)
			tbi.set_data('stock', stock)
			tbi.set_data('label', label)
			hid = tbi.connect('clicked', on_click_button, fnc_left)
			tbi.child.connect('button-press-event', on_press_button, fnc_right)
		tbi.set_data('clicked-handler', hid)
		toolbar.insert(tbi, -1)
		items.append(tbi)
	return items

def setup_treeview__icon_label(tv, label_edit_cb=None):
	colnum_txt = 1
	tvc = gtk.TreeViewColumn()
	tv.append_column(tvc)
	cr_pix = gtk.CellRendererPixbuf()
	cr_txt = gtk.CellRendererText()
	if label_edit_cb is not None:
		cr_txt.set_property('editable', True)
		cr_txt.connect('edited', label_edit_cb, colnum_txt)
	tvc.pack_start(cr_pix, False)
	tvc.pack_start(cr_txt, True)
	tvc.add_attribute(cr_txt, 'markup', colnum_txt)
	tvc.add_attribute(cr_pix, 'icon-name', 2)
	tvc.add_attribute(cr_pix, 'pixbuf', 3)


def validate_all_comp_headers():
	for n in range(0, len(panel_comp_header.children())):
		box = panel_comp_header.children()[n]
		if box.get_visible():
			valid = box.validate()
			if not valid:
				box.point_out()
				return False
	return True

def act_send():
	msg = ''
	if not validate_all_comp_headers():
		return
	if not get_composer_subject():
		msg += _("No Subject." + '\n')
	if len(filter(lambda x: len(x.strip()), get_composer_headers(RecipientHeaders))) < 1:
		msg += _("No any Recipient." + '\n')
	if msg != '':
		msg += _("Send anyway?")
		if not question(msg, (_("Send"), 'mail-send')):
			return
	build_newemail()
	
	dlg = gtk.MessageDialog(win_comp, gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_INFO, gtk.BUTTONS_CANCEL)
	dlg.connect('delete-event', lambda w, e: True)
	dlg.set_title(_("Sending..."))
	dlg.set_markup(_("Sending..."))
	set_dialog_icon_name(dlg, 'mail-send-receive')
	carea = dlg.get_content_area()
	aarea = dlg.get_action_area()
	progressbar = gtk.ProgressBar()
	carea.pack_start(progressbar, False, True)
	btn_cancel = aarea.children()[0]
	dlg.show_all()
	
	thrd = threading.Thread(target=sending_thread, args=(dlg, progressbar, btn_cancel))
	thrd.start()

def sending_thread(dlg, progressbar, btn_cancel):
	global StopSending
	StopSending = False
	child_read, parent_write, parent_read, child_write = get_pipe_handlers(2)
	pid = os.fork()
	if pid == 0:
		parent_read.close()
		parent_write.close()
		os.dup2(child_read.fileno(), sys.stdin.fileno())
		os.dup2(child_write.fileno(), sys.stdout.fileno())
		os.dup2(child_write.fileno(), sys.stderr.fileno())
		os.closerange(3, 255)
		try:
			os.execvp('sendmail', ['sendmail', '-ti'])
		except OSError, e:
			sys.stderr.write(str(e))
		os._exit(127)
	
	gtk.threads_enter()
	sn = btn_cancel.connect('clicked', sending_cancel, pid, parent_write)
	gtk.threads_leave()
	
	child_read.close()
	child_write.close()
	set_blocking(parent_write, False)
	resp = ''
	text = NewEmail.as_string()
	pos = 0
	bufsize = 4096
	length = len(text)
	while pos < length and not StopSending:
		try:
			parent_write.write(text[pos:pos+bufsize])
			pos += bufsize
		except ValueError, e:
			resp += '>>> ' + str(e) + '\n'
			break
		except IOError, e:
			if e.errno == os.errno.EAGAIN:
				while not StopSending:
					ready = select.select([], [parent_write], [], 1.0)
					if len(ready[1]) > 0:
						break
			else:
				raise e
		gtk.threads_enter()
		progressbar.set_fraction((min(pos, length) + 0.0) / length)
		gtk.threads_leave()
	set_blocking(parent_write, True)
	if not StopSending:
		try:
			parent_write.close()
		except IOError, e:
			resp += '>>> ' + str(e) + '\n'
	
	resp += ''.join(parent_read.readlines())
	parent_read.close()
	status = WaitExecStatus(pid)
	
	gtk.threads_enter()
	progressbar.hide()
	btn_cancel.hide()
	btn_close = gtk.Button(stock=gtk.STOCK_CLOSE)
	btn_close.connect('clicked', lambda x: dlg.destroy())
	dlg.get_action_area().pack_start(btn_close, False, False)
	btn_close.show_all()
	output_mu = '\n<tt>' + glib.markup_escape_text(resp) + '</tt>'
	if status.code == 0:
		set_dialog_icon_name(dlg, gtk.STOCK_APPLY)
		dlg.set_markup(_("Email is sent.") + output_mu)
		win_comp.set_data('email-sent', True)
		if win_comp.get_data('is-an-mdn'):
			menubutton_mdn.set_markup(menubutton_mdn.get_data('saved-label'))
		if hasattr(cliArgs, 'FILE'):
			MsgId = NewEmail['Message-ID']
			for xattrname in win_comp.get_data('set-xattr-on-send'):
				set_xattrs(cliArgs.FILE, {xattrname: MsgId}, cliArgs.FILE)
	else:
		set_dialog_icon_name(dlg, gtk.STOCK_DIALOG_ERROR)
		dlg.set_markup(_("Sendmail error %s." % (status.code)) + output_mu)
	gtk.threads_leave()

def sending_cancel(btn, pid, writer_fh):
	global StopSending
	StopSending = True
	os.kill(pid, signal.SIGINT)

def build_newemail():
	preserve_headers = win_comp.get_data('preserve-headers')
	idx = 0
	for hname, hval in NewEmail._headers:
		if hname not in preserve_headers:
			del(NewEmail._headers[idx])
			continue
		idx += 1
	for hname, hval in get_composer_headers(None) + [('Subject', get_composer_subject())]:
		if len(hname) > 0 and len(hval) > 0:
			enchunks = []
			for chunk in hval.split(' '):
				try:
					enchunk = make_header([(chunk, None)])
				except UnicodeDecodeError:
					enchunk = make_header([(chunk, 'UTF-8')])
				enchunks.append(str(enchunk))
			NewEmail.add_header(hname, ' '.join(enchunks))
	
	# if there is not Message-ID but we must set at least one xattr
	if not NewEmail[HDR_MI] and win_comp.get_data('set-xattr-on-send'):
		NewEmail.add_header(HDR_MI, email.utils.make_msgid())
	
	text = get_composer_text()
	text_qp = text.encode('quoted-printable')
	text_b64 = text.encode('base64')
	if len(text_qp) < len(text_b64):
		text = text_qp
		enc = 'quoted-printable'
	else:
		text = text_b64
		enc = 'base64'
	part0 = NewEmail.get_payload()[0]
	part0.replace_header(HDR_CTE, enc)
	part0.set_payload(text)

def act_save_edit(save_as=False):
	filename = win_comp.get_data('saved-to-file')
	ask_overwrite = False
	if filename is None or save_as:
		ask_overwrite = True
		subj = get_composer_subject()
		if subj: subj = ' - ' + subj
		filename = choose_save_file(_("Draft") + subj + '.eml')
	if filename is not None:
		build_newemail()
		if save_to_file(NewEmail, filename, ask_overwrite=ask_overwrite) == True:
			win_comp.set_data('saved-to-file', filename)
			on_after_save_draft()

def on_after_save_draft():
	set_unsaved(False)
	panel_edit_message.get_buffer().set_modified(False)

def act_addressbook():
	def dblclick(wdg, evt):
		if evt.button == 1 and evt.type == gtk.gdk._2BUTTON_PRESS:
			x = int(evt.x)
			y = int(evt.y)
			pathinfo = trv.get_path_at_pos(x, y)
			if pathinfo is not None:
				itpath, col, cellx, celly = pathinfo
				clear_composer_headers('To', '')
				add_composer_header('To', mod[mod.get_iter(itpath)][0])
	def click_add(btn):
		clear_composer_headers('To', '')
		add_composer_headers('To', map(lambda x: mod[mod.get_iter(x)][0], sel.get_selected_rows()[1]))
	
	win = gtk.Window()
	box = gtk.VBox(False, 3)
	ent = gtk.Entry()
	scr = gtk.ScrolledWindow()
	mod = gtk.ListStore(str)
	flt = mod.filter_new()
	trv = gtk.TreeView(flt)
	sel = trv.get_selection()
	bbx = gtk.HBox(True, 2)
	bad = StockButton(stock=gtk.STOCK_ADD)
	bcl = StockButton(stock=gtk.STOCK_CLOSE)
	
	try:
		for ln in open(os.path.join(os.environ['HOME'], 'Mail', '.addressbook'), 'r'):
			mod.append([ln.strip()])
	except IOError, e:
		display_error(e)
		return
	
	win.set_transient_for(win_comp)
	win.set_modal(True)
	win.set_default_size(280, 400)
	win.set_border_width(4)
	sel.set_mode(gtk.SELECTION_MULTIPLE)
	scr.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
	trv.set_headers_visible(False)
	trv.set_rules_hint(True)
	trv.insert_column_with_attributes(0, '', gtk.CellRendererText(), text=0)
	flt.set_visible_func(lambda mo, it, ent: mo[it][0].find(ent.get_text())>-1, ent)
	win.connect('delete-event', lambda w, x: win.destroy())
	add_key_binding(win, 'Escape', lambda a,b,c,d: win.destroy())
	ent.connect('changed', lambda w: flt.refilter())
	trv.connect('button-press-event', dblclick)
	bcl.connect('clicked', lambda w: win.destroy())
	bad.connect('clicked', click_add)
	
	win.add(box)
	box.pack_start(ent, False, True)
	box.pack_start(scr, True, True)
	scr.add_with_viewport(trv)
	box.pack_start(bbx, False, True)
	bbx.pack_start(bad, True, False)
	bbx.pack_start(bcl, True, False)
	win.show_all()

def act_attach():
	filename = choose_open_file()
	if filename is not None:
		attach_path(filename)

def attach_path(path, parent_part=None, parent_iter=None):
	global NewEmail
	if not os.path.exists(path):
		return False
	if parent_part is None:
		parent_part = NewEmail
	basename = os.path.basename(path)
	ct_main, ct_sub = get_mime_by_filepath(path).split('/')
	
	if os.path.isdir(path):
		part = MIMEMultipart('related')
	else:
		part = MIMEBase(ct_main, ct_sub)
		part.set_payload('')
		enc = None
		try:
			fh = open(path, 'r')
			moddatetime = email.utils.formatdate(os.stat(path).st_mtime, True)
		except IOError, e:
			display_error(e)
			return False
		except OSError, e:
			display_error(e)
			return False
		while True:
			buf = fh.read(4095)
			if buf == '': break
			if enc is None:
				qp = buf.encode('quoted-printable')
				b64 = buf.encode('base64')
				if qp < b64:
					buf = qp
					enc = 'quoted-printable'
				else:
					buf = b64
					enc = 'base64'
				part.add_header(HDR_CTE, enc)
			else:
				buf = buf.encode(enc)
			part._payload += buf
		fh.close()
	
	part.add_header(HDR_CD, 'attachment', filename=basename, modification_date=moddatetime)
	parent_part.attach(part)
	set_unsaved()
	stock = get_stock_by_mime(ct_main, ct_sub)
	pixb = None
	iterator = Attachments.append(parent_iter, [part, basename, stock, pixb])
	
	if os.path.isdir(path):
		for entry in os.listdir(path):
			if not attach_path(os.path.join(path, entry), part, iterator):
				return False
	return True

def drop_attachment_motion(wdg, context, x, y, time):
	wdg.drag_highlight()
	context.drag_status(gtk.gdk.ACTION_COPY, time)
	return True

def drop_attachment_accept(wdg, context, x, y, time):
	accepted = False
	for desired in ['text/uri-list']:
		if desired in context.targets:
			wdg.drag_get_data(context, desired, time)
			accepted = True
			break
	context.drop_reply(accepted, time)
	wdg.drag_unhighlight()
	return True

def drop_attachment(wdg, context, x, y, data, info, time):
	success = None
	if data.get_length() > -1:
		typ = data.get_data_type()
		if typ == 'text/uri-list':
			for uri in data.get_uris():
				if uri.startswith('file:///'):
					if not attach_path(uri[7:]):
						success = False
						break
			if success is None:
				success = True
		else:
			success = False
	else:
		success = False
	context.finish(success, False, time)
	return True

def rename_attachment(cellrenderer, iterator, new_text, colnum):
	eml = Attachments[iterator][0]
	if eml[HDR_CD]:
		eml._headers.remove((HDR_CD, eml[HDR_CD]))
		eml.add_header(HDR_CD, 'attachment', filename=new_text)
		Attachments[iterator][colnum] = new_text
		return True

def on_keypress_attachments(tv, evt):
	if evt.keyval == gtk.gdk.keyval_from_name('Delete'):
		sel = panel_attachments.get_selection()
		for itpath in reversed(sel.get_selected_rows()[1]):
			try:
				iterator = Attachments.get_iter(itpath)
			except ValueError:
				# child was deleted in meantime
				continue
			if Attachments[iterator][0].get_content_type() == 'message/disposition-notification':
				win_comp.get_window().beep()
				continue
			parent_iter = Attachments.iter_parent(iterator)
			if parent_iter is None:
				parent_part = NewEmail
			else:
				parent_part = Attachments[parent_iter][0]
			parent_part._payload.remove(Attachments[iterator][0])
			del(Attachments[iterator])
		return True
	return False

def act_encrypt():
	pass

def act_sign():
	pass

def act_dispos_notif():
	if open_composer():
		NewEmail.set_type('multipart/report')
		NewEmail.set_param('report-type', 'disposition-notification')
		
		win_comp.set_data('is-an-mdn', True)
		win_comp.set_data('set-xattr-on-send', [XATTR_MDNSENT])
		add_composer_agent_headers()
		pndr_box = add_composer_header(HDR_PNDR, 'yes')
		pndr_box['readonly'] = True
		toggle_rqdn.set_sensitive(False)
		
		dnt_address = Email.get_all(HDR_DNT)
		my_address = guess_my_address()
		if dnt_address:
			for realname, addr in email.utils.getaddresses(dnt_address):
				add_composer_header('To', email.utils.formataddr((decode_header(realname), addr)))
		else:
			add_composer_header('To', guess_reply_address())
		lang = get_one_header_main('Accept-Language')
		if lang:
			savelang = os.environ['LANGUAGE']
			os.environ['LANGUAGE'] = lang
		Ltxt_subj = _("Disposition Notification: {subject}")
		Ltxt_body = _("The message sent on {date} to {me} with subject \"{subject}\" "
			"delivered on {delivery_date} and has been displayed. "
			"This is no guarantee that the message has been read or understood.")
		if lang:
			os.environ['LANGUAGE'] = savelang
		prms = {
			'date': get_one_header_main('Date') or '(somewhen)',
			'me': my_address or '(somewho)',
			'subject': get_one_header_main('Subject'),
			'delivery_date': get_one_header_main('Delivery-Date') or '(somewhen)',
			}
		subject_text = Ltxt_subj.format(**prms)
		message_text = ''.join(map(lambda x: x+'\n', textwrap.wrap(Ltxt_body.format(**prms), 79)))
		set_composer_subject(subject_text)
		set_composer_text(message_text)
		
		dn_part = MIMEBase('message', 'disposition-notification')
		dn_fields = ['Disposition: manual-action/MDN-sent-manually; displayed']
		finalrecipient = my_address
		dn_fields += ['Final-Recipient: RFC822;%s' % (finalrecipient)]
		if Email[HDR_OR]:
			origrcpt = get_one_header_main(HDR_OR)
			dn_fields += ['%s: RFC822;%s' % (HDR_OR, origrcpt)]
		if Email[HDR_MI]:
			messageid = get_one_header_main(HDR_MI)
			dn_fields += ['Original-Message-ID: %s' % (messageid)]
		dn_text = ''.join(map(lambda x: x+'\n', dn_fields))
		dn_part.set_payload(dn_text)
		NewEmail.attach(dn_part)
		Attachments.append(None, [dn_part, _("Disposition Notification"), 'mail-mark-read', None])
		
		on_after_save_draft()
		panel_edit_message.grab_focus()

def act_req_dispos_notif():
	if toggle_rqdn.get_active():
		clear_composer_headers(HDR_GDR)
		box_gdr = add_composer_header(HDR_GDR, 'Yes')
		box_gdr['readonly'] = True
		
		Froms = get_composer_headers('From', even_if_hidden=True)
		From = Froms[0]
		if From == '':
			From = '[' + _("missing email address") + ']'
		box_dnt = add_composer_header(HDR_DNT, From)
	else:
		clear_composer_headers(HDR_GDR)
		clear_composer_headers(HDR_DNT)

def turn_clicked_signal(ti, on):
	hid = ti.get_data('clicked-handler')
	if on:
		ti.handler_unblock(hid)
	else:
		ti.handler_block(hid)

def ninja_toggle(ti, on):
	turn_clicked_signal(ti, False)
	ti.set_active(on)
	turn_clicked_signal(ti, True)

def on_toggled(wdg):
	if wdg in [toggle_unimportant, toggle_important]:
		return on_toggled_importance(wdg)

def on_toggled_importance(wdg):
	if wdg.get_active():
		if wdg == toggle_important:
			toggle_unimportant.set_active(False)
		elif wdg == toggle_unimportant:
			toggle_important.set_active(False)
		return True
	return False

def act_importance():
	n = 1
	if toggle_important.get_active(): n = 2
	elif toggle_unimportant.get_active(): n = 0
	set_composer_headers('Importance', [] if n == 1 else [Importances[n]])
	set_composer_headers('Priority', [] if n == 1 else [Priorities[n]])

def act_edit_external():
	menubutton_send.set_sensitive(False)
	panel_edit_message.set_sensitive(False)
	menubutton_edit_external.set_sensitive(False)
	
	err = None
	fd, tmppath = mkstemp(prefix = PROGNAME + '-', suffix = '.txt')
	try:
		filehandler = os.fdopen(fd, 'w')
		filehandler.write(get_composer_text())
		set_xattrs(filehandler, {XATTR_CHARSET: 'UTF-8', XATTR_TYPE: 'text/plain'}, tmppath)
		filehandler.close()
	except IOError, e:
		err = e
	except OSError, e:
		e.filename = tmppath
		err = e
	if err is not None:
		display_error(e)
		os.unlink(tmppath)
		on_edit_external_done(None)
		return
	thread = ExecThreadRunner('mimeopen-gui', [tmppath], [cb_edit_external, tmppath])
	thread.start()

def cb_edit_external(status, filepath):
	if main_thread_alive():
		gtk.threads_enter()
		filehandler = None
		try:
			filehandler = open(filepath, 'r')
		except IOError, e:
			display_error(e)
			on_edit_external_done(None)
		else:
			on_edit_external_done(''.join(filehandler.readlines()))
			filehandler.close()
		try:
			os.unlink(filepath)
		except OSError, e:
			display_error(e)
		gtk.threads_leave()
	else:
		try:
			os.unlink(filepath)
		except OSError, e:
			sys.stderr.write(str(e) + '\n')

def on_edit_external_done(data):
	if data is not None:
		set_composer_text(data)
	menubutton_send.set_sensitive(True)
	panel_edit_message.set_sensitive(True)
	menubutton_edit_external.set_sensitive(True)

def set_unsaved(unsaved=True):
	win_comp.set_data('is-saved', not unsaved)
	win_comp.set_data('email-sent', False)
	s = menubutton_save_draft.get_label()
	endmark = '*'
	endmark_re = re.escape(endmark)
	if unsaved:
		s = re.sub('(%s)?$' % (endmark_re), endmark, s)
	else:
		s = re.sub(endmark_re + '$', '', s)
	menubutton_save_draft.set_label(s)

def on_edit_message(tb):
	if tb.get_modified():
		set_unsaved()



### Main ###

PROGNAME = 'gemlv'
VERSION = '0.1'
USERAGENT = PROGNAME + '/' + VERSION
gettext.textdomain(PROGNAME)
_ = gettext.gettext
PMU_MIME = '<i><span color=\'gray30\'>'
PMU_MIME_CLOSE = '</span></i>'
PMU_NAME = '<b>'
PMU_NAME_CLOSE = '</b>'
PMU_HEAD = '<b>'
PMU_HEAD_CLOSE = '</b>'
PMU_WARN = '<span foreground=\'darkred\' weight=\'bold\'>'
PMU_WARN_CLOSE = '</span>'
PMU_SUBJ = '<big>'
PMU_SUBJ_CLOSE = '</big>'
HDR_CD = 'Content-Disposition'
HDR_CTE = 'Content-Transfer-Encoding'
HDR_DNT = 'Disposition-Notification-To'
HDR_GDR = 'Generate-Delivery-Report'
HDR_PNDR = 'Prevent-NonDelivery-Report'
HDR_OR = 'Original-Recipient'
HDR_MI = 'Message-ID'
RE_EMAIL = '(?P<LP>[a-z][\w\.-]*(?<![\.-]))@(?P<DP>(?:(?!-)[a-z\d-]+(?<!-)\.?)+)'
VAL_EMAIL = {
	'require': '^' + RE_EMAIL + '$',
	}
VAL_ADDRESSES = {
	'repetative': r'^(?i)\s*(?:(?P<DQ>\x22|)(?P<N>(?<=\x22)(?:[^\x22\\\n]|\\[\x22\\])*|\w[\w\.-]*)(?P=DQ))?\s*(?(N)<|(?:(?P<LT><)|))' + RE_EMAIL + '(?(N)>|(?(LT)>))\s*(?:,\s*|$)',
	}
VAL_ADDRESS = {
	'require': VAL_ADDRESSES['repetative'] + '$',
	}
VAL_AGE = {
	'require': '^\d+[shmdwy]$',
	}
VAL_DATE = {
	'require': '^[a-zA-Z]+,\s*([12]\d|3[01]|0?[1-9])\s+[a-zA-Z]+\s+\d{4}\s+([01]\d|2[0-3])(:([0-5]\d)){2}\s+[+-]\d{4}$',
	}
Email = None
PartPrimary = None
PartSecondary = None
LastFolder = os.getcwd()
OriginatorHeaders = ['From', 'Sender', 'Return-Path', 'X-Sender', 'X-X-Sender', 'Reply-To']
SenderHeaders = ['From', 'Reply-To', 'Organization']
RecipientHeaders = ['To', 'Cc', 'Bcc']
DateTimeHeaders = ['Date', 'Reply-By', 'Expires', 'Deliver-At-Date']
PopularHeaders = ['Subject']
AdvancedHeaders = [
	'References', 'In-Reply-To', HDR_DNT,
	'Generate-Delivery-Report', 'Prevent-NonDelivery-Report',
	'Priority', 'Importance', 'Precedence',
	'Newsgroups', 'Followup-To', 'Thread-Topic',
	'Content-Language', 'Accept-Language',
	'Deliver-At-Age', 'Deliver-At-Date', 'Reply-By', 'Expires',
	'User-Agent', 'X-Mailer',
	]
Importances = ['low','normal','high']
Priorities = ['non-urgent','normal','urgent']
ValidatorHeaders = {
	'From': VAL_ADDRESS,
	'Reply-To': VAL_ADDRESS,
	HDR_DNT: VAL_ADDRESS,
	'To': VAL_ADDRESSES,
	'Cc': VAL_ADDRESSES,
	'Bcc': VAL_ADDRESSES,
	'Deliver-At-Age': VAL_AGE,
	'Priority': Priorities,
	'Importance': Importances,
	'Precedence': ['list', 'junk', 'bulk'],
}
for h in DateTimeHeaders:
	ValidatorHeaders[h] = VAL_DATE
XATTR_CHARSET = 'user.mime_encoding'
XATTR_TYPE = 'user.mime_type'
XATTR_MDNSENT = 'user.gemlv.mdn_sent'
XATTR_REPLIED = 'user.gemlv.replied'
XATTR_FORWARDED = 'user.gemlv.forwarded'
NewEmail = None
PREAMBLE = _("This is a MIME multipart Email.")


### Parse Arguments ###

argparser = argparse.ArgumentParser()
argparser.add_argument('--compose', action='store_true', help=_("Write a new Email"))
argparser.add_argument('--from', metavar='FROM', help=_("New Email's writer's name and address"))
argparser.add_argument('--to', metavar='ADDRESSES', help=_("New Email's Recipients, comma-separated list"))
argparser.add_argument('--cc', metavar='ADDRESSES', help=_("Carbon Copy Recipients, comma-separated list"))
argparser.add_argument('--bcc', metavar='ADDRESSES', help=_("Blind Carbon Copy Recipients, comma-separated list"))
argparser.add_argument('--subject', metavar='STRING', help=_("Subject"))
argparser.add_argument('--message', metavar='STRING', help=_("Message body"))
argparser.add_argument('--mailto', metavar='URL', help=_("Full 'mailto:' link"))
argparser.add_argument('--attach', metavar='FILES', help=_("Attachments, comma-separated list"))
argparser.add_argument('--localedir', metavar='DIR', help=_("L10n base directory"))
argparser.add_argument('FILE', nargs='?', help=_("Raw Email file for read or continue editing"))
cliArgs = argparser.parse_args()
for attr in 'to', 'cc', 'bcc', 'attach':
	if getattr(cliArgs, attr) is not None:
		setattr(cliArgs, attr, re.split('\s*,\s*', getattr(cliArgs, attr)))
if not cliArgs.compose and not cliArgs.FILE:
	sys.stderr.write(_("Either compose mode or FILE is needed.") + '\n')
	os._exit(1)
if cliArgs.localedir:
	gettext.bindtextdomain(PROGNAME, os.path.abspath(cliArgs.localedir))
if xattr is None:
	sys.stderr.write(_("Notice: no module xattr loaded") + '\n')
if hasattr(magic, 'open'):
	Magic = magic.open(magic.MAGIC_MIME_TYPE)
	Magic.load()
else:
	class magic0(object):
		def file(self, path):
			return magic.from_file(path, mime=True)
	Magic = magic0()
gtk.gdk.threads_init()


### Build GUI ###

win_main = gtk.Window()
win_main.set_default_size(800, 450)
start_evt = win_main.connect('map-event', win_main_show)
win_main.connect('delete-event', lambda a,b: act_quit())
add_key_binding(win_main, '<Control>q', lambda a,b,c,d: act_quit())
add_key_binding(win_main, '<Control>s', lambda a,b,c,d: act_save())
add_key_binding(win_main, '<Control>o', lambda a,b,c,d: act_open())
add_key_binding(win_main, '<Control>n', lambda a,b,c,d: act_compose())
add_key_binding(win_main, '<Control><Shift>r', lambda a,b,c,d: act_reply('one'))
add_key_binding(win_main, '<Control>r', lambda a,b,c,d: act_reply('all'))
add_key_binding(win_main, '<Control>f', lambda a,b,c,d: act_reply(''))
add_key_binding(win_main, '<Control>u', lambda a,b,c,d: act_view_source())
add_key_binding(win_main, '<Control>h', lambda a,b,c,d: show_view_headers(not panel_view_header.get_data('all-headers')))

box_main = gtk.VBox(False, 5)
toolbar = gtk.Toolbar()
spanel_view_header = gtk.ScrolledWindow()
panel_view = gtk.VPaned()
panel_view_upper = gtk.VBox()
panel_view_upper_2 = gtk.HBox()
panel_view_header = gtk.Label()
panel_view_avatar = gtk.VBox()
panel_view_subject = gtk.Label(' ')
panel_body = gtk.HPaned()
spanel_parts = gtk.ScrolledWindow()
Parts = gtk.TreeStore(gobject.TYPE_PYOBJECT, str, str, gtk.gdk.Pixbuf)
panel_parts = gtk.TreeView(Parts)
selection_parts = panel_parts.get_selection()
panel_right = gtk.VBox()
lbl_content_location = gtk.Label()
panel_btnbox = gtk.Frame()
panel_btnbox2 = gtk.VBox()
panel_btnbox3 = gtk.HBox()
lbl_right = gtk.Label()
btnbox_right = gtk.VBox(True, 10)
btn_open = StockButton(stock=gtk.STOCK_OPEN)
btn_save = StockButton(stock=gtk.STOCK_SAVE)
btn_save_struct = StockButton(label=_("Save to Structure"), stock=gtk.STOCK_SAVE)
panel_content_image = gtk.Frame()
spanel_content = gtk.ScrolledWindow()
panel_content = gtk.TextView()
tb_controls = gtk.Toolbar()
menubutton_filters = gtk.MenuToolButton(gtk.STOCK_ZOOM_FIT)
menu_filters = gtk.Menu()

win_main.add(box_main)
box_main.pack_start(toolbar, False, True)
box_main.pack_start(panel_view, True, True)
panel_view.pack1(panel_view_upper, False, True)
panel_view_upper.pack_start(panel_view_upper_2, True, True)
panel_view_upper_2.pack_start(spanel_view_header, True, True)
panel_view_upper_2.pack_start(panel_view_avatar, False, False)
panel_view_avatar.pack_start(gtk.Image(), False, False)
spanel_view_header.add_with_viewport(panel_view_header)
panel_view_upper.pack_start(panel_view_subject, False, True)
panel_view.pack2(panel_body, True, True)
panel_body.pack1(spanel_parts, True, True)
panel_body.pack2(panel_right, True, True)
spanel_parts.add_with_viewport(panel_parts)
panel_right.pack_start(lbl_content_location, False, True)
panel_right.pack_start(panel_btnbox, True, True)
panel_btnbox.add(panel_btnbox2)
panel_btnbox2.pack_start(panel_btnbox3, True, False)
panel_btnbox3.pack_start(lbl_right, True, False)
panel_btnbox3.pack_start(btnbox_right, True, False)
btnbox_right.pack_start(btn_open, False, False)
btnbox_right.pack_start(btn_save, False, False)
btnbox_right.pack_start(btn_save_struct, False, False)
panel_right.pack_start(panel_content_image, True, True)
panel_content_image.add(gtk.Image())
panel_right.pack_start(spanel_content, True, True)
spanel_content.add_with_viewport(panel_content)
panel_right.pack_start(tb_controls, False, True)

win_main.set_icon_name('emblem-mail')
win_main.set_geometry_hints(min_width=100, min_height=250)
toolbar.set_style(gtk.TOOLBAR_BOTH)
panel_view.set_position(124)
spanel_view_header.set_policy(gtk.POLICY_NEVER, gtk.POLICY_AUTOMATIC)
spanel_view_header.connect('size-allocate', resize_panel_view_header)
panel_view_header.set_line_wrap(True)
panel_view_header.set_padding(4, 2)
panel_view_header.set_alignment(0, 0)
panel_view_header.set_justify(gtk.JUSTIFY_LEFT)
panel_view_header.set_selectable(True)
panel_view_header.connect('populate-popup', populate_header_menu)
panel_view_avatar.children()[0].set_padding(6, 1)
panel_view_subject.set_selectable(True)
panel_view_subject.set_padding(5, 4)
panel_view_subject.set_alignment(0, 0)
panel_view_subject.set_justify(gtk.JUSTIFY_LEFT)
panel_body.set_position(175)
spanel_parts.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
spanel_content.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
panel_parts.set_headers_visible(False)
selection_parts.set_mode(gtk.SELECTION_MULTIPLE)
selection_parts.connect('changed', on_select_parts)
lbl_content_location.set_alignment(0, 0)
lbl_content_location.set_padding(2, 5)
lbl_right.set_alignment(0, 0)
lbl_right.set_justify(gtk.JUSTIFY_LEFT)
btn_open.connect('clicked', lambda wdg: act_open())
btn_save.connect('clicked', lambda wdg: act_save())
btn_save_struct.connect('clicked', lambda wdg: act_save_struct())
panel_content_image.connect('size-allocate', on_allocate_panel_content_image)
panel_content.set_editable(False)
panel_content.set_wrap_mode(gtk.WRAP_WORD)
tb_controls.set_icon_size(gtk.ICON_SIZE_MENU)
tb_controls.set_style(gtk.TOOLBAR_ICONS)
menubutton_filters.set_homogeneous(False)
menubutton_filters.set_menu(menu_filters)
menubutton_filters.set_arrow_tooltip_text(_("Filters"))


toolbuttons = [
	("Compose", gtk.STOCK_EDIT, None, act_compose, None),
	("Send MDN", 'mail-reply-sender', "Send a Message Disposition Notification", act_dispos_notif, None),
	("Reply", 'mail-reply-sender', "Reply\nRight click: Send a Message Disposition Notification", (act_reply, 'one'), act_dispos_notif),
	("Reply to All", 'mail-reply-all', None, (act_reply, 'all'), None),
	("Reply to List", 'mail-reply-all', None, (act_reply, 'list'), None),
	("Forward", 'mail-forward', None, (act_reply, ''), None),
	(None, None, None, 'separator', None),
	("Unsubscribe", 'stop', None, act_unsubscribe, None),
	("Report Spam", 'mail-mark-junk', None, act_report_spam, None),
	("Report Ham", 'mail-mark-notjunk', None, (act_report_spam, False), None),
	(None, None, None, 'space', None),
	(None, gtk.STOCK_QUIT, None, act_quit, None),
]
x, menubutton_mdn, x, x, menubutton_replytolist, x, x_, menubutton_unsubscribe, x, x, x_, x \
= load_toolitems(toolbar, toolbuttons)
l = menubutton_mdn.get_label()
menubutton_mdn.set_data('saved-label', l)
menubutton_mdn.set_markup(PMU_WARN + l + PMU_WARN_CLOSE)
setup_treeview__icon_label(panel_parts)

def ToolItemDeclaration_wrap(tv):
	return ("Wrap", gtk.STOCK_JUSTIFY_LEFT, "Soft / Hard / No Wrap\nRight click: No / Soft / Hard Wrap", (act_wrap, tv), (act_wrap, tv, -1))
def ToolItemDeclaration_font(tv):
	return (None, gtk.STOCK_SELECT_FONT, "Change Font\nRight click: monospace", (act_font, tv), (act_font_switch, tv))

toolbuttons = [
	(None, None, None, 'space', None),
	(None, gtk.STOCK_OPEN, None, act_open, None),
	(None, gtk.STOCK_SAVE, "Save\nRight click: Save to Structure", act_save, act_save_struct),
	(None, None, None, 'separator', None),
	("Unfilter", menubutton_filters, "Filter / Unfilter", act_view_source, None),
	ToolItemDeclaration_wrap(panel_content),
	ToolItemDeclaration_font(panel_content),
]
x_, btn_open2, btn_save2, x_, x, x, x \
= load_toolitems(tb_controls, toolbuttons)


### Build Composer GUI ###

win_comp = gtk.Window()
win_comp.set_default_size(*win_main.get_default_size())
win_comp.connect('delete-event', lambda a,b: act_close_edit())
add_key_binding(win_comp, '<Control>'+('q' if cliArgs.compose else 'w'), lambda a,b,c,d: act_close_edit())
add_key_binding(win_comp, '<Control>s', lambda a,b,c,d: act_save_edit())
add_key_binding(win_comp, '<Control><Shift>s', lambda a,b,c,d: act_save_edit(True))
add_key_binding(win_comp, 'F4', lambda a,b,c,d: act_edit_external())

box_compose = gtk.VBox()
tb_compose = gtk.Toolbar()
panel_compose = gtk.VPaned()
panel_upper = gtk.HPaned()
spanel_comp_header = gtk.ScrolledWindow()
menu_add_header = gtk.Menu()
panel_comp_header = gtk.VBox(False, 0)
UnionHeadersStore = gtk.ListStore(str)
spanel_attachments = gtk.ScrolledWindow()
Attachments = gtk.TreeStore(gobject.TYPE_PYOBJECT, str, str, gtk.gdk.Pixbuf)
panel_attachments = gtk.TreeView(Attachments)
panel_edit = gtk.VBox()
panel_subject = gtk.HBox(False, 5)
panel_subject.set_border_width(4)
entry_subject = gtk.Entry()
frame_edit = gtk.Frame()
spanel_edit_message = gtk.ScrolledWindow()
panel_edit_message = gtk.TextView()
tb_comp_controls = gtk.Toolbar()

win_comp.add(box_compose)
box_compose.pack_start(tb_compose, False, True)
box_compose.pack_start(panel_compose, True, True)
panel_compose.pack1(panel_upper, True, True)
panel_upper.pack1(spanel_comp_header, True, True)
spanel_comp_header.add_with_viewport(panel_comp_header)
panel_upper.pack2(spanel_attachments, False, True)
spanel_attachments.add_with_viewport(panel_attachments)
panel_attachments.set_headers_visible(False)
panel_compose.pack2(panel_edit, True, True)
panel_edit.pack_start(panel_subject, False, True)
panel_subject.pack_start(gtk.Label(_("Subject")), False, True)
panel_subject.pack_start(entry_subject, True, True)
panel_edit.pack_start(frame_edit, True, True)
frame_edit.add(spanel_edit_message)
spanel_edit_message.add(panel_edit_message)
box_compose.pack_start(tb_comp_controls, False, True)

win_comp.set_icon_name('mail-message-new')
win_comp.set_geometry_hints(min_width=120, min_height=200)
tb_compose.set_style(gtk.TOOLBAR_BOTH)
panel_upper.set_position(win_comp.get_default_size()[0]-150)
spanel_comp_header.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_ALWAYS)
spanel_comp_header.connect('button-press-event', open_comp_hdr_menu)
panel_comp_header.set_border_width(4)
spanel_attachments.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
panel_attachments.get_selection().set_mode(gtk.SELECTION_MULTIPLE)
panel_attachments.drag_dest_set(0, [], 0)
panel_attachments.connect('drag-motion', drop_attachment_motion)
panel_attachments.connect('drag-drop', drop_attachment_accept)
panel_attachments.connect('drag-data-received', drop_attachment)
panel_attachments.connect('focus-out-event', lambda w, e: w.get_selection().unselect_all())
panel_attachments.connect('key-press-event', on_keypress_attachments)
panel_compose.set_position(125)
entry_subject.connect('changed', on_edit_subject)
spanel_edit_message.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
panel_edit_message.get_buffer().connect('modified-changed', on_edit_message)
frame_edit.set_shadow_type(gtk.SHADOW_IN)
tb_comp_controls.set_icon_size(gtk.ICON_SIZE_MENU)
tb_comp_controls.set_style(gtk.TOOLBAR_ICONS)

for name in SenderHeaders:
	mi = gtk.CheckMenuItem(_("Specify %s") % (_(name)))
	mi.set_data('chname', name)
	mi.connect('toggled', act_comp_hdr_menuitem)
	menu_add_header.append(mi)
mi = StockMenuItem(stock_id=gtk.STOCK_ADD, label=_("Add Recipient"))
mi.connect('activate', act_comp_hdr_menuitem, 'To')
menu_add_header.append(mi)
menu_add_header.append(gtk.SeparatorMenuItem())
mi = StockMenuItem(stock_id=gtk.STOCK_ADD, label=_("Add Custom Header"))
mi.connect('activate', act_comp_hdr_menuitem, '')
menu_add_header.append(mi)
menuitem_all_comp_hdr = gtk.CheckMenuItem(_("Show Custom Headers"))
menuitem_all_comp_hdr.connect('toggled', act_all_comp_hdr)
menu_add_header.append(menuitem_all_comp_hdr)
menu_add_header.show_all()

toolbuttons = [
	("Send", 'mail-send', None, act_send, None),
	(None, gtk.STOCK_SAVE, "Save\nRight click: Save As...", act_save_edit, (act_save_edit, True)),
	("Addressbook", 'x-office-address-book', None, act_addressbook, None),
	("Attach File", 'mail-attachment', None, act_attach, None),
	(None, None, None, 'space', None),
	(None, gtk.STOCK_QUIT if cliArgs.compose else gtk.STOCK_CLOSE, None, act_close_edit, None),
]
menubutton_send, menubutton_save_draft, x, x, x_, x \
= load_toolitems(tb_compose, toolbuttons)
setup_treeview__icon_label(panel_attachments, label_edit_cb=rename_attachment)

for h in SenderHeaders + RecipientHeaders + PopularHeaders + AdvancedHeaders:
	UnionHeadersStore.append([h])

toolbuttons = [
	(None, None, None, 'space', None),
	(None, StockToggleToolButton('dialog-password'), "Encrypt", act_encrypt, None),
	(None, StockToggleToolButton('mail-signed'), "Crypto-Sign", act_sign, None),
	(None, StockToggleToolButton('mail-mark-read'), "Disposition Notification", act_req_dispos_notif, None),
	(None, None, None, 'separator', None),
	("Unimportant", StockToggleToolButton('emblem-generic'), "Unimportant", act_importance, None),
	("Important", StockToggleToolButton('emblem-important'), "Important", act_importance, None),
	(None, None, None, 'separator', None),
	(None, gtk.STOCK_EDIT, "Edit with External Program", act_edit_external, None),
	ToolItemDeclaration_wrap(panel_edit_message),
	ToolItemDeclaration_font(panel_edit_message),
]
x_, x, x, toggle_rqdn, x_, toggle_unimportant, toggle_important, x_, menubutton_edit_external, x, x \
= load_toolitems(tb_comp_controls, toolbuttons)
toggle_rqdn.connect('toggled', on_toggled)
toggle_unimportant.connect('toggled', on_toggled)
toggle_important.connect('toggled', on_toggled)


signal.signal(signal.SIGTERM, sighandler)
if cliArgs.compose:
	open_composer()
	add_composer_agent_headers()
	if cliArgs.FILE:
		# TODO load email
		win_comp.set_data('saved-to-file', cliArgs.FILE)
	if cliArgs.mailto:
		try:
			mailto = get_mailtos('<%s>' % (cliArgs.mailto))[0]
		except IndexError:
			sys.stderr.write(_("Can not parse mailto link.") + '\n')
		else:
			add_composer_mailto(mailto)
	if getattr(cliArgs, 'from'):
		set_composer_headers('From', [getattr(cliArgs, 'from')])
	if cliArgs.to:
		add_composer_headers('To', cliArgs.to)
	if cliArgs.cc:
		add_composer_headers('Cc', cliArgs.cc)
	if cliArgs.bcc:
		add_composer_headers('Bcc', cliArgs.bcc)
	if len(get_composer_headers(RecipientHeaders)) < 1:
		add_composer_header('To')
	if cliArgs.subject:
		set_composer_subject(cliArgs.subject)
	if cliArgs.message:
		set_composer_text(cliArgs.message)
	else:
		set_composer_text('\n\n' + get_user_signature())
	if cliArgs.attach:
		for path in cliArgs.attach:
			attach_path(path)
	on_after_save_draft()
	panel_edit_message.grab_focus()
else:
	win_main.show_all()
	menubutton_mdn.hide()
	menubutton_replytolist.hide()
	menubutton_unsubscribe.hide()
	panel_view_avatar.hide()
	lbl_content_location.hide()
	panel_btnbox.hide()
	panel_content_image.hide()

gtk.main()
if len(threading.enumerate()) > 1:
	sys.stderr.write(_("Waiting background threads to complete.") + '\n')
