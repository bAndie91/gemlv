#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os
import sys
import signal
import select
import fcntl
import gtk
import gobject
import glib
import pango
import gettext
import email
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email.mime.message import MIMEMessage
from email.header import make_header
import re
from tempfile import mkstemp
from mimetypes import guess_extension
import magic
from fnmatch import fnmatch
import argparse
try:
	import xattr
except ImportError:
	sys.stderr.write(_("Notice: no module xattr loaded") + '\n')
	xattr = None
import urlparse
import pwd
import threading
import time


### helper classes, functions ###

class StockToggleToolButton(gtk.ToggleToolButton):
	def __init__(self, stock=None):
		super(self.__class__, self).__init__(stock)
		if stock not in gtk.stock_list_ids():
			self.set_icon_name(stock)

class StockMenuItem(gtk.ImageMenuItem):
	def __init__(self, stock_id=None, accel_group=None, label=None):
		super(self.__class__, self).__init__(stock_id=stock_id, accel_group=accel_group)
		if label is not None:
			self.set_label(label)

class StockToolButton(gtk.ToolButton):
	def __init__(self, label=None, stock=None, tooltip=None):
		super(self.__class__, self).__init__()
		if stock is not None:
			if stock in gtk.stock_list_ids():
				if stock is not None: self.set_stock_id(stock)
			else:
				self.set_icon_name(stock)
		if label is not None:
			self.set_label(label)
		if tooltip is not None:
			self.set_tooltip_text(tooltip)
	def set_pixbuf(self, pxb):
		a = self.get_children()[0]
		a = a.get_children()[0]
		img, a = a.get_children()
		img.set_from_pixbuf(pxb)
		img.props.visible = True

class StockButton(gtk.Button):
	def __init__(self, label=None, stock=None, use_underline=True, icon_size=None):
		if stock is not None and stock in gtk.stock_list_ids():
			stock_tmp = stock
		else:
			stock_tmp = gtk.STOCK_ABOUT
		super(self.__class__, self).__init__(stock=stock_tmp, use_underline=use_underline)
		if label is not None:
			self.set_markup(label)
		if stock is None:
			self.set_icon('')
		elif stock not in gtk.stock_list_ids():
			self.set_icon(stock)
		if icon_size is not None:
			self.set_icon(stock, icon_size)
	def __get_children(self):
		align = self.get_children()[0]
		hbox = align.get_children()[0]
		return hbox.get_children()
	def set_label(self, label):
		x, lbl = self.__get_children()
		lbl.set_label(label)
	def set_markup(self, label):
		x, lbl = self.__get_children()
		lbl.set_markup(label)
	def set_icon(self, icon, size=gtk.ICON_SIZE_BUTTON):
		img, x = self.__get_children()
		if type(icon) == str:
			if icon == '':
				img.props.visible = False
			else:
				img.set_from_icon_name(icon, size)
				img.props.visible = True
		else:
			img.set_from_pixbuf(icon)
			img.props.visible = True

class cfgparser:
	def __init__(self, name, **kvargs):
		self.var = {'regex': '^\s*([^;#].*)', 'split': [1],}
		for k in 'regex', 'splitgroups':
			if not self.var.has_key(k): self.var[k] = None
			if kvargs.has_key(k): self.var[k] = kvargs[k]
		suff = '.conf'
		self.filehandlers = []
		for t in (os.environ['HOME'], '.config', PROGNAME, name + suff), (os.path.sep, 'etc', PROGNAME, name + suff), (name + suff,),:
			n = os.path.join(*t)
			try:
				fh = open(n, 'r')
				self.filehandlers.append(fh)
			except IOError:
				pass
	
	def __iter__(self):
		return self
	
	def next(self):
		if len(self.filehandlers) == 0:
			raise StopIteration
		else:
			fh = self.filehandlers[0]
			while True:
				ln = fh.readline()
				if ln == '':
					fh.close()
					self.filehandlers.reverse()
					self.filehandlers.pop()
					self.filehandlers.reverse()
					if len(self.filehandlers) == 0:
						raise StopIteration
					fh = self.filehandlers[0]
					continue
				m = re.match(self.var['regex'], ln)
				if m:
					grps = []
					n = 0
					for grp in m.groups():
						n += 1
						if n in self.var['splitgroups']:
							if grp is None:
								grp = []
							else:
								grp = re.split('\s+', grp)
						grps.append(grp)
					return grps
	
	def __del__(self):
		for fh in self.filehandlers:
			fh.close()

class pipereader:
	def __init__(self, inputstr, cmd, args=[], exitdict=None):
		self.exitdict = exitdict
		args = args[:]
		args.insert(0, os.path.basename(cmd))
		child_read, parent_write, parent_read, child_write = get_pipe_handlers(2)
		pid = os.fork()
		if pid == 0:
			parent_read.close()
			parent_write.close()
			os.dup2(child_read.fileno(), sys.stdin.fileno())
			os.dup2(child_write.fileno(), sys.stdout.fileno())
			os.closerange(3, 255)
			try:
				os.execvp(cmd, args)
			except OSError, e:
				sys.stderr.write(str(e))
			os._exit(127)
		else:
			child_read.close()
			child_write.close()
			parent_write.write(inputstr)
			parent_write.close()
			self.pid = pid
			self.reader = parent_read
	
	def __iter__(self):
		return self
	
	def next(self):
		s = self.reader.readline()
		if s == '':
			raise StopIteration
		else:
			return s
	
	def __del__(self):
		self.reader.close()
		status = WaitExecStatus(self.pid)
		if self.exitdict is not None:
			self.exitdict.update(status.__dict__)

class cyclelist(list):
	def __init__(self, lst, **kvargs):
		if type(lst) != type([]):
			raise TypeError('need list, %s found' % (str(type(lst))))
		if len(lst) < 1:
			raise ValueError('need non-empty list')
		super(self.__class__, self).__init__(lst)
		self.idx = 0
		if kvargs.has_key('at'):
			self.whirl(kvargs['at'])
	
	def whirl(self, val):
		for i in range(0, len(self)):
			if self[i] == val:
				self.idx = i
				return val
		return None
	
	def turn(self, n=1):
		self.idx = (self.idx + n) % len(self)
		return self[self.idx]
	
	def __getitem__(self, i):
		return super(self.__class__, self).__getitem__(i % len(self))

	def __setitem__(self, i, v):
		return super(self.__class__, self).__setitem__(i % len(self), v)
	
	def __str__(self):
		return str(self[self.idx])

def add_key_binding(widget, keyname, callback):
	accelgroup = gtk.AccelGroup()
	key, modifier = gtk.accelerator_parse(keyname)
	accelgroup.connect_group(key, modifier, gtk.ACCEL_VISIBLE, callback)
	widget.add_accel_group(accelgroup)

def get_current_window():
	for w in gtk.window_list_toplevels():
		if w.is_active():
			return w
	return None

def display_error(e):
	text = None
	if isinstance(e, OSError) or isinstance(e, IOError):
		text = '%s (#%d)\n%s' % (e.strerror, e.errno, e.filename)
	elif isinstance(e, Exception):
		text = e.message
	elif type(e) == type([]):
		text = ''.join(e)
	if text is None:
		text = str(e)
	dlg = gtk.MessageDialog(get_current_window(), gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_ERROR, gtk.BUTTONS_OK, text)
	dlg.set_title(_("Error"))
	dlg.run()
	dlg.destroy()

def question(msg, stock_yes=None):
	dlg = gtk.MessageDialog(get_current_window(), gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_QUESTION, gtk.BUTTONS_YES_NO, msg)
	dlg.set_title(_("Question"))
	if stock_yes is not None:
		dlg.get_widget_for_response(gtk.RESPONSE_YES).hide()
		btn_yes = StockButton(label=stock_yes[0], stock=stock_yes[1])
		dlg.add_action_widget(btn_yes, gtk.RESPONSE_YES)
		btn_yes.show()
	resp = dlg.run()
	dlg.destroy()
	return (resp == gtk.RESPONSE_YES)

def choose_dialog(action, filename=None):
	global LastFolder
	selected = None
	
	btn_accept_stock = gtk.STOCK_SAVE
	if action == gtk.FILE_CHOOSER_ACTION_OPEN:
		btn_accept_stock = gtk.STOCK_OPEN
	dlg = gtk.FileChooserDialog(parent=get_current_window(), action=action, buttons=(gtk.STOCK_CANCEL, gtk.RESPONSE_REJECT, btn_accept_stock, gtk.RESPONSE_ACCEPT))
	if LastFolder is not None: dlg.set_current_folder(LastFolder)
	if filename is not None: dlg.set_current_name(filename)
	btn_cwd = StockButton(label=_("Working Dir"), stock=gtk.STOCK_JUMP_TO)
	dlg.add_action_widget(btn_cwd, gtk.RESPONSE_NO)
	btn_cwd.show()
	while True:
		resp = dlg.run()
		if resp == gtk.RESPONSE_ACCEPT:
			selected = dlg.get_filename()
			break
		elif resp == gtk.RESPONSE_NO:
			dlg.set_current_folder(os.getcwd())
		else:
			break
	LastFolder = dlg.get_current_folder()
	dlg.destroy()
	return selected

def choose_save_file(filename=None):
	return choose_dialog(gtk.FILE_CHOOSER_ACTION_SAVE, filename)

def choose_save_folder():
	return choose_dialog(gtk.FILE_CHOOSER_ACTION_SELECT_FOLDER)

def choose_open_file():
	return choose_dialog(gtk.FILE_CHOOSER_ACTION_OPEN)

def get_pipe_handlers(npairs):
	pipes = []
	for n in range(0, npairs):
		r, w = os.pipe()
		pipes.append(os.fdopen(r, 'r'))
		pipes.append(os.fdopen(w, 'w'))
	return pipes

def which(cmd):
	def is_executable(p):
		return (os.path.isfile(p) and os.access(p, os.X_OK))
	
	ap, bn = os.path.split(cmd)
	if ap:
		if is_executable(cmd):
			return cmd
	else:
		for d in os.environ['PATH'].split(os.path.pathsep):
			p = os.path.join(d, cmd)
			if is_executable(p):
				return p
	return None

def mkdir(path):
	if os.path.exists(path) or path == '':
		return
	else:
		mkdir(os.path.dirname(path))
		os.mkdir(path)

def run_async(cmd, args, postrun):
	args = args[:]
	args.insert(0, os.path.basename(cmd))
	pid1 = os.fork()
	if pid1 == 0:
		os.closerange(0, 255)
		pid2 = os.fork()
		if pid2 == 0:
			pid3 = os.fork()
			if pid3 == 0:
				os.execvp(cmd, args)
				os._exit(127)
			else:
				status = WaitExecStatus(pid3)
				postrun[0](*postrun[1:])
				os._exit(status.code)
		else:
			os._exit(0)
	else:
		os.waitpid(pid1, 0)

class WaitExecStatus:
	def __init__(self, pid):
		x, status = os.waitpid(pid, 0)
		self.status = status >> 8
		self.code = self.status
		self.signal = status & 0x7F
		self.coredumped = status & 0x80 >> 7
	def __repr__(self):
		return 'status %s, signal %s%s' % (self.status, self.signal, ', core dumped' if self.coredumped else '')

class ExecThreadRunner(threading.Thread):
	def __init__(self, syscmd, sysargs, cb=None):
		assert isinstance(syscmd, str)
		assert isinstance(sysargs, list)
		assert isinstance(cb, list)
		assert len(cb) > 0
		super(self.__class__, self).__init__(target=self.execve, args=[syscmd, sysargs])
		self.callback = cb
	
	def execve(self, cmd, args):
		pid = os.fork()
		if pid == 0:
			os.closerange(0, 255)
			try:
				os.execvp(cmd, [cmd] + args)
			except OSError, e:
				sys.stderr.write(str(e))
			os._exit(127)
		else:
			return WaitExecStatus(pid)
	
	def run(self):
		result = self._Thread__target(*self._Thread__args, **self._Thread__kwargs)
		if self.callback is not None:
			self.callback[0](result, *self.callback[1:])

### private functions ###

def win_main_show(widget, event):
	win_main.disconnect(start_evt)
	panel_content.set_data('saved-font', get_current_font(panel_content))
	if args.FILE:
		load_file(args.FILE)

def load_file(filename):
	global Email
	global LeafParts
	try:
		fh = open(filename, 'r')
	except IOError, e:
		display_error(e)
		act_quit()
		return
	Email = email.message_from_file(fh)
	fh.close()
	
	if get_listaddress_main() is not None:
		menubutton_replytolist.show()
	if (Email['List-Unsubscribe'] or '').strip():
		menubutton_unsubscribe.show()
	
	panel_view_header.set_markup(get_headers_markup(Email))
	panel_view_subject.set_markup(PMU_SUBJ + glib.markup_escape_text(re.sub('\n', '', get_one_header_main('Subject', ''))) + PMU_SUBJ_CLOSE)
	clear_parts(Parts)
	load_parts(Email, Parts, Parts.get_iter_root())
	panel_parts.expand_all()
	if Email.is_multipart():
		if PartPrimary is not None:
			selection_parts.select_iter(PartPrimary)
		elif PartSecondary is not None:
			selection_parts.select_iter(PartSecondary)
		else:
			selection_parts.select_path((0,))
	else:
		selection_parts.select_path((0,))

	if LeafParts > 1:
		pos = panel_body.get_data('saved-position')
		if pos is not None:
			panel_body.set_position(pos)
			panel_body.set_data('saved-position', None)
	else:
		panel_body.set_data('saved-position', panel_body.get_position())
		panel_body.set_position(0)

def clear_parts(model):
	global LeafParts
	LeafParts = 0
	model.clear()

def load_parts(eml, model, parent):
	global PartPrimary
	global PartSecondary
	global LeafParts
	
	label = PMU_MIME + glib.markup_escape_text(eml.get_content_type()) + PMU_MIME_CLOSE
	filename = eml.get_filename()
	if filename is not None: label = glib.markup_escape_text(filename) + ' ' + label
	stock = get_stock_by_mime(eml.get_content_maintype(), eml.get_content_subtype())
	pixb = None
	
	iterator = model.append(parent, [eml, label, stock, pixb])
	if PartPrimary is None and eml.get_content_type() == 'text/plain':
		PartPrimary = iterator
	if PartSecondary is None and eml.get_content_type() == 'text/html':
		PartSecondary = iterator
	if type(eml.get_payload()) == type([]):
		for part in eml.get_payload():
			load_parts(part, model, iterator)
	else:
		LeafParts += 1

def clear_content(s=''):
	bufr = panel_content.get_buffer()
	bufr.set_text(s)
	panel_content.set_sensitive(False)
	return bufr

def decode_readably(s, eml):
	charset = eml.get_content_charset()
	if charset is None: charset = 'utf-8'
	return s.decode(charset, 'replace')

def get_content_readably(eml):
	return decode_readably(get_content_any(eml), eml)

def get_content_any(eml):
	s = eml.get_payload(decode=1)
	if s is None: s = eml.as_string()
	return s

def set_content_text(s):
	bufr = panel_content.get_buffer()
	bufr.set_text(s)
	if s != '' and bufr.get_text(bufr.get_start_iter(), bufr.get_end_iter(), True) == '':
		return False
	panel_content.set_sensitive(True)
	return True

def load_part(eml, filt=None):
	if eml is None: return
	clear_content(_("Loading failed"))
	panel_content.set_data('view-unfiltered', False)
	ct_main, ct_sub = eml.get_content_maintype(), eml.get_content_subtype()

	if filt is None:
		filt = get_filter_by_mime(ct_main, ct_sub)
	
	if filt is None:
		if type(eml.get_payload()) == type([]) and (eml.preamble is not None or eml.epilogue is not None):
			set_content_text(decode_readably('\n'.join([eml.preamble or '', eml.epilogue or '']), eml))
		else:
			if ct_main == 'image':
				loader = gtk.gdk.PixbufLoader()
				loader.write(eml.get_payload(decode=1))
				loader.close()
				pxb = loader.get_pixbuf()
				panel_content_image.set_data('last-alloc', None)
				panel_content_image.set_data('pixbuf', pxb)
				panel_content_image.show()
			else:
				label = _("Content type: %s%s%s") % (PMU_MIME, glib.markup_escape_text(eml.get_content_type()), PMU_MIME_CLOSE)
				filename = eml.get_filename()
				if filename is not None: label = (_("Filename: %s%s%s") % (PMU_NAME, glib.markup_escape_text(filename), PMU_NAME_CLOSE)) + '\n' + label
				lbl_right.set_markup(label)
				
				panel_btnbox.show()
				btn_open.show()
				btn_save.set_label(gtk.stock_lookup(gtk.STOCK_SAVE)[1])
			spanel_content.hide()
	else:
		cmd, args, binary = filt[:]
		if binary:
			content = get_content_any(eml)
		else:
			content = get_content_readably(eml)
		if cmd == '':
			panel_content.set_data('view-unfiltered', True)
			set_content_text(content) or clear_content(_("Loading failed"))
		else:
			bufr = panel_content.get_buffer()
			bufr.set_text('')
			for s in pipereader(content, cmd, args):
				bufr.insert(bufr.get_end_iter(), s)
			panel_content.set_sensitive(True)
		panel_btnbox.hide()
		panel_content_image.hide()
		spanel_content.show()

def on_allocate_panel_content_image(wdg, alloc):
	pxb = wdg.get_data('pixbuf')
	if pxb is not None:
		lastalloc = wdg.get_data('last-alloc')
		if lastalloc is None or alloc.width != lastalloc.width or alloc.height != lastalloc.height:
			wdg.set_data('last-alloc', alloc)
			B = wdg.get_border_width()
			W, H = alloc.width - B, alloc.height - B
			w0, h0 = pxb.get_width(), pxb.get_height()
			w = w0
			h = h0
			if W < w:
				w = W
				h = h0 * w / w0
			if H < h:
				h = H
				w = w0 * h / h0
			b = 5+B*2
			pxb = pxb.scale_simple(w - b, h - b, gtk.gdk.INTERP_BILINEAR)
			wdg.children()[0].set_from_pixbuf(pxb)

def resize_panel_view_header(wdg, rect=None):
	if not panel_view_header.get_data('all-headers'):
		if rect is None: rect = wdg.get_allocation()
		h, v = panel_view_header.get_padding()
		panel_view_header.set_size_request(rect.width - h - 4, -1)

def decode_header(s, unfold=False):
	chunks = []
	for chars, encoding in email.Header.decode_header(s):
		if encoding is None:
			if unfold:
				chars = re.sub('\r?\n\s*', ' ', chars)
			encoding = 'utf-8'
		chunks.append(chars.decode(encoding, 'replace'))
	return ' '.join(chunks)

def get_one_header_main(hname, dflt=None, unfold=True):
	hval = Email[hname]
	if hval is None:
		return dflt
	return decode_header(hval, unfold=unfold)

def get_all_headers_main(hname):
	return map(decode_header, Email.get_all(hname) or [])

def get_mailtos(s, schemata=['mailto']):
	l = []
	uris = re.findall('<([^>]+)>', s)
	if len(uris) == 0:
		# For poorly behaved mail lists.
		uris = re.findall('^\s*(\S+)', s)
	for uri in uris:
		rslt = urlparse.urlsplit(uri)
		if '*' in schemata or rslt.scheme.lower() in schemata:
			q = dict((k.lower(), v if len(v)>1 else v[0]) for k, v in urlparse.parse_qs(rslt.query).iteritems())
			q['to'] = urlparse.unquote(rslt.path)
			q['uri'] = uri
			q['split'] = rslt
			l.append(q)
	return l

def get_listaddress_main():
	try:
		# Hopefully there is only one list address.
		listaddress = get_mailtos(','.join(get_all_headers_main('List-Post') or []))[0]['to']
	except IndexError:
		listaddress = None
	except KeyError:
		listaddress = None
	return listaddress

def get_headers_markup(eml):
	lns = []
	hdrs = [
		"X-X-Sender",
		"X-Sender",
		"Sender",
		"From",
		"Organization",
		"Reply-To",
		"Importance",
		"To",
		"Cc",
		"Date",
		"Reply-By",
		"Expires",
	]
	originator_headers = ['X-X-Sender', 'X-Sender', 'Sender', 'From', 'Reply-To']
	from_addresses = map(lambda x: x[1], email.utils.getaddresses(eml.get_all('From') or []))
	if len(filter(lambda h: eml[h] is not None, originator_headers)) == 0:
		hdrs = ['Return-Path'] + hdrs
	
	for hname in hdrs:
		hvals_mu = []
		for hval in eml.get_all(hname) or []:
			hval = decode_header(hval)
			if hname != 'From' and hname in originator_headers:
				# do not display Sender or Reply-To fields if they equal to From
				addr = email.utils.parseaddr(hval)[1]
				if addr in from_addresses: continue
			if hname in RecipientHeaders or hname in originator_headers:
				list_mu = []
				for realname, addr in email.utils.getaddresses([hval]):
					realname = decode_header(realname)
					addr_mu = glib.markup_escape_text(addr)
					mu = '<a href=\'mailto:%s\'>%s</a>' % (addr_mu, addr_mu)
					if realname: mu = realname + ' ' + mu
					list_mu.append(mu)
				hval_mu = ', '.join(list_mu)
			elif hname in DateTimeHeaders:
				# display Date field in local timezone
				try:
					timestamp = email.utils.mktime_tz(email.utils.parsedate_tz(hval))
				except TypeError:
					timestamp = None
				else:
					hval = email.utils.formatdate(timestamp, True)
				hval_mu = glib.markup_escape_text(hval)
				if timestamp is not None and timestamp < time.time():
					if hname == 'Reply-By':
						wrn = _("Overdue")
					elif hname == 'Expires':
						wrn = _("(Expired)")
					try: hval_mu += ' ' + PMU_WARN + wrn + PMU_WARN_CLOSE
					except NameError: pass
			else:
				hval_mu = glib.markup_escape_text(hval)
			if len(hval_mu):
				hvals_mu.append(hval_mu)
		if len(hvals_mu):
			lns.append(PMU_HEAD + _(hname) + PMU_HEAD_CLOSE + ': ' + ', '.join(hvals_mu))
	return '\n'.join(lns)

def get_filters_by_mime(main, sub, all=True):
	filters = []
	for m, s, marks, cmd, args in cfgparser('filters', regex='^\s*([^;#][^\s/]*)/(\S+)\s+([!\$]*)(\S+)\s*(.+)?', splitgroups=[5]):
		if fnmatch(main, m) and fnmatch(sub, s):
			isbin = marks.find('!')>-1
			isshell = marks.find('$')>-1
			e = None
			if cmd == '-':
				e = ('', None, isbin)
			else:
				if isshell:
					e = ('sh', ['-c', ' '.join([cmd]+args)], isbin)
				else:
					if which(cmd):
						e = (cmd, args, isbin)
			if e is not None:
				if all:
					filters.append(e)
				else:
					return e
	if all:
		return filters
	return None

def get_filter_by_mime(main, sub):
	return get_filters_by_mime(main, sub, all=False)

def get_stock_by_mime(main, sub):
	assoc_main = {
		'multipart': gtk.STOCK_DIRECTORY,
		'message': 'emblem-mail',
	}
	assoc_full = {
		'application/pgp-signature': 'mail-signed',
		'application/ics': 'x-office-calendar',
		'text/calendar': 'x-office-calendar',
		'inode/directory': gtk.STOCK_DIRECTORY,
		'inode/x-empty': 'document-new',
	}
	full = main + '/' + sub
	
	if full == 'multipart/digest':
		return 'emblem-mail'
	if assoc_full.has_key(full):
		return assoc_full[full]
	elif assoc_main.has_key(main):
		return assoc_main[main]
	
	if full in ['text/html']:
		return main + '-' + sub
	elif main in ['audio', 'image', 'font', 'package', 'text', 'video']:
		return main + '-x-generic'

	return gtk.STOCK_FILE

def sighandler(sign, frame):
	if sign == signal.SIGTERM:
		glib.idle_add(sig_term, priority=glib.PRIORITY_HIGH)

def sig_term():
	act_quit()
	return False

def act_quit():
	if win_comp.get_visible():
		act_close_edit()
	if win_comp.get_visible():
		return True
	gtk.main_quit()
	return False

def act_close_edit():
	if not win_comp.get_data('email-sent') and not win_comp.get_data('is-saved'):
		if not question(_("Message is not saved.\nClose anyway?"), (None, gtk.STOCK_QUIT if args.compose else gtk.STOCK_CLOSE)):
			return True
	if args.compose:
		gtk.main_quit()
		return False
	else:
		win_comp.hide()
		return True

def act_button(func):
	if type(func) != type(()):
		func = (func,)
	if func[0] is not None:
		func[0](*func[1:])

def on_click_button(btn, func):
	act_button(func)
	return False

def on_press_button(btn, evt, func):
	if evt.type == gtk.gdk.BUTTON_PRESS:
		if evt.button == 3 or (evt.button == 1 and evt.state & gtk.gdk.SHIFT_MASK):
			act_button(func)
	return False

def open_comp_hdr_menu(widget, event):
	if event.button == 3 or (event.button == 1 and event.state & gtk.gdk.SHIFT_MASK):
		menu_add_header.popup(None, None, None, event.button, event.time)
		return True

def act_comp_hdr_menuitem(mi, hname=None):
	if hname is None:
		hname = mi.get_data('chname')
	if hname == '':
		menuitem_all_comp_hdr.set_active(True)
	on = mi.active if isinstance(mi, gtk.CheckMenuItem) else None
	box = add_composer_header__direct(hname)
	if on == False:
		box.cancel()
	return True

def act_all_comp_hdr(mi):
	show_advanced_comp_hdr(mi.active)

def show_advanced_comp_hdr(show=True):
	for n in range(0, len(panel_comp_header.children())):
		box = panel_comp_header.children()[n]
		if box.hntype == compose_header_box.HNTYPE_CUSTOM:
			if show: box.show()
			else: box.hide()

def add_composer_header__direct(hname, hval=None):
	box = None
	for thisbox in panel_comp_header.children():
		if thisbox.hntype == compose_header_box.HNTYPE_LABEL and thisbox['name'] == hname:
			box = thisbox
			if hval is not None: box['value'] = hval
			break
	if box is None:
		if hval is None: hval = ''
		box = compose_header_box(hname, hval)
		panel_comp_header.pack_start(box, False, True)
		if box.hntype == compose_header_box.HNTYPE_MENU:
			for n in range(0, len(panel_comp_header.children())):
				if panel_comp_header.children()[n].hntype == compose_header_box.HNTYPE_CUSTOM:
					panel_comp_header.reorder_child(box, n)
					break
				n += 1
	box.focus()
	box.show_all()
	return box

def add_composer_header(hname, hval=None):
	box = add_composer_header__direct(hname, hval)
	box.tick_my_menuitem(1)
	return box

def add_composer_headers(hname, hvals):
	for hval in hvals:
		box = add_composer_header__direct(hname, hval)
		box.tick_my_menuitem(1)

def set_composer_headers(hname, hvals):
	clear_composer_headers(hname)
	for hval in hvals:
		add_composer_header(hname, hval)

def clear_composer_headers(hname):
	for box in panel_comp_header.children():
		if hname is None or box['name'] == hname:
			box.cancel(manual=False)

class compose_header_box(gtk.HBox):
	HNTYPE_LABEL, HNTYPE_MENU, HNTYPE_CUSTOM = range(3)
	
	def __init__(self, chname, val, hntype=None):
		assert isinstance(chname, str)
		assert isinstance(val, str) or isinstance(val, unicode)
		plus = True
		minus = True
		
		super(self.__class__, self).__init__(False, 2)
		if hntype is None:
			if chname is None or chname == '' or chname in AdvancedHeaders:
				hntype = self.HNTYPE_CUSTOM
			elif chname in RecipientHeaders:
				hntype = self.HNTYPE_MENU
			else:
				hntype = self.HNTYPE_LABEL
		self.hntype = hntype
		if self.hntype == self.HNTYPE_CUSTOM:
			self.wdg_name = gtk.combo_box_entry_new_with_model(UnionHeadersStore, 0)
			self.wdg_name.connect('changed', set_unsaved)
		elif self.hntype == self.HNTYPE_MENU:
			self.wdg_name = gtk.Button()
			self.wdg_name.set_relief(gtk.RELIEF_NONE)
			self.wdg_name.connect('button-release-event', self.popup_rcpt_menu)
		elif self.hntype == self.HNTYPE_LABEL:
			plus = False
			self.wdg_name = gtk.Label()
		self.pack_start(self.wdg_name, False, True)
		
		self.wdg_value = gtk.Entry()
		self.wdg_value.connect('changed', set_unsaved)
		self.pack_start(self.wdg_value, True, True)
		#TODO wdg_value.set_completion()
		
		if plus:
			self.wdg_add = StockButton('', gtk.STOCK_ADD, icon_size=gtk.ICON_SIZE_MENU)
			self.pack_start(self.wdg_add, False, False)
			self.wdg_add.set_relief(gtk.RELIEF_NONE)
			self.wdg_add.connect('clicked', self.duplicate)
		if minus:
			self.wdg_del = StockButton('', gtk.STOCK_REMOVE, icon_size=gtk.ICON_SIZE_MENU)
			self.wdg_del.set_relief(gtk.RELIEF_NONE)
			self.pack_start(self.wdg_del, False, False)
			self.wdg_del.connect('clicked', self.cancel)
		
		if chname == 'Importance':
			turn_importance_signal(False)
			toggle_unimportant.set_active(val.lower().find('low')>-1)
			toggle_important.set_active(val.lower().find('high')>-1)
			turn_importance_signal(True)
		
		self['name'] = chname
		self['value'] = val
	
	def popup_rcpt_menu(self, wdg, evt):
		wdg.set_relief(gtk.RELIEF_NORMAL)
		mnu = gtk.Menu()
		mnu.connect('deactivate', self.popup_rcpt_menu_disappear, wdg)
		for chname in RecipientHeaders:
			mi = gtk.MenuItem(label=_(chname))
			mi.set_data('name', chname)
			mi.connect('activate', self.popup_rcpt_menuitem_activated, wdg)
			mnu.append(mi)
		mnu.show_all()
		mnu.popup(None, None, self.bottomleft, evt.button, evt.time, wdg)
	
	def popup_rcpt_menuitem_activated(self, mi, wdg):
		self['name'] = mi.get_data('name')
		self.popup_rcpt_menu_disappear(mi.parent, wdg)
		set_unsaved()
	
	def popup_rcpt_menu_disappear(self, mnu, wdg):
		wdg.set_relief(gtk.RELIEF_NONE)
		self.focus()
	
	def bottomleft(self, mnu, wdg):
		X, Y = self.window.get_origin()
		x, y, w, h = wdg.get_allocation()
		mx = X + x
		my = Y + y + h
		return (mx, my, True)
	
	def show_all(self):
		super(self.__class__, self).show_all()
		if self.hntype == self.HNTYPE_CUSTOM and not menuitem_all_comp_hdr.get_active():
			self.hide()
	
	def duplicate(self, evtwdg=None):
		newbox = self.__class__(self['name'], self['value'], hntype=self.hntype)
		self.parent.pack_start(newbox, False, True)
		newbox.show_all()
		newbox.focus()
		for n in range(0, len(self.parent.children())):
			if self.parent.children()[n] == self:
				self.parent.reorder_child(newbox, n)
	
	def cancel(self, evtwdg=None, manual=True):
		if self['value']:
			set_unsaved()
		if self.hntype == self.HNTYPE_LABEL:
			self.hide()
			self.tick_my_menuitem(0)
			if not manual:
				self['value'] = ''
		else:
			if manual and self.hntype == self.HNTYPE_MENU:
				n = 0
				for x in self.parent.children():
					if x.hntype == self.HNTYPE_MENU: n += 1
					if n > 1: break
				if n < 2: return False
			if self['name'] == 'Importance':
				turn_importance_signal(False)
				if self['value'].lower().find('low')>-1:
					toggle_unimportant.set_active(False)
				if self['value'].lower().find('high')>-1: 
					toggle_important.set_active(False)
				turn_importance_signal(True)
			self.parent.remove(self)
	
	def tick_my_menuitem(self, on):
		for mi in menu_add_header.children():
			if mi.get_data('chname') == self['name']:
				mi.set_active(on)
				break
	
	def focus(self):
		self.wdg_value.grab_focus()
		self.wdg_value.set_position(-1)
	
	def __getitem__(self, key):
		if key == 'name':
			if self.hntype == self.HNTYPE_CUSTOM:
				it = self.wdg_name.get_active_iter()
				if it is not None:
					return self.wdg_name.get_model().get_value(it, 0)
				else:
					return self.wdg_name.children()[0].get_text()
			else:
				return self.wdg_name.get_data('name')
		elif key == 'value':
			return self.wdg_value.get_text()
		else:
			raise IndexError()

	def __setitem__(self, key, newvalue):
		if key == 'name':
			self.wdg_name.set_data('name', newvalue)
			if self.hntype == self.HNTYPE_CUSTOM:
				self.wdg_name.children()[0].set_text(newvalue)
			else:
				self.wdg_name.set_data('name', newvalue)
				self.wdg_name.set_label(_(newvalue))
		elif key == 'value':
			self.wdg_value.set_text(newvalue)
			if newvalue:
				set_unsaved()
		else:
			raise IndexError()


def get_composer_headers(hname):
	hlist = []
	for hbox in panel_comp_header.children():
		if hbox.get_visible():
			if hname is None:
				hlist.append((hbox['name'], hbox['value']))
			elif type(hname) == type([]) and hbox['name'] in hname:
				hlist.append(hbox['value'])
			elif hbox['name'] == hname:
				hlist.append(hbox['value'])
	return hlist

def set_composer_subject(s):
	entry_subject.set_text(s)

def get_composer_subject():
	return entry_subject.get_text()

def on_edit_subject(wdg):
	set_unsaved()

def set_composer_text(s):
	bufr = panel_edit_message.get_buffer()
	bufr.set_text(s)
	bufr.place_cursor(bufr.get_start_iter())

def get_composer_text():
	bufr = panel_edit_message.get_buffer()
	return bufr.get_text(bufr.get_start_iter(), bufr.get_end_iter(), True)

def open_composer():
	if win_comp.get_visible():
		act_close_edit()
	if win_comp.get_visible():
		win_comp.set_urgency_hint(True)
		win_comp.present()
		win_comp.set_urgency_hint(False)
		return False
	
	global NewEmail
	NewEmail = MIMEMultipart('mixed')
	win_comp.set_data('preserve-headers', map(lambda x: x[0], NewEmail._headers))
	NewEmail.preamble = PREAMBLE
	part0 = MIMEText('')
	part0.set_charset('UTF-8')
	part0.replace_header(HDR_CTE, '')
	NewEmail.attach(part0)
	Attachments.clear()
	
	win_comp.show_all()
	menuitem_all_comp_hdr.set_active(False)
	clear_composer_headers(None)
	add_composer_from_hidden()
	for h in SenderHeaders: add_composer_header(h).cancel()
	set_composer_subject('')
	set_composer_text('')

	win_comp.set_data('saved-to-file', None)
	on_after_save_draft()
	return True

def quote_message_plain():
	if PartPrimary is not None:
		return re.sub('(^|\n)(.)', '\\1> \\2', get_content_readably(Parts[PartPrimary][0]))
	return '>'

def get_gecos_name():
	return re.sub(',.*,.*,.*', '', pwd.getpwuid(os.getuid()).pw_gecos)

def get_user_signature():
	try:
		sign = ''.join(open(os.path.join(os.environ['HOME'], '.signature'), 'r').readlines())
		sign = re.sub('\n?$', '\n', sign)
	except:
		sign = '--\n' + get_gecos_name() + '\n'
	return sign

def filter_out_addresses(noaddrs, hvals):
	filtered = []
	for realname, addr in email.utils.getaddresses(hvals):
		if addr not in noaddrs:
			filtered.append(email.utils.formataddr((realname, addr)))
	return filtered

def add_composer_agent_headers():
	add_composer_header('User-Agent', USERAGENT)
	add_composer_header('X-Mailer', USERAGENT)

def add_composer_mailto(mailto):
	for h in 'To', 'Cc', 'Bcc':
		k = h.lower()
		if mailto.has_key(k):
			add_composer_headers(h, mailto[k] if hasattr(mailto[k], '__iter__') else [mailto[k]])
	if mailto.has_key('subject'):
		set_composer_subject(mailto['subject'])
	if mailto.has_key('body'):
		set_composer_text(mailto['body'])

def guess_my_address():
	return get_one_header_main('Envelope-To') or get_one_header_main('Delivered-To')

def add_composer_from_hidden():
	addr = guess_my_address()
	if addr is not None:
		name = get_gecos_name()
		box = add_composer_header('From', email.utils.formataddr((name, addr)))
		box.cancel()
		return True
	return False

def act_compose():
	if open_composer():
		add_composer_agent_headers()
		add_composer_header('To', '')
		set_composer_subject('')
		set_composer_text('\n\n' + get_user_signature())
		on_after_save_draft()
		panel_edit_message.grab_focus()

def act_reply(recip):
	if open_composer():
		add_composer_agent_headers()
		subj = get_one_header_main('Subject', '')
		body = '\n\n' + get_user_signature()
		my_address = guess_my_address()

		if recip == '':
			fwdname = (subj or _("Email")) + '.eml'
			pre = _("Fwd: ")
			if not subj.lower().startswith(pre.lower()): subj = pre + subj
			set_composer_subject(subj)
			add_composer_header('To', '')
			references = get_one_header_main('References')
			if references is not None:
				add_composer_header('References', references)
			
			part = MIMEMessage(Email)
			part.add_header(HDR_CD, 'attachment', filename=fwdname)
			NewEmail.attach(part)
			Attachments.append(None, [part, fwdname, 'emblem-mail', None])
		else:
			add_composer_header('Thread-Topic', get_one_header_main('Thread-Topic', subj))
			pre = _("Re: ")
			if not subj.lower().startswith(pre.lower()): subj = pre + subj
			set_composer_subject(subj)
			body += '\n' + _("Quote:") + '\n\n' + quote_message_plain()

			messageid = get_one_header_main('Message-ID')
			references = get_one_header_main('References')
			if messageid is not None:
				add_composer_header('In-Reply-To', messageid)
				if references is not None:
					references = references + ' ' + messageid
				else:
					references = messageid
			if references is not None:
				add_composer_header('References', references)
			
			reply_fulladdress = None
			reply_address = None
			for h in ['Reply-To', 'From', 'Sender', 'X-Sender', 'X-X-Sender']:
				if Email[h] is not None:
					reply_fulladdress = get_one_header_main(h)
					reply_address = email.utils.parseaddr(reply_fulladdress)[1]
					break
			listaddress = get_listaddress_main()
			
			if recip == 'one':
				add_composer_header('To', reply_fulladdress or '')
			elif recip == 'all':
				cc_addresses = map(lambda x: x[1], email.utils.getaddresses(get_all_headers_main('Cc')))
				skip_addresses = [my_address, reply_address, '']
				rcpt_addresses = []
				
				if reply_address is not None and reply_address != my_address:
					add_composer_header('To', reply_fulladdress)
				for h in 'To', 'Cc':
					for addr in filter_out_addresses(skip_addresses, get_all_headers_main(h)):
						add_composer_header(h, addr)
						rcpt_addresses.append(email.utils.parseaddr(addr)[1])
				if listaddress is not None and listaddress not in rcpt_addresses:
					add_composer_header('To', listaddress)
			elif recip == 'list':
				add_composer_header('To', listaddress)
		set_composer_text(body)
		on_after_save_draft()
		panel_edit_message.grab_focus()

def act_unsubscribe():
	MAXLEN = 80
	links = get_mailtos(','.join(Email.get_all('List-Unsubscribe')), schemata=['mailto', 'http', 'https', '*'])
	if len(links) == 1 and links[0]['split'].scheme == 'mailto':
		if open_composer():
			add_composer_mailto(links[0])
			on_after_save_draft()
	else:
		text = ''
		for link in links:
			uri = urlparse.unquote(link['uri'])
			escuri = glib.markup_escape_text(uri)
			if link['split'].scheme == 'mailto':
				linktext = link['to']
			else:
				if len(uri) > MAXLEN:
					linktext = glib.markup_escape_text(uri[0:MAXLEN-1] + 'â€¦')
				else:
					linktext = escuri
			text += '\n\n<a href=\'%s\'>%s</a>' % (escuri, linktext)
		dlg = gtk.MessageDialog(get_current_window(), gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_OTHER, gtk.BUTTONS_CLOSE)
		dlg.set_title(_("Unsubscribe Methods"))
		dlg.set_markup(_("Select a link to unsubscribe") + text)
		try:
			label = dlg.get_content_area().children()[0].children()[1].children()[0]
			label.set_selectable(False)
			dlg.get_action_area().children()[0].grab_focus()
		except: pass
		dlg.run()
		dlg.destroy()

def scroll_textview(tv, rect, scrwin):
	vadj = scrwin.get_vadjustment()
	vadj.set_value(vadj.upper - vadj.page_size)

def act_report_spam(considered_as_spam = True):
	win = gtk.Window()
	vb = gtk.VBox(False, 6)
	spanel_output = gtk.ScrolledWindow()
	panel_output = gtk.TextView()
	hb = gtk.HBox()
	btn = StockButton(stock=gtk.STOCK_CLOSE)
	win.add(vb)
	vb.pack_start(spanel_output, True, True)
	spanel_output.add(panel_output)
	vb.pack_start(hb, False, True)
	hb.pack_start(btn, True, False)
	
	win.set_transient_for(win_main)
	win.set_modal(True)
	win.set_border_width(4)
	win.set_title(_("Reporting Spam") if considered_as_spam else _("Reporting Ham"))
	hid = win.connect('delete-event', lambda w, e: True)
	win.set_data('delete-event-handler', hid)
	spanel_output.set_size_request(420, 34)
	spanel_output.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
	panel_output.set_editable(False)
	panel_output.set_wrap_mode(gtk.WRAP_NONE)
	panel_output.modify_font(pango.FontDescription('monospace'))
	bgc = win.get_style().bg[gtk.STATE_NORMAL]
	panel_output.modify_base(gtk.STATE_NORMAL, bgc)
	panel_output.connect('size-allocate', scroll_textview, spanel_output)
	buffer_output = panel_output.get_buffer()
	btn.set_sensitive(False)
	btn.connect('clicked', lambda w: win.destroy())
	win.show_all()
	
	razor_cmd = 'razor-report' if considered_as_spam else 'razor-revoke'
	pipedesc_reader, pipedesc_writer = os.pipe()
	thrd_feed = threading.Thread(target=spam_feeder_thread, args=(pipedesc_writer,))
	thrd_feed.start()
	thrd = threading.Thread(target=runcmd_thread, args=([razor_cmd, '-f', '-d'], pipedesc_reader, buffer_output, win, btn))
	thrd.start()

def spam_feeder_thread(fd):
	os.write(fd, Email.as_string())
	os.close(fd)

def runcmd_thread(args, input_fd, out_buffer, win, btn):
	reader, writer = get_pipe_handlers(1)
	pid = os.fork()
	if pid == 0:
		reader.close()
		os.dup2(input_fd, sys.stdin.fileno())
		os.dup2(writer.fileno(), sys.stdout.fileno())
		os.dup2(writer.fileno(), sys.stderr.fileno())
		os.closerange(3, 255)
		try:
			os.execvp(args[0], args)
		except OSError, e:
			sys.stderr.write(str(e))
		os._exit(127)
	
	writer.close()
	while True:
		ln = reader.readline()
		if ln == '': break
		gtk.threads_enter()
		out_buffer.insert(out_buffer.get_end_iter(), ln)
		gtk.threads_leave()
	reader.close()
	status = WaitExecStatus(pid)
	
	gtk.threads_enter()
	out_buffer.insert(out_buffer.get_end_iter(), _("exit code: %s") % (status.code))
	win.connect('delete-event', lambda w, e: w.destroy())
	win.disconnect(win.get_data('delete-event-handler'))
	btn.set_sensitive(True)
	gtk.threads_leave()

def get_extension_by_mime(mime):
	if mime is None:
		e = None
	else:
		e = guess_extension(mime)
	if e is None:
		e = '.dat'
	return e

def get_mime_by_filepath(path):
	t = Magic.file(os.path.realpath(path))
	if t is None or t.find('/')<1: return 'application/octet-stream'
	return t

def act_open():
	eml = get_part_by_itpath()
	if eml is None: return
	mime = eml.get_content_type()
	fd, tmppath = mkstemp(prefix = PROGNAME + '-', suffix = get_extension_by_mime(mime))
	try:
		save_to_filedescriptor(eml, fd)
		fh = os.fdopen(fd, 'r')
		set_xattrs(fh, {XATTR_CHARSET: eml.get_content_charset(), XATTR_TYPE: mime}, tmppath)
		fh.close()
	except OSError, e:
		os.unlink(tmppath)
		e.filename = tmppath
		display_error(e)
		return
	run_async('mimeopen-gui', [tmppath], [os.unlink, tmppath])

def calc_attachment_name(part, n=None):
	name = part.get_filename()
	if name is None:
		sfx = ''
		if n is not None: sfx = '-' + str(n)
		name = "%s - attachment%s%s" % (get_one_header_main('Subject', _("Email")), sfx, get_extension_by_mime(part.get_content_type()))
	return name

def act_save_struct():
	itpaths = selection_parts.get_selected_rows()[1]
	savedir = choose_save_folder()
	if savedir is not None:
		for n in range(0, len(itpaths)):
			act_save_struct_inner(savedir, Parts.get_iter(itpaths[n]))

def act_save_struct_inner(savedir, iterator):
	part = Parts[iterator][0]
	myname = part.get_filename()
	if not myname:
		myname = 'multipart-%s' % ('-'.join(map(str, Parts.get_path(iterator))))
	if Parts.iter_has_child(iterator):
		mysavedir = os.path.join(savedir, myname)
		try:
			mkdir(mysavedir)
		except OSError, e:
			display_error(e)
		else:
			for nth in range(0, Parts.iter_n_children(iterator)):
				subiter = Parts.iter_nth_child(iterator, nth)
				act_save_struct_inner(mysavedir, subiter)
	else:
		savefile = os.path.join(savedir, myname)
		save_to_file(part, savefile)

def act_save():
	itpaths = selection_parts.get_selected_rows()[1]
	if len(itpaths) == 1:
		itpath = itpaths[0]
		eml = get_part_by_itpath(itpath)
		savefile = choose_save_file(calc_attachment_name(eml))
		if savefile is not None:
			save_to_file(eml, savefile)
	elif len(itpaths) > 1:
		savedir = choose_save_folder()
		if savedir is not None:
			for n in range(0, len(itpaths)):
				eml = get_part_by_itpath(itpaths[n])
				basename = calc_attachment_name(eml, n)
				savefile = os.path.join(savedir, basename)
				save_to_file(eml, savefile)

def set_xattrs(fh, attrs, filename='-'):
	if xattr is not None:
		for attrname, attrval in attrs.iteritems():
			try:
				if attrval is None:
					try:
						xattr.removexattr(fh, attrname)
					except IOError, e:
						if e.errno != os.errno.ENODATA:
							raise e
				else:
					xattr.setxattr(fh, attrname, attrval)
			except IOError, e:
				sys.stderr.write((_("Notice: can not set xattr '%s' on '%s': %s") % (attrname, filename, str(e))) + '\n')

def save_to_file(eml, filename, ask_overwrite=True):
	if ask_overwrite:
		if os.path.exists(filename):
			if not question(_("This file already exists:\n%s\nOverwrite?") % (os.path.basename(filename)), (None, gtk.STOCK_SAVE)):
				return None
	try:
		fh = open(filename, 'w')
		save_to_filedescriptor(eml, fh.fileno())
		set_xattrs(fh, {XATTR_CHARSET: eml.get_content_charset(), XATTR_TYPE: eml.get_content_type()}, filename)
		fh.close()
		return True
	except IOError, e:
		display_error(e)
	except OSError, e:
		e.filename = filename
		display_error(e)
	return False

def save_to_filedescriptor(eml, fd):
	s = eml.get_payload(decode=1)
	if s is None:
		s = eml.as_string()
	written = os.write(fd, s)
	if written != len(s):
		raise OSError(5, 'Write Error')

def act_view_source():
	if panel_content.get_data('view-unfiltered'):
		filt = None
	else:
		filt = ('', None, False)
	load_part(get_part_by_itpath(), filt)

def act_wrap(tv, i=1):
	modes = cyclelist([gtk.WRAP_WORD, gtk.WRAP_WORD_CHAR, gtk.WRAP_NONE], at=panel_content.get_wrap_mode())
	tv.set_wrap_mode(modes.turn(i))

def get_current_font(txtv):
	pctx = txtv.get_pango_context()
	fdsc = pctx.get_font_description()
	s = fdsc.to_string()
	m = re.match('\s(\d+)(\s|$)', s)
	if m: pt = int(m.group(1))
	else: pt = 12
	return {'family': fdsc.get_family().lower(), 'string': s.lower(), 'size': pt, 'desc': fdsc,}

def act_font_switch(tv):
	font = get_current_font(tv)
	if font['family'] != 'monospace':
		tv.set_data('saved-font', font)
		f = tv.get_data('saved-font-monospace')
		if f is None: f = 'monospace 12'
		else: f = f['string']
	else:
		f = tv.get_data('saved-font')['string']
	change_font(tv, f)

def act_font(tv):
	dlg = gtk.FontSelectionDialog(_("Select Font"))
	dlg.set_transient_for(get_current_window())
	dlg.set_font_name(tv.get_data('saved-font')['string'])
	dlg.set_modal(True)
	dlg.run()
	font_name = dlg.get_font_name()
	dlg.destroy()
	change_font(tv, font_name)
	font = get_current_font(tv)
	if font['family'] == 'monospace':
		key = 'saved-font-monospace'
	else:
		key = 'saved-font'
	tv.set_data(key, font)

def change_font(tv, s):
	tv.modify_font(pango.FontDescription(s))

def on_select_parts(selection):
	itpaths = selection.get_selected_rows()[1]
	if len(itpaths) > 1:
		panel_btnbox.show()
		lbl_right.set_markup(_("Multiple (%s) selected attachments") % (len(itpaths)))
		btn_open.hide()
		btn_save.set_label(_("Save All"))
		panel_content_image.hide()
		spanel_content.hide()
		btn_open2.set_sensitive(False)
		btn_save2.set_sensitive(True)
		menubutton_filters.set_sensitive(False)
	else:
		panel_btnbox.hide()
		panel_content_image.hide()
		spanel_content.show()
		if len(itpaths) == 1:
			btn_open2.set_sensitive(True)
			btn_save2.set_sensitive(True)
			itpath = itpaths[0]
			eml = get_part_by_itpath(itpath)
			load_part(eml)
			menubutton_filters.set_sensitive(True)
			populate_filters_menu(eml)
		else:
			btn_open2.set_sensitive(False)
			btn_save2.set_sensitive(False)
			clear_content()
			menubutton_filters.set_sensitive(False)

def act_show_view_headers(chkmi):
	show_view_headers(chkmi.active)

def show_view_headers(show=True):
	if show:
		spanel_view_header.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
		panel_view_header.set_size_request(-1, -1)
		panel_view_header.set_line_wrap(False)
		s = ''
		for hname, hval in Email._headers:
			hval = decode_header(hval)
			s += PMU_HEAD + glib.markup_escape_text(hname) + PMU_HEAD_CLOSE + ': ' + glib.markup_escape_text(hval) + '\n'
		panel_view_header.set_markup(s)
	else:
		spanel_view_header.set_policy(gtk.POLICY_NEVER, gtk.POLICY_AUTOMATIC)
		resize_panel_view_header(spanel_view_header)
		panel_view_header.set_line_wrap(True)
		panel_view_header.set_markup(get_headers_markup(Email))
	panel_view_header.set_data('all-headers', show)

def populate_header_menu(label, menu):
	menu.append(gtk.SeparatorMenuItem())
	mi = gtk.CheckMenuItem(_("Show All Headers"))
	mi.set_active(panel_view_header.get_data('all-headers') == True)
	if panel_view_header.get_data('all-headers'): mi.set_active(True)
	mi.connect('toggled', act_show_view_headers)
	menu.append(mi)
	menu.show_all()

def populate_filters_menu(eml):
	for mi in menu_filters.children():
		menu_filters.remove(mi)
	uniqfilt = {}
	for filt in get_filters_by_mime(eml.get_content_maintype(), eml.get_content_subtype()):
		if filt[0] == '': continue
		if uniqfilt.has_key(filt[0]) and uniqfilt[filt[0]] == filt[1]: continue
		uniqfilt[filt[0]] = filt[1]
		lbl = filt[0]
		if lbl == 'sh':
			lbl = ' '.join(re.findall('(^\S+|\d*[<>]+(?:&\d+|\s*\S+)|[;\|&]+\s*\S+)', filt[1][1]))
		mi = gtk.MenuItem(lbl)
		mi.connect('activate', lambda mi, eml, filt: load_part(eml, filt), eml, filt)
		menu_filters.append(mi)
	menu_filters.show_all()
	disable_filters_menu(True if len(menu_filters.children()) == 0 else False)

def disable_filters_menu(b=True):
	menubutton_filters.children()[0].children()[1].set_sensitive(not b)

def get_part_by_itpath(itpath = None):
	if itpath is None:
		try:
			itpath = selection_parts.get_selected_rows()[1][0]
		except IndexError:
			return None
	model = Parts
	return model.get_value(model.get_iter(itpath), 0)

def load_toolitems(toolbar, toolitems):
	items = []
	for label, stock, tip, fnc_left, fnc_right in toolitems:
		hid = None
		if type(fnc_left) == str:
			tbi = gtk.SeparatorToolItem()
			if fnc_left == 'space':
				tbi.set_draw(False)
				tbi.set_expand(True)
			elif fnc_left == 'separator':
				tbi.set_draw(True)
				tbi.set_expand(False)
		elif isinstance(stock, gtk.ToolItem):
			tbi = stock
			if tip is not None:
				tbi.set_tooltip_text(_(tip))
			hid = tbi.connect('clicked', on_click_button, fnc_left)
		else:
			Lstocklabel = None
			st = gtk.stock_lookup(stock)
			if st:
				Lstocklabel = re.sub('_', '', st[1])
			if label is not None:
				Llabel = _(label)
			else:
				Llabel = Lstocklabel
			if tip is not None:
				Ltip = _(tip)
			else:
				if label is not None:
					Ltip = Llabel
				else:
					Ltip = Lstocklabel
			tbi = StockToolButton(label=Llabel, stock=stock, tooltip=Ltip)
			tbi.set_data('stock', stock)
			tbi.set_data('label', label)
			hid = tbi.connect('clicked', on_click_button, fnc_left)
			tbi.child.connect('button-press-event', on_press_button, fnc_right)
		tbi.set_data('clicked-handler', hid)
		toolbar.insert(tbi, -1)
		items.append(tbi)
	return items

def setup_treeview__icon_label(tv, label_edit_cb=None):
	colnum_txt = 1
	tvc = gtk.TreeViewColumn()
	tv.append_column(tvc)
	cr_pix = gtk.CellRendererPixbuf()
	cr_txt = gtk.CellRendererText()
	if label_edit_cb is not None:
		cr_txt.set_property('editable', True)
		cr_txt.connect('edited', label_edit_cb, colnum_txt)
	tvc.pack_start(cr_pix, False)
	tvc.pack_start(cr_txt, True)
	tvc.add_attribute(cr_txt, 'markup', colnum_txt)
	tvc.add_attribute(cr_pix, 'icon-name', 2)
	tvc.add_attribute(cr_pix, 'pixbuf', 3)


def act_send():
	msg = ''
	if not get_composer_subject():
		msg += _("No Subject.\n")
	if len(filter(lambda x: len(x.strip()), get_composer_headers(RecipientHeaders))) < 1:
		msg += _("No any Recipient.\n")
	if msg != '':
		msg += _("Send anyway?")
		if not question(msg, (_("Send"), 'mail-send')):
			return
	build_newemail()
	
	dlg = gtk.MessageDialog(get_current_window(), gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_INFO, gtk.BUTTONS_CANCEL)
	dlg.set_title(_("Sending..."))
	dlg.set_markup(_("Sending..."))
	carea = dlg.get_content_area()
	aarea = dlg.get_action_area()
	progressbar = gtk.ProgressBar()
	carea.pack_start(progressbar, False, True)
	btn_cancel = aarea.children()[0]
	dlg.show_all()
	
	thrd = threading.Thread(target=sending_thread, args=(dlg, progressbar, btn_cancel))
	thrd.start()

def sending_thread(dlg, progressbar, btn_cancel):
	child_read, parent_write, parent_read, child_write = get_pipe_handlers(2)
	pid = os.fork()
	if pid == 0:
		parent_read.close()
		parent_write.close()
		os.dup2(child_read.fileno(), sys.stdin.fileno())
		os.dup2(child_write.fileno(), sys.stdout.fileno())
		os.dup2(child_write.fileno(), sys.stderr.fileno())
		os.closerange(3, 255)
		try:
			os.execvp('sendmail', ['sendmail', '-ti'])
		except OSError, e:
			sys.stderr.write(str(e))
		os._exit(127)
	
	gtk.threads_enter()
	sn = btn_cancel.connect('clicked', sending_cancel, pid, parent_write)
	gtk.threads_leave()
	
	child_read.close()
	child_write.close()
	resp = ''
	text = NewEmail.as_string()
	pos = 0
	bufsize = 512
	length = len(text)
	while pos < length:
		try:
			parent_write.write(text[pos:pos+bufsize])
			pos += bufsize
		except ValueError, e:
			resp += str(e) + '\n'
			break
		gtk.threads_enter()
		progressbar.set_fraction((min(pos, length) + 0.0) / length)
		gtk.threads_leave()
	try:
		parent_write.close()
	except IOError, e:
		resp += str(e) + '\n'
	
	resp += ''.join(parent_read.readlines())
	parent_read.close()
	status = WaitExecStatus(pid)
	
	gtk.threads_enter()
	progressbar.hide()
	btn_cancel.hide()
	btn_close = gtk.Button(stock=gtk.STOCK_CLOSE)
	btn_close.connect('clicked', lambda x: dlg.destroy())
	dlg.get_action_area().pack_start(btn_close, False, False)
	btn_close.show_all()
	img = dlg.get_content_area().children()[0].children()[0]
	if status.code == 0:
		img.set_from_icon_name(gtk.STOCK_APPLY, gtk.ICON_SIZE_DIALOG)
		dlg.set_markup(_("Email is sent."))
		win_comp.set_data('email-sent', True)
	else:
		img.set_from_icon_name(gtk.STOCK_DIALOG_ERROR, gtk.ICON_SIZE_DIALOG)
		dlg.set_markup(_("Sendmail error %s." % (status.code)) + '\n<tt>' + glib.markup_escape_text(resp) + '</tt>')
	gtk.threads_leave()

def sending_cancel(btn, pid, writer_fh):
	writer_fh.close()
	os.kill(pid, signal.SIGINT)

def build_newemail():
	preserve_headers = win_comp.get_data('preserve-headers')
	idx = 0
	for hname, hval in NewEmail._headers:
		if hname not in preserve_headers:
			del(NewEmail._headers[idx])
			continue
		idx += 1
	for hname, hval in get_composer_headers(None) + [('Subject', get_composer_subject())]:
		if len(hval) > 0:
			mimeheader = make_header([(hval, 'UTF-8')])
			NewEmail.add_header(hname, str(mimeheader))

	text = get_composer_text()
	text_qp = text.encode('quoted-printable')
	text_b64 = text.encode('base64')
	if len(text_qp) < len(text_b64):
		text = text_qp
		enc = 'quoted-printable'
	else:
		text = text_b64
		enc = 'base64'
	part0 = NewEmail.get_payload()[0]
	part0.replace_header(HDR_CTE, enc)
	part0.set_payload(text)

def act_save_edit(save_as=False):
	filename = win_comp.get_data('saved-to-file')
	ask_overwrite = False
	if filename is None or save_as:
		ask_overwrite = True
		subj = get_composer_subject()
		if subj: subj = ' - ' + subj
		filename = choose_save_file(_("Draft") + subj + '.eml')
	if filename is not None:
		build_newemail()
		if save_to_file(NewEmail, filename, ask_overwrite=ask_overwrite) == True:
			win_comp.set_data('saved-to-file', filename)
			on_after_save_draft()

def on_after_save_draft():
	set_unsaved(False)
	panel_edit_message.get_buffer().set_modified(False)

def act_attach():
	filename = choose_open_file()
	if filename is not None:
		attach_path(filename)

def attach_path(path, parent_part=None, parent_iter=None):
	global NewEmail
	if not os.path.exists(path):
		return False
	if parent_part is None:
		parent_part = NewEmail
	basename = os.path.basename(path)
	ct_main, ct_sub = get_mime_by_filepath(path).split('/')
	
	if os.path.isdir(path):
		part = MIMEMultipart('related')
	else:
		part = MIMEBase(ct_main, ct_sub)
		part.set_payload('')
		enc = None
		try:
			fh = open(path, 'r')
		except IOError, e:
			display_error(e)
			return False
		while True:
			buf = fh.read(4095)
			if buf == '': break
			if enc is None:
				qp = buf.encode('quoted-printable')
				b64 = buf.encode('base64')
				if qp < b64:
					buf = qp
					enc = 'quoted-printable'
				else:
					buf = b64
					enc = 'base64'
				part.add_header(HDR_CTE, enc)
			else:
				buf = buf.encode(enc)
			part._payload += buf
		fh.close()
	
	part.add_header(HDR_CD, 'attachment', filename=basename)
	parent_part.attach(part)
	set_unsaved()
	stock = get_stock_by_mime(ct_main, ct_sub)
	pixb = None
	iterator = Attachments.append(parent_iter, [part, basename, stock, pixb])
	
	if os.path.isdir(path):
		for entry in os.listdir(path):
			if not attach_path(os.path.join(path, entry), part, iterator):
				return False
	return True

def drop_attachment_motion(wdg, context, x, y, time):
	wdg.drag_highlight()
	context.drag_status(gtk.gdk.ACTION_COPY, time)
	return True

def drop_attachment_accept(wdg, context, x, y, time):
	accepted = False
	for desired in ['text/uri-list']:
		if desired in context.targets:
			wdg.drag_get_data(context, desired, time)
			accepted = True
			break
	context.drop_reply(accepted, time)
	wdg.drag_unhighlight()
	return True

def drop_attachment(wdg, context, x, y, data, info, time):
	success = None
	if data.get_length() > -1:
		typ = data.get_data_type()
		if typ == 'text/uri-list':
			for uri in data.get_uris():
				if uri.startswith('file:///'):
					if not attach_path(uri[7:]):
						success = False
						break
			if success is None:
				success = True
		else:
			success = False
	else:
		success = False
	context.finish(success, False, time)
	return True

def rename_attachment(cellrenderer, iterator, new_text, colnum):
	eml = Attachments[iterator][0]
	eml._headers.remove((HDR_CD, eml[HDR_CD]))
	eml.add_header(HDR_CD, 'attachment', filename=new_text)
	Attachments[iterator][colnum] = new_text
	return True

def on_keypress_attachments(tv, evt):
	if evt.keyval == gtk.gdk.keyval_from_name('Delete'):
		sel = panel_attachments.get_selection()
		for itpath in reversed(sel.get_selected_rows()[1]):
			try:
				iterator = Attachments.get_iter(itpath)
			except ValueError:
				# child deleted in meantime
				continue
			parent_iter = Attachments.iter_parent(iterator)
			if parent_iter is None:
				parent_part = NewEmail
			else:
				parent_part = Attachments[parent_iter][0]
			parent_part._payload.remove(Attachments[iterator][0])
			del(Attachments[iterator])
		return True
	return False

def act_encrypt():
	pass

def act_sign():
	pass

def turn_importance_signal(on):
	h1 = toggle_unimportant.get_data('clicked-handler')
	h2 = toggle_important.get_data('clicked-handler')
	meth = 'handler_unblock' if on else 'handler_block'
	getattr(toggle_unimportant, meth).__call__(h1)
	getattr(toggle_important, meth).__call__(h2)

def on_toggled_importance(wdg):
	if wdg.get_active():
		if wdg == toggle_important:
			toggle_unimportant.set_active(False)
		elif wdg == toggle_unimportant:
			toggle_important.set_active(False)
		return True
	return False

def act_importance():
	n = 1
	if toggle_important.get_active(): n = 2
	elif toggle_unimportant.get_active(): n = 0
	set_composer_headers('Importance', [] if n == 1 else [Importances[n]])
	set_composer_headers('Priority', [] if n == 1 else [Priorities[n]])

def act_edit_external():
	menubutton_send.set_sensitive(False)
	panel_edit_message.set_sensitive(False)
	menubutton_edit_external.set_sensitive(False)
	
	err = None
	fd, tmppath = mkstemp(prefix = PROGNAME + '-', suffix = '.txt')
	try:
		filehandler = os.fdopen(fd, 'w')
		filehandler.write(get_composer_text())
		set_xattrs(filehandler, {XATTR_CHARSET: 'UTF-8', XATTR_TYPE: 'text/plain'}, tmppath)
		filehandler.close()
	except IOError, e:
		err = e
	except OSError, e:
		e.filename = tmppath
		err = e
	if err is not None:
		display_error(e)
		os.unlink(tmppath)
		on_edit_external_done()
		return
	thread = ExecThreadRunner('mimeopen-gui', [tmppath], [cb_edit_external, tmppath])
	thread.start()

def cb_edit_external(status, filepath):
	gtk.threads_enter()
	filehandler = None
	try:
		filehandler = open(filepath, 'r')
		on_edit_external_done(''.join(filehandler.readlines()))
	except IOError, e:
		display_error(e)
		on_edit_external_done()
	finally:
		if filehandler is not None: filehandler.close()
	try:
		os.unlink(filepath)
	except OSError:
		pass
	gtk.threads_leave()

def on_edit_external_done(data=None):
	if data is not None:
		set_composer_text(data)
	menubutton_send.set_sensitive(True)
	panel_edit_message.set_sensitive(True)
	menubutton_edit_external.set_sensitive(True)

def set_unsaved(unsaved=True):
	win_comp.set_data('is-saved', not unsaved)
	win_comp.set_data('email-sent', False)
	s = menubutton_save_draft.get_label()
	endmark = '*'
	endmarkre = re.escape(endmark)
	if unsaved:
		s = re.sub('(%s)?$' % (endmarkre), endmark, s)
	else:
		s = re.sub(endmarkre + '$', '', s)
	menubutton_save_draft.set_label(s)

def on_edit_message(tb):
	if tb.get_modified():
		set_unsaved()



### Main ###

PROGNAME = 'gemlv'
VERSION = '0.1'
USERAGENT = PROGNAME + '/' + VERSION
gettext.textdomain(PROGNAME)
_ = gettext.gettext
PMU_MIME = '<i><span color=\'gray30\'>'
PMU_MIME_CLOSE = '</span></i>'
PMU_NAME = '<b>'
PMU_NAME_CLOSE = '</b>'
PMU_HEAD = '<b>'
PMU_HEAD_CLOSE = '</b>'
PMU_WARN = '<span foreground=\'darkred\' weight=\'bold\'>'
PMU_WARN_CLOSE = '</span>'
PMU_SUBJ = '<big>'
PMU_SUBJ_CLOSE = '</big>'
Email = None
PartPrimary = None
PartSecondary = None
LastFolder = os.getcwd()
SenderHeaders = ['From', 'Reply-To', 'Organization']
RecipientHeaders = ['To', 'Cc', 'Bcc']
DateTimeHeaders = ['Date', 'Reply-By', 'Expires']
PopularHeaders = ['Subject']
AdvancedHeaders = [
	'References', 'In-Reply-To', 'Disposition-Notification-To',
	'Priority', 'Importance', 'Precedence',
	'Newsgroups', 'Followup-To', 'Thread-Topic',
	'Language', 'Accept-Language', 'Content-Language',
	'Expires',
	'User-Agent', 'X-Mailer',
	]
XATTR_CHARSET = 'user.mime_encoding'
XATTR_TYPE = 'user.mime_type'
NewEmail = None
PREAMBLE = _("This is a MIME multipart Email.")
Magic = magic.open(magic.MAGIC_MIME_TYPE)
HDR_CD = 'Content-Disposition'
HDR_CTE = 'Content-Transfer-Encoding'
Importances = ['low','normal','high']
Priorities = ['non-urgent','normal','urgent']


### Parse Arguments ###

argparser = argparse.ArgumentParser()
argparser.add_argument('--compose', action='store_true', help=_("Write a new Email"))
argparser.add_argument('--from', metavar='FROM', help=_("New Email's writer's name and address"))
argparser.add_argument('--to', metavar='ADDRESSES', help=_("New Email's Recipients, comma-separated list"))
argparser.add_argument('--cc', metavar='ADDRESSES', help=_("Carbon Copy Recipients, comma-separated list"))
argparser.add_argument('--bcc', metavar='ADDRESSES', help=_("Blind Carbon Copy Recipients, comma-separated list"))
argparser.add_argument('--subject', metavar='STRING', help=_("Subject"))
argparser.add_argument('--message', metavar='STRING', help=_("Message body"))
argparser.add_argument('--mailto', metavar='URL', help=_("Full 'mailto:' link"))
argparser.add_argument('--attach', metavar='FILES', help=_("Attachments, comma-separated list"))
argparser.add_argument('--localedir', metavar='DIR', help=_("L10n base directory"))
argparser.add_argument('FILE', nargs='?', help=_("Raw Email file for read or continue editing"))
args = argparser.parse_args()
for attr in 'to', 'cc', 'bcc', 'attach':
	if getattr(args, attr) is not None:
		setattr(args, attr, re.split('\s*,\s*', getattr(args, attr)))
if not args.compose and not args.FILE:
	sys.stderr.write(_("Either compose mode or FILE is needed.") + '\n')
	os._exit(1)
if args.localedir:
	gettext.bindtextdomain(PROGNAME, os.path.abspath(args.localedir))
gtk.gdk.threads_init()


### Build GUI ###

win_main = gtk.Window()
win_main.set_default_size(800, 450)
start_evt = win_main.connect('map-event', win_main_show)
win_main.connect('delete-event', lambda a,b: act_quit())
add_key_binding(win_main, '<Control>q', lambda a,b,c,d: act_quit())
add_key_binding(win_main, '<Control>s', lambda a,b,c,d: act_save())
add_key_binding(win_main, '<Control>o', lambda a,b,c,d: act_open())
add_key_binding(win_main, '<Control>n', lambda a,b,c,d: act_compose())
add_key_binding(win_main, '<Control><Shift>r', lambda a,b,c,d: act_reply('one'))
add_key_binding(win_main, '<Control>r', lambda a,b,c,d: act_reply('all'))
add_key_binding(win_main, '<Control>f', lambda a,b,c,d: act_reply(''))
add_key_binding(win_main, '<Control>u', lambda a,b,c,d: act_view_source())
add_key_binding(win_main, '<Control>h', lambda a,b,c,d: show_view_headers(not panel_view_header.get_data('all-headers')))

box_main = gtk.VBox(False, 5)
toolbar = gtk.Toolbar()
spanel_view_header = gtk.ScrolledWindow()
panel_view = gtk.VPaned()
panel_view_upper = gtk.VBox()
panel_view_header = gtk.Label()
panel_view_subject = gtk.Label(' ')
panel_body = gtk.HPaned()
spanel_parts = gtk.ScrolledWindow()
Parts = gtk.TreeStore(gobject.TYPE_PYOBJECT, str, str, gtk.gdk.Pixbuf)
panel_parts = gtk.TreeView(Parts)
selection_parts = panel_parts.get_selection()
panel_right = gtk.VBox()
lbl_right = gtk.Label()
panel_btnbox = gtk.Frame()
panel_btnbox2 = gtk.VBox()
panel_btnbox3 = gtk.HBox()
btnbox_right = gtk.VBox(True, 10)
btn_open = StockButton(stock=gtk.STOCK_OPEN)
btn_save = StockButton(stock=gtk.STOCK_SAVE)
btn_save_struct = StockButton(label=_("Save to Structure"), stock=gtk.STOCK_SAVE)
panel_content_image = gtk.Frame()
spanel_content = gtk.ScrolledWindow()
panel_content = gtk.TextView()
tb_controls = gtk.Toolbar()
menubutton_filters = gtk.MenuToolButton(gtk.STOCK_ZOOM_FIT)
menu_filters = gtk.Menu()

win_main.add(box_main)
box_main.pack_start(toolbar, False, True)
box_main.pack_start(panel_view, True, True)
panel_view.pack1(panel_view_upper, False, True)
panel_view_upper.pack_start(spanel_view_header, True, True)
spanel_view_header.add_with_viewport(panel_view_header)
panel_view_upper.pack_start(panel_view_subject, False, True)
panel_view.pack2(panel_body, True, True)
panel_body.pack1(spanel_parts, True, True)
panel_body.pack2(panel_right, True, True)
spanel_parts.add_with_viewport(panel_parts)
panel_right.pack_start(panel_btnbox, True, True)
panel_btnbox.add(panel_btnbox2)
panel_btnbox2.pack_start(panel_btnbox3, True, False)
panel_btnbox3.pack_start(lbl_right, True, False)
panel_btnbox3.pack_start(btnbox_right, True, False)
btnbox_right.pack_start(btn_open, False, False)
btnbox_right.pack_start(btn_save, False, False)
btnbox_right.pack_start(btn_save_struct, False, False)
panel_right.pack_start(panel_content_image, True, True)
panel_content_image.add(gtk.Image())
panel_right.pack_start(spanel_content, True, True)
spanel_content.add_with_viewport(panel_content)
panel_right.pack_start(tb_controls, False, True)

win_main.set_icon_name('emblem-mail')
win_main.set_geometry_hints(min_width=100, min_height=250)
toolbar.set_style(gtk.TOOLBAR_BOTH)
panel_view.set_position(124)
spanel_view_header.set_policy(gtk.POLICY_NEVER, gtk.POLICY_AUTOMATIC)
spanel_view_header.connect('size-allocate', resize_panel_view_header)
panel_view_header.set_line_wrap(True)
panel_view_header.set_padding(4, 2)
panel_view_header.set_alignment(0, 0)
panel_view_header.set_justify(gtk.JUSTIFY_LEFT)
panel_view_header.set_selectable(True)
panel_view_header.connect('populate-popup', populate_header_menu)
panel_view_subject.set_selectable(True)
panel_view_subject.set_padding(5, 4)
panel_view_subject.set_alignment(0, 0)
panel_view_subject.set_justify(gtk.JUSTIFY_LEFT)
panel_body.set_position(175)
spanel_parts.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
spanel_content.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
panel_parts.set_headers_visible(False)
selection_parts.set_mode(gtk.SELECTION_MULTIPLE)
selection_parts.connect('changed', on_select_parts)
lbl_right.set_alignment(0, 0)
lbl_right.set_justify(gtk.JUSTIFY_LEFT)
btn_open.connect('clicked', lambda wdg: act_open())
btn_save.connect('clicked', lambda wdg: act_save())
btn_save_struct.connect('clicked', lambda wdg: act_save_struct())
panel_content_image.connect('size-allocate', on_allocate_panel_content_image)
panel_content.set_editable(False)
panel_content.set_wrap_mode(gtk.WRAP_WORD)
tb_controls.set_icon_size(gtk.ICON_SIZE_MENU)
tb_controls.set_style(gtk.TOOLBAR_ICONS)
menubutton_filters.set_homogeneous(False)
menubutton_filters.set_menu(menu_filters)
menubutton_filters.set_arrow_tooltip_text(_("Filters"))


toolbuttons = [
	("Compose", gtk.STOCK_EDIT, None, act_compose, None),
	("Reply", 'mail-reply-sender', None, (act_reply, 'one'), None),
	("Reply To All", 'mail-reply-all', None, (act_reply, 'all'), None),
	("Reply To List", 'mail-reply-all', None, (act_reply, 'list'), None),
	("Forward", 'mail-forward', None, (act_reply, ''), None),
	(None, None, None, 'separator', None),
	("Unsubscribe", 'stop', None, act_unsubscribe, None),
	("Report Spam", 'mail-mark-junk', None, act_report_spam, None),
	(None, None, None, 'space', None),
	(None, gtk.STOCK_QUIT, None, act_quit, None),
]
x, x, x, menubutton_replytolist, x, x_, menubutton_unsubscribe, x, x_, x \
= load_toolitems(toolbar, toolbuttons)
setup_treeview__icon_label(panel_parts)

def ToolItemDeclaration_wrap(tv):
	return ("Wrap", gtk.STOCK_JUSTIFY_LEFT, "Soft / Hard / No Wrap\nRight click: No / Soft / Hard Wrap", (act_wrap, tv), (act_wrap, tv, -1))
def ToolItemDeclaration_font(tv):
	return (None, gtk.STOCK_SELECT_FONT, "Change Font\nRight click: monospace", (act_font, tv), (act_font_switch, tv))

toolbuttons = [
	(None, None, None, 'space', None),
	(None, gtk.STOCK_OPEN, None, act_open, None),
	(None, gtk.STOCK_SAVE, "Save\nRight click: Save to Structure", act_save, act_save_struct),
	(None, None, None, 'separator', None),
	("Unfilter", menubutton_filters, "Filter / Unfilter", act_view_source, None),
	ToolItemDeclaration_wrap(panel_content),
	ToolItemDeclaration_font(panel_content),
]
x_, btn_open2, btn_save2, x_, x, x, x \
= load_toolitems(tb_controls, toolbuttons)


### Build Composer GUI ###

win_comp = gtk.Window()
win_comp.set_default_size(*win_main.get_default_size())
win_comp.connect('delete-event', lambda a,b: act_close_edit())
add_key_binding(win_comp, '<Control>'+('q' if args.compose else 'w'), lambda a,b,c,d: act_close_edit())
add_key_binding(win_comp, '<Control>s', lambda a,b,c,d: act_save_edit())
add_key_binding(win_comp, '<Control><Shift>s', lambda a,b,c,d: act_save_edit(True))
add_key_binding(win_comp, 'F4', lambda a,b,c,d: act_edit_external())

box_compose = gtk.VBox()
tb_compose = gtk.Toolbar()
panel_compose = gtk.VPaned()
panel_upper = gtk.HPaned()
spanel_comp_header = gtk.ScrolledWindow()
menu_add_header = gtk.Menu()
panel_comp_header = gtk.VBox(False, 0)
UnionHeadersStore = gtk.ListStore(str)
spanel_attachments = gtk.ScrolledWindow()
Attachments = gtk.TreeStore(gobject.TYPE_PYOBJECT, str, str, gtk.gdk.Pixbuf)
panel_attachments = gtk.TreeView(Attachments)
panel_edit = gtk.VBox()
panel_subject = gtk.HBox(False, 5)
panel_subject.set_border_width(4)
entry_subject = gtk.Entry()
frame_edit = gtk.Frame()
spanel_edit_message = gtk.ScrolledWindow()
panel_edit_message = gtk.TextView()
tb_comp_controls = gtk.Toolbar()

win_comp.add(box_compose)
box_compose.pack_start(tb_compose, False, True)
box_compose.pack_start(panel_compose, True, True)
panel_compose.pack1(panel_upper, True, True)
panel_upper.pack1(spanel_comp_header, True, True)
spanel_comp_header.add_with_viewport(panel_comp_header)
panel_upper.pack2(spanel_attachments, False, True)
spanel_attachments.add_with_viewport(panel_attachments)
panel_attachments.set_headers_visible(False)
panel_compose.pack2(panel_edit, True, True)
panel_edit.pack_start(panel_subject, False, True)
panel_subject.pack_start(gtk.Label(_("Subject")), False, True)
panel_subject.pack_start(entry_subject, True, True)
panel_edit.pack_start(frame_edit, True, True)
frame_edit.add(spanel_edit_message)
spanel_edit_message.add(panel_edit_message)
box_compose.pack_start(tb_comp_controls, False, True)

win_comp.set_icon_name('mail-message-new')
win_comp.set_geometry_hints(min_width=120, min_height=200)
tb_compose.set_style(gtk.TOOLBAR_BOTH)
panel_upper.set_position(win_comp.get_default_size()[0]-150)
spanel_comp_header.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
spanel_comp_header.connect('button-press-event', open_comp_hdr_menu)
panel_comp_header.set_border_width(4)
spanel_attachments.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
panel_attachments.get_selection().set_mode(gtk.SELECTION_MULTIPLE)
panel_attachments.drag_dest_set(0, [], 0)
panel_attachments.connect('drag-motion', drop_attachment_motion)
panel_attachments.connect('drag-drop', drop_attachment_accept)
panel_attachments.connect('drag-data-received', drop_attachment)
panel_attachments.connect('focus-out-event', lambda w, e: w.get_selection().unselect_all())
panel_attachments.connect('key-press-event', on_keypress_attachments)
panel_compose.set_position(125)
entry_subject.connect('changed', on_edit_subject)
spanel_edit_message.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
panel_edit_message.get_buffer().connect('modified-changed', on_edit_message)
frame_edit.set_shadow_type(gtk.SHADOW_IN)
tb_comp_controls.set_icon_size(gtk.ICON_SIZE_MENU)
tb_comp_controls.set_style(gtk.TOOLBAR_ICONS)

for name in SenderHeaders:
	mi = gtk.CheckMenuItem(_("Specify %s") % (_(name)))
	mi.set_data('chname', name)
	mi.connect('toggled', act_comp_hdr_menuitem)
	menu_add_header.append(mi)
mi = StockMenuItem(stock_id=gtk.STOCK_ADD, label=_("Add Recipient"))
mi.connect('activate', act_comp_hdr_menuitem, 'To')
menu_add_header.append(mi)
menu_add_header.append(gtk.SeparatorMenuItem())
mi = StockMenuItem(stock_id=gtk.STOCK_ADD, label=_("Add Custom Header"))
mi.connect('activate', act_comp_hdr_menuitem, '')
menu_add_header.append(mi)
menuitem_all_comp_hdr = gtk.CheckMenuItem(_("Show Custom Headers"))
menuitem_all_comp_hdr.connect('toggled', act_all_comp_hdr)
menu_add_header.append(menuitem_all_comp_hdr)
menu_add_header.show_all()

toolbuttons = [
	("Send", 'mail-send', None, act_send, None),
	(None, gtk.STOCK_SAVE, "Save\nRight click: Save As...", act_save_edit, (act_save_edit, True)),
	("Addressbook", 'x-office-address-book', None, None, None), # TODO
	("Attach File", 'mail-attachment', None, act_attach, None),
	(None, None, None, 'space', None),
	(None, gtk.STOCK_QUIT if args.compose else gtk.STOCK_CLOSE, None, act_close_edit, None),
]
menubutton_send, menubutton_save_draft, x, x, x_, x \
= load_toolitems(tb_compose, toolbuttons)
setup_treeview__icon_label(panel_attachments, label_edit_cb=rename_attachment)

for h in SenderHeaders + RecipientHeaders + PopularHeaders + AdvancedHeaders:
	UnionHeadersStore.append([h])

toggle_unimportant = StockToggleToolButton('emblem-generic')
toggle_important = StockToggleToolButton('emblem-important')
toggle_unimportant.connect('toggled', on_toggled_importance)
toggle_important.connect('toggled', on_toggled_importance)
toolbuttons = [
	(None, None, None, 'space', None),
	(None, StockToggleToolButton('dialog-password'), "Encrypt", act_encrypt, None),
	(None, StockToggleToolButton('mail-signed'), "Crypto-Sign", act_sign, None),
	(None, None, None, 'separator', None),
	("Unimportant", toggle_unimportant, "Unimportant", act_importance, None),
	("Important", toggle_important, "Important", act_importance, None),
	(None, None, None, 'separator', None),
	(None, gtk.STOCK_EDIT, "Edit with External Program", act_edit_external, None),
	ToolItemDeclaration_wrap(panel_edit_message),
	ToolItemDeclaration_font(panel_edit_message),
]
x_, x, x, x_, x, x, x_, menubutton_edit_external, x, x \
= load_toolitems(tb_comp_controls, toolbuttons)


Magic.load()
signal.signal(signal.SIGTERM, sighandler)
if args.compose:
	open_composer()
	if args.FILE:
		# TODO load email
		win_comp.set_data('saved-to-file', args.FILE)
	if args.mailto:
		try:
			mailto = get_mailtos('<%s>' % (args.mailto))[0]
		except IndexError:
			sys.stderr.write(_("Can not parse mailto link.") + '\n')
		else:
			add_composer_mailto(mailto)
	if getattr(args, 'from'):
		set_composer_headers('From', [getattr(args, 'from')])
	if args.to:
		add_composer_headers('To', args.to)
	if args.cc:
		add_composer_headers('Cc', args.cc)
	if args.bcc:
		add_composer_headers('Bcc', args.bcc)
	if len(get_composer_headers(RecipientHeaders)) < 1:
		add_composer_header('To')
	if args.subject:
		set_composer_subject(args.subject)
	if args.message:
		set_composer_text(args.message)
	else:
		set_composer_text('\n\n' + get_user_signature())
	if args.attach:
		for path in args.attach:
			attach_path(path)
	on_after_save_draft()
	panel_edit_message.grab_focus()
else:
	win_main.show_all()
	panel_btnbox.hide()
	panel_content_image.hide()
	menubutton_replytolist.hide()
	menubutton_unsubscribe.hide()

gtk.main()
