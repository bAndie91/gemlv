#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os
import sys
import signal
import select
import fcntl
import gtk
import gobject
import glib
import pango
import gettext
import email
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email.mime.message import MIMEMessage
from email.header import make_header
import re
from tempfile import mkstemp
from mimetypes import guess_extension
import magic
from fnmatch import fnmatch
import argparse
try:
	import xattr
except ImportError:
	sys.stderr.write("No module named xattr. Degrading extended attribute management.\n")
	xattr = None
import urlparse
import pwd
import threading
import time
import hashlib
import urllib2
import ctypes
from ctypes.util import find_library
try:
	import textwrap
except ImportError:
	sys.stderr.write("No module named textwrap. Degrading.\n")
	class textwrap(object):
		@classmethod
		def wrap(self, text, width):
			return [text]
try:
	import setproctitle
except ImportError:
	sys.stderr.write("No module named setproctitle. Degrading.\n")
	class setproctitle(object):
		@classmethod
		def setproctitle(self, *x, **kv):
			pass


### helper classes, functions ###

class gtkWindow(gtk.Window):
	def set_icon_name(self, name):
		self.set_icon(gtk.icon_theme_get_default().load_icon(name, gtk.ICON_SIZE_SMALL_TOOLBAR, 0))

class LabelToolItem(gtk.ToolItem):
	def __init__(self, label=None, markup=None):
		super(self.__class__, self).__init__()
		self.label = gtk.Label()
		if label is not None: self.label.set_label(label)
		if markup is not None: self.markup.set_markup(markup)
		self.add(self.label)
	def set_label(self, label):
		self.label.set_label(label)
	def set_markup(self, markup):
		self.markup.set_markup(markup)

class StockToggleToolButton(gtk.ToggleToolButton):
	def __init__(self, stock=None):
		super(self.__class__, self).__init__(stock)
		if stock not in gtk.stock_list_ids():
			self.set_icon_name(stock)

class StockMenuItem(gtk.ImageMenuItem):
	def __init__(self, stock_id=None, accel_group=None, label=None):
		super(self.__class__, self).__init__(stock_id=stock_id, accel_group=accel_group)
		if label is not None:
			self.set_label(label)

class StockToolButton(gtk.ToolButton):
	def __init__(self, label=None, stock=None, tooltip=None):
		super(self.__class__, self).__init__()
		if stock is not None:
			if stock in gtk.stock_list_ids():
				if stock is not None: self.set_stock_id(stock)
			else:
				self.set_icon_name(stock)
		if label is not None:
			self.set_label(label)
		if tooltip is not None:
			self.set_tooltip_text(tooltip)
	def set_pixbuf(self, pxb):
		btn = self.get_children()[0]
		x = btn.get_children()[0]
		img, x = x.get_children()
		img.set_from_pixbuf(pxb)
		img.props.visible = True
	def __get_children(self):
		align = self.get_children()[0]
		hbox = align.get_children()[0]
		return hbox.get_children()
	def set_markup(self, markup):
		lbl = self.__get_children()[1]
		lbl.set_markup(markup)

class StockButton(gtk.Button):
	def __init__(self, label=None, stock=None, use_underline=True, icon_size=None):
		if stock is not None and stock in gtk.stock_list_ids():
			stock_tmp = stock
		else:
			stock_tmp = gtk.STOCK_ABOUT
		super(self.__class__, self).__init__(stock=stock_tmp, use_underline=use_underline)
		if label is not None:
			self.set_markup(label)
		if stock is None:
			self.set_icon('')
		elif stock not in gtk.stock_list_ids():
			self.set_icon(stock)
		if icon_size is not None:
			self.set_icon(stock, icon_size)
	def __get_children(self):
		align = self.get_children()[0]
		hbox = align.get_children()[0]
		return hbox.get_children()
	def set_label(self, label):
		x, lbl = self.__get_children()
		lbl.set_label(label)
	def set_markup(self, label):
		x, lbl = self.__get_children()
		lbl.set_markup(label)
	def set_icon(self, icon, size=gtk.ICON_SIZE_BUTTON):
		img, x = self.__get_children()
		if type(icon) == str:
			if icon == '':
				img.props.visible = False
			else:
				img.set_from_icon_name(icon, size)
				img.props.visible = True
		else:
			img.set_from_pixbuf(icon)
			img.props.visible = True

class Marquee(gtk.ScrolledWindow):
	def __init__(self, child):
		assert isinstance(child, gtk.Widget)
		super(self.__class__, self).__init__()
		self.set_policy(gtk.POLICY_NEVER, gtk.POLICY_NEVER)
		self.add_with_viewport(child)
		viewport = self.get_child()
		viewport.set_shadow_type(gtk.SHADOW_NONE)
		viewport.connect('scroll-event', self.scroll_viewport)
	def scroll_viewport(self, viewport, event):
		hadj = self.get_hadjustment()
		delta = +10 if event.direction in [gtk.gdk.SCROLL_DOWN, gtk.gdk.SCROLL_LEFT] else -10
		newvalue = hadj.value + delta
		width = self.get_allocation().width
		if newvalue + width > hadj.upper:
			newvalue = hadj.upper - width
		hadj.set_value(newvalue)

class cfgparser(object):
	def __init__(self, name, **kvargs):
		self.var = {'regex': '^\s*([^;#].*)', 'split': [1],}
		for k in 'regex', 'splitgroups':
			if not self.var.has_key(k): self.var[k] = None
			if kvargs.has_key(k): self.var[k] = kvargs[k]
		suff = '.conf'
		self.filehandlers = []
		for t in (os.environ['HOME'], '.config', PROGNAME, name + suff), (os.path.sep, 'etc', PROGNAME, name + suff), (name + suff,),:
			n = os.path.join(*t)
			try:
				fh = open(n, 'r')
				self.filehandlers.append(fh)
			except IOError:
				pass
	
	def __iter__(self):
		return self
	
	def next(self):
		if len(self.filehandlers) == 0:
			raise StopIteration
		else:
			fh = self.filehandlers[0]
			while True:
				ln = fh.readline()
				if ln == '':
					fh.close()
					self.filehandlers.reverse()
					self.filehandlers.pop()
					self.filehandlers.reverse()
					if len(self.filehandlers) == 0:
						raise StopIteration
					fh = self.filehandlers[0]
					continue
				m = re.search(self.var['regex'], ln)
				if m:
					grps = []
					n = 0
					for grp in m.groups():
						n += 1
						if n in self.var['splitgroups']:
							if grp is None:
								grp = []
							else:
								grp = re.split('\s+', grp)
						grps.append(grp)
					return grps
	
	def __del__(self):
		for fh in self.filehandlers:
			fh.close()

class pipereader(object):
	def __init__(self, inputstr, cmd, args=[], exitdict=None):
		self.exitdict = exitdict
		args = args[:]
		args.insert(0, os.path.basename(cmd))
		child_read, parent_write, parent_read, child_write = get_pipe_handlers(2)
		pid = os.fork()
		if pid == 0:
			parent_read.close()
			parent_write.close()
			os.dup2(child_read.fileno(), sys.stdin.fileno())
			os.dup2(child_write.fileno(), sys.stdout.fileno())
			os.closerange(3, 255)
			try:
				os.execvp(cmd, args)
			except OSError as e:
				stderr(str(e))
			os._exit(127)
		else:
			child_read.close()
			child_write.close()
			parent_write.write(inputstr)
			parent_write.close()
			self.pid = pid
			self.reader = parent_read
	
	def __iter__(self):
		return self
	
	def next(self):
		s = self.reader.readline()
		if s == '':
			raise StopIteration
		else:
			return s
	
	def __del__(self):
		self.reader.close()
		status = WaitExecStatus(self.pid)
		if self.exitdict is not None:
			self.exitdict.update(status.__dict__)

class cyclelist(list):
	def __init__(self, lst, **kvargs):
		if type(lst) != type([]):
			raise TypeError('need list, %s found' % (str(type(lst))))
		if len(lst) < 1:
			raise ValueError('need non-empty list')
		super(self.__class__, self).__init__(lst)
		self.idx = 0
		if kvargs.has_key('at'):
			self.whirl(kvargs['at'])
	
	def whirl(self, val):
		for i in range(0, len(self)):
			if self[i] == val:
				self.idx = i
				return val
		return None
	
	def turn(self, n=1):
		self.idx = (self.idx + n) % len(self)
		return self[self.idx]
	
	def __getitem__(self, i):
		return super(self.__class__, self).__getitem__(i % len(self))

	def __setitem__(self, i, v):
		return super(self.__class__, self).__setitem__(i % len(self), v)
	
	def __str__(self):
		return str(self[self.idx])


class TIMEVAL(ctypes.Structure):
	_fields_ = [('tv_sec', ctypes.c_long), ('tv_usec', ctypes.c_long)]

def futimes(fd, times):
	if len(times) < 2:
		raise OSError
	stdlib = find_library('c')
	libc = ctypes.CDLL(stdlib)
	TIMEVALS = TIMEVAL * 2
	if libc.futimes(fd, TIMEVALS((times[0], 0), (times[1], 0))) == -1:
		raise OSError

def timer_once(iden, sec, func, func_args=()):
	if Timers.has_key(iden):
		glib.source_remove(Timers[iden])
		del Timers[iden]
	if func is not None:
		Timers[iden] = glib.timeout_add(sec*1000, timer_call, (func, func_args))

def timer_call(data):
	func = data[0]
	args = data[1]
	func(*args)
	return False

def add_key_binding(widget, keyname, callback):
	accelgroup = gtk.AccelGroup()
	key, modifier = gtk.accelerator_parse(keyname)
	accelgroup.connect_group(key, modifier, gtk.ACCEL_VISIBLE, callback)
	widget.add_accel_group(accelgroup)

def get_current_window():
	for w in gtk.window_list_toplevels():
		if w.is_active():
			while True:
				par = w.get_transient_for()
				if par is None:
					return w
				else:
					w = par
	return None

def display_error(e):
	text = None
	if isinstance(e, OSError) or isinstance(e, IOError):
		text = '%s (#%d)' % (e.strerror, e.errno)
		if e.filename is not None:
			text += '\n%s' % (e.filename)
	elif isinstance(e, Exception):
		text = e.message
	elif type(e) == type([]):
		text = ''.join(e)
	if text is None:
		text = str(e)
	dlg = gtk.MessageDialog(get_current_window(), gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_ERROR, gtk.BUTTONS_OK, text)
	dlg.set_title(_("Error"))
	dlg.run()
	dlg.destroy()

def question(msg, stock_yes=None, stock_no=None, parent=None):
	dlg = gtk.MessageDialog(parent or get_current_window(), gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_QUESTION, gtk.BUTTONS_YES_NO)
	dlg.set_markup(msg)
	dlg.set_title(_("Question"))
	if stock_no is not None:
		dlg.get_widget_for_response(gtk.RESPONSE_NO).hide()
		btn_no = StockButton(label=stock_no[0], stock=stock_no[1])
		dlg.add_action_widget(btn_no, gtk.RESPONSE_NO)
		btn_no.show()
	if stock_yes is not None:
		dlg.get_widget_for_response(gtk.RESPONSE_YES).hide()
		btn_yes = StockButton(label=stock_yes[0], stock=stock_yes[1])
		dlg.add_action_widget(btn_yes, gtk.RESPONSE_YES)
		btn_yes.show()
	resp = dlg.run()
	dlg.destroy()
	return (resp == gtk.RESPONSE_YES)

def set_dialog_icon_name(dlg, icon):
	img = dlg.get_content_area().children()[0].children()[0]
	img.set_from_icon_name(icon, gtk.ICON_SIZE_DIALOG)

def choose_dialog(action, filename=None):
	global LastFolder
	selected = None
	
	btn_accept_stock = gtk.STOCK_SAVE
	if action == gtk.FILE_CHOOSER_ACTION_OPEN:
		btn_accept_stock = gtk.STOCK_OPEN
	dlg = gtk.FileChooserDialog(parent=get_current_window(), action=action, buttons=(gtk.STOCK_CANCEL, gtk.RESPONSE_REJECT, btn_accept_stock, gtk.RESPONSE_ACCEPT))
	if LastFolder is not None: dlg.set_current_folder(LastFolder)
	if filename is not None: dlg.set_current_name(filename)
	btn_cwd = StockButton(label=_("Working Dir"), stock=gtk.STOCK_JUMP_TO)
	dlg.add_action_widget(btn_cwd, gtk.RESPONSE_NO)
	btn_cwd.show()
	while True:
		resp = dlg.run()
		if resp == gtk.RESPONSE_ACCEPT:
			selected = dlg.get_filename()
			break
		elif resp == gtk.RESPONSE_NO:
			dlg.set_current_folder(os.getcwd())
		else:
			break
	LastFolder = dlg.get_current_folder()
	dlg.destroy()
	return selected

def choose_save_file(filename=None):
	return choose_dialog(gtk.FILE_CHOOSER_ACTION_SAVE, filename)

def choose_save_folder():
	return choose_dialog(gtk.FILE_CHOOSER_ACTION_SELECT_FOLDER)

def choose_open_file():
	return choose_dialog(gtk.FILE_CHOOSER_ACTION_OPEN)

def get_pipe_handlers(npairs):
	pipes = []
	for n in range(0, npairs):
		r, w = os.pipe()
		pipes.append(os.fdopen(r, 'r'))
		pipes.append(os.fdopen(w, 'w'))
	return pipes

def set_blocking(fd, doblock):
	if type(fd) != int:
		fd = fd.fileno()
	fl = fcntl.fcntl(fd, fcntl.F_GETFL)
	if doblock:
		fl = fl & ~os.O_NONBLOCK
	else:
		fl = fl | os.O_NONBLOCK
	return fcntl.fcntl(fd, fcntl.F_SETFL, fl)

def stderr(string):
	sys.stderr.write(string + ('' if string[-1] == '\n' else '\n'))

def which(cmd):
	def is_executable(p):
		return (os.path.isfile(p) and os.access(p, os.X_OK))
	
	ap, bn = os.path.split(cmd)
	if ap:
		if is_executable(cmd):
			return cmd
	else:
		for d in os.environ['PATH'].split(os.path.pathsep):
			p = os.path.join(d, cmd)
			if is_executable(p):
				return p
	return None

def mkdir(path):
	if os.path.exists(path) or path == '':
		return
	else:
		mkdir(os.path.dirname(path))
		os.mkdir(path)

def run_async(cmd, args, postrun):
	args = args[:]
	args.insert(0, os.path.basename(cmd))
	pid1 = os.fork()
	if pid1 == 0:
		os.closerange(0, 255)
		pid2 = os.fork()
		if pid2 == 0:
			pid3 = os.fork()
			if pid3 == 0:
				os.execvp(cmd, args)
				os._exit(127)
			else:
				status = WaitExecStatus(pid3)
				postrun[0](*postrun[1:])
				os._exit(status.code)
		else:
			os._exit(0)
	else:
		os.waitpid(pid1, 0)

class WaitExecStatus(object):
	def __init__(self, pid):
		x, status = os.waitpid(pid, 0)
		self.status = status >> 8
		self.code = self.status
		self.signal = status & 0x7F
		self.coredumped = status & 0x80 >> 7
	def __repr__(self):
		return 'status %s, signal %s%s' % (self.status, self.signal, ', core dumped' if self.coredumped else '')

class ExecThreadRunner(threading.Thread):
	def __init__(self, syscmd, sysargs, cb=None):
		assert isinstance(syscmd, str)
		assert isinstance(sysargs, list)
		assert isinstance(cb, list)
		assert len(cb) > 0
		super(self.__class__, self).__init__(target=self.execve, args=[syscmd, sysargs])
		self.callback = cb
	
	def execve(self, cmd, args):
		pid = os.fork()
		if pid == 0:
			os.closerange(0, 255)
			try:
				os.execvp(cmd, [cmd] + args)
			except OSError as e:
				stderr(str(e))
			os._exit(127)
		else:
			return WaitExecStatus(pid)
	
	def run(self):
		result = self._Thread__target(*self._Thread__args, **self._Thread__kwargs)
		if self.callback is not None:
			self.callback[0](result, *self.callback[1:])

def main_thread_alive():
	alive = None
	for thr in threading.enumerate():
		if thr.name == 'MainThread':
			alive = thr.is_alive()
			break
	return alive

def get_header_parameter(text, param):
	for g1, g2 in re.findall('\\b' + re.escape(param) + '=(?:\x22([^\x22]+)\x22|([^\s;]+))', text or ''):
		if g1 != '': return g1
		if g2 != '': return g2
	return None

def truish(x):
	return(str(x).lower() in ['yes', '1', 'true', 'on'])

def file_uri_to_path(uri):
	if uri.startswith('file:///'):
		return urllib2.unquote(uri[7:])
	elif uri.startswith('file://'):
		return urllib2.unquote(uri[6:])
	elif uri.startswith('file:/'):
		return urllib2.unquote(uri[5:])
	return None


def get_iterator_from_pos(treeview, x, y):
	pathinfo = treeview.get_path_at_pos(x, y)
	if pathinfo is None: return None
	return treeview.get_model().get_iter(pathinfo[0])


def human_size(x, suffix='B', decimals=1):
	prefixa = ['', 'K', 'M', 'G']
	for prefixum in prefixa:
		if abs(x) < 1024.0 or prefixum == prefixa[-1]:
			return '%.*f %s%s' % (decimals, x, prefixum, suffix)
		x /= 1024.0

def fix_unquoted_comma(s):
	def repl(m):
		probably_realname = m.group(2)
		probably_realname_norm = probably_realname.strip()
		if probably_realname_norm == '' or probably_realname_norm.startswith('"') or probably_realname.find(',')==-1:
			return m.group(0)
		else:
			return '%s "%s" %s' % (m.group(1), probably_realname_norm, m.group(3))
	return re.sub('(^|,)(.+)(<)', repl, s)

def getaddresses(array):
	return email.utils.getaddresses(map(fix_unquoted_comma, array))

### private functions ###

def win_main_show(widget, event):
	win_main.disconnect(start_evt)
	panel_content.set_data('saved-font', get_current_font(panel_content))
	if cliArgs.FILE:
		load_file(cliArgs.FILE)

def get_email_addresses_in_main_headers(h):
	return map(lambda x: x[1], getaddresses(Email.get_all(h) or []))

def email_from_file(filename):
	try:
		fh = open(filename, 'r')
	except IOError as e:
		display_error(e)
		act_quit()
		return
	eml = email.message_from_file(fh)
	fh.close()
	return eml

def load_file(filename):
	global Email
	global LeafParts
	Email = email_from_file(filename)
	update_window_title(win_main, filename, get_one_header_main('Subject'))
	
	senderaddr = None
	for h in OriginatorHeaders:
		addrs = get_email_addresses_in_main_headers(h)
		if len(addrs) > 0:
			senderaddr = addrs[0]
			break
	threading.Thread(target=load_gravatar, args=(senderaddr, panel_view_avatar)).start()
	
	if (Email[HDR_DNT] or '').strip():
		if get_xattr(cliArgs.FILE, XATTR_MDNSENT) is None:
			menubutton_mdn.show()
	if truish(get_xattr(cliArgs.FILE, XATTR_MDNSENT)):
		stck_mdn.show()
	if truish(get_xattr(cliArgs.FILE, XATTR_REPLIED)):
		stck_repl.show()
	if truish(get_xattr(cliArgs.FILE, XATTR_FORWARDED)):
		stck_fwd.show()
	
	if get_listaddress_main() is not None:
		menubutton_replytolist.show()
	if (Email['List-Unsubscribe'] or '').strip():
		menubutton_unsubscribe.show()
	
	panel_view_header.set_markup(get_headers_markup(Email))
	panel_view_subject.set_markup(PMU_SUBJ + glib.markup_escape_text(re.sub('\n', '', get_one_header_main('Subject') or '')) + PMU_SUBJ_CLOSE)
	clear_parts(Parts)
	load_parts(Email, Parts, Parts.get_iter_root())
	panel_parts.expand_all()
	if Email.is_multipart():
		if PartPrimary is not None:
			selection_parts.select_iter(PartPrimary)
		elif PartSecondary is not None:
			selection_parts.select_iter(PartSecondary)
		else:
			selection_parts.select_path((0,))
	else:
		selection_parts.select_path((0,))

	if LeafParts > 1:
		pos = panel_body.get_data('saved-position')
		if pos is not None:
			panel_body.set_position(pos)
			panel_body.set_data('saved-position', None)
	else:
		panel_body.set_data('saved-position', panel_body.get_position())
		panel_body.set_position(0)

def clear_parts(model):
	global LeafParts
	LeafParts = 0
	model.clear()

def load_parts(eml, model, parent):
	global PartPrimary
	global PartSecondary
	global LeafParts
	
	label = PMU_MIME + glib.markup_escape_text(eml.get_content_type()) + PMU_MIME_CLOSE
	filename = decode_mimetext(eml.get_filename())
	if filename is not None: label = glib.markup_escape_text(filename) + ' ' + label
	stock = get_stock_by_mime(eml.get_content_maintype(), eml.get_content_subtype())
	pixb = None
	
	iterator = model.append(parent, [eml, label, stock, pixb])
	# Note, buggy or incomplete Content-Type (eg. "Content-Type: pdf") is translated to text/plain by email module
	if PartPrimary is None and eml.get_content_type() == MIMETYPE_TEXT:
		PartPrimary = iterator
	if PartSecondary is None and eml.get_content_type() == MIMETYPE_HTML:
		PartSecondary = iterator
	if type(eml.get_payload()) == type([]):
		for part in eml.get_payload():
			load_parts(part, model, iterator)
	else:
		LeafParts += 1

def clear_content(s=''):
	bufr = panel_content.get_buffer()
	bufr.set_text(s)
	panel_content.set_sensitive(False)
	return bufr

def decode_readably(s, eml):
	charset = eml.get_content_charset()
	if charset is None: charset = 'utf-8'
	return s.decode(charset, 'replace')

def get_content_readably(eml):
	return decode_readably(get_content_any(eml), eml)

def get_content_any(eml):
	s = eml.get_payload(decode=True)
	# TODO preamble+epilogue instead of as_string?
	if s is None: s = eml.as_string()
	return s

def set_content_text(s):
	bufr = panel_content.get_buffer()
	bufr.set_text(s)
	if s != '' and bufr.get_text(bufr.get_start_iter(), bufr.get_end_iter(), True) == '':
		return False
	panel_content.set_sensitive(True)
	return True

def load_part(eml, filt=None):
	if eml is None: return
	clear_content(_("Loading failed"))
	panel_content.set_data('view-unfiltered', False)
	ct_main, ct_sub = eml.get_content_maintype(), eml.get_content_subtype()
	loaded_text = None
	
	if eml['Content-Location']:
		uri = eml['Content-Location']
		uri_esc = glib.markup_escape_text(uri)
		lbl_content_location.set_markup('%s <a href=\'%s\'>%s</a>' % (_("See Content here:"), uri_esc, uri_esc))
		lbl_content_location.show()
	else:
		lbl_content_location.hide()
	
	if filt is None:
		filt = get_filter_by_mime(ct_main, ct_sub)
	
	if filt is None:
		if type(eml.get_payload()) == type([]) and (eml.preamble is not None or eml.epilogue is not None):
			text = decode_readably('\n'.join([eml.preamble or '', eml.epilogue or '']), eml)
			set_content_text(text)
			loaded_text = text
		else:
			if ct_main == 'image':
				loader = gtk.gdk.PixbufLoader()
				loader.write(eml.get_payload(decode=True))
				loader.close()
				pxb = loader.get_pixbuf()
				panel_content_image.set_data('last-alloc', None)
				panel_content_image.set_data('pixbuf', pxb)
				panel_content_image.show()
#			elif ct_main == 'audio':
#				TODO
			else:
				label = _("Content type: %s%s%s") % (PMU_MIME, glib.markup_escape_text(eml.get_content_type()), PMU_MIME_CLOSE)
				filename = decode_mimetext(eml.get_filename())
				if filename is not None: label = (_("Filename: %s%s%s") % (PMU_NAME, glib.markup_escape_text(filename), PMU_NAME_CLOSE)) + '\n' + label
				label = label + '\n' + _("Size: %s" % human_size(len(eml.get_payload(decode=True))))
				lbl_right.set_markup(label)
				
				panel_btnbox.show()
				btn_open.show()
				btn_save.set_label(gtk.stock_lookup(gtk.STOCK_SAVE)[1])
			spanel_content.hide()
	else:
		cmd, args, binary = filt[:]
		if binary:
			content = get_content_any(eml)
		else:
			content = get_content_readably(eml)
		if cmd == '':
			panel_content.set_data('view-unfiltered', True)
			set_content_text(content) or clear_content(_("Loading failed"))
			loaded_text = content
		else:
			bufr = panel_content.get_buffer()
			bufr.set_text('')
			loaded_text = ''
			for s in pipereader(content, cmd, args):
				bufr.insert(bufr.get_end_iter(), s)
				loaded_text += s
			panel_content.set_sensitive(True)
		panel_btnbox.hide()
		panel_content_image.hide()
		spanel_content.show()
	if spanel_content.get_data('loaded-part') != eml:
		spanel_content.get_vadjustment().set_value(0.0)
	spanel_content.set_data('loaded-part', eml)
	if ct_main == 'text' and loaded_text is not None:
		spanel_content.set_data('last-loaded-text', loaded_text)

def on_allocate_panel_content_image(wdg, alloc):
	pxb = wdg.get_data('pixbuf')
	if pxb is not None:
		lastalloc = wdg.get_data('last-alloc')
		if lastalloc is None or alloc.width != lastalloc.width or alloc.height != lastalloc.height:
			wdg.set_data('last-alloc', alloc)
			B = wdg.get_border_width()
			W, H = alloc.width - B, alloc.height - B
			w0, h0 = pxb.get_width(), pxb.get_height()
			w = w0
			h = h0
			if W < w:
				w = W
				h = h0 * w / w0
			if H < h:
				h = H
				w = w0 * h / h0
			b = 5+B*2
			pxb = pxb.scale_simple(w - b, h - b, gtk.gdk.INTERP_BILINEAR)
			wdg.children()[0].set_from_pixbuf(pxb)

def resize_panel_view_header(wdg, rect=None):
	if not panel_view_header.get_data('all-headers'):
		if rect is None: rect = wdg.get_allocation()
		h, v = panel_view_header.get_padding()
		panel_view_header.set_size_request(rect.width - h - 4, -1)

def decode_mimetext(s):
	if s is not None:
		plain_str, encoding = email.header.decode_header(s)[0]
		return plain_str
	return s

def decode_header(s, unfold=False, eml=None):
	chunks = []
	for chars, encoding in email.header.decode_header(s):
		if encoding is None:
			if unfold:
				chars = re.sub('\r?\n\s*', ' ', chars)
			# encoding is not specified in this header
			# first try to decode in UTF-8
			# then guess by other available encodings in the email
			# lastly fall back to UTF-8 but mask unrecognizable chars
			encodings = ['utf-8']
			if eml:
				for _, part in walk_multipart(eml):
					m = re.search('\\bcharset=([a-z0-9_-]+)', part['Content-Type'] or '', re.I)
					if m:
						encodings.append(m.group(1))
			for encoding in encodings:
				try:
					chars.decode(encoding, 'strict')
					break
				except UnicodeDecodeError:
					encoding = None
			if encoding is None:
				encoding = 'utf-8'
		chunks.append(chars.decode(encoding, 'replace'))
	return ' '.join(chunks)

def get_one_header_main(hname, unfold=True):
	hval = Email[hname]
	if hval is None: return None
	return decode_header(hval, unfold=unfold, eml=Email)

def get_all_headers_main(hname):
	return map(lambda hdr: decode_header(hdr, eml=Email), Email.get_all(hname) or [])

def get_header_links(s, schemata=['mailto']):
	l = []
	uris = re.findall('<([^>]+)>', s)
	if len(uris) == 0:
		# workaround for poorly behaved mail lists
		uris = re.findall('^\s*(\S+)', s)
	for uri in uris:
		rslt = urlparse.urlsplit(uri)
		if '*' in schemata or rslt.scheme.lower() in schemata:
			q = dict((k.lower(), v if len(v)>1 else v[0]) for k, v in urlparse.parse_qs(rslt.query).iteritems())
			q['to'] = urlparse.unquote(rslt.path)
			q['uri'] = uri
			q['split'] = rslt
			l.append(q)
	return l

def get_mailto(s):
	l = get_header_links('<%s>' % (s))
	if len(l) > 0: return l[0]
	stderr(_("Can not parse mailto link: '%s'") % (s))
	return {}

def get_fskv(key):
	"""
	Filesystem as key-value store
	"""
	for t in (os.environ['HOME'], '.config', PROGNAME, key), (os.path.sep, 'etc', PROGNAME, key),:
		n = os.path.join(*t)
		fh = None
		try:
			fh = open(n, 'r')
		except IOError:
			pass
		if fh is not None:
			return ''.join(fh.readlines())
	return None

def load_gravatar(addr, container):
	if not isinstance(addr, str): return
	url = (get_fskv('avatar_url_template') or 'https://www.gravatar.com/avatar/{email_md5}?default=404&size=64&rating=G')\
		.format(email=addr.lower(), email_md5=hashlib.md5(addr.lower()).hexdigest())
	try:
		web = urllib2.urlopen(url)
	except urllib2.HTTPError:
		pass
	else:
		loader = gtk.gdk.PixbufLoader()
		try:
			loader.write(web.read())
			loader.close()
		except glib.GError as e:
			if e.code != 3:   # 'Unrecognized image file format'
				raise e
		else:
			pxb = loader.get_pixbuf()
			img = container.children()[0]
			img.set_from_pixbuf(pxb)
			container.show_all()

def get_listaddress_main():
	try:
		# Hopefully there is only one list address.
		listaddress = get_header_links(','.join(get_all_headers_main('List-Post') or []))[0]['to']
	except IndexError:
		listaddress = None
	except KeyError:
		listaddress = None
	return listaddress

def get_headers_markup(eml):
	lns = []
	hdrs = [
		"Return-Path",
		"X-X-Sender",
		"X-Sender",
		"Sender",
		"From",
		"Organization",
		"Reply-To",
		"Importance",
		"Priority",
		"X-Priority",  # @notranslate
		"X-MSMail-Priority",  # @notranslate
		"To",
		"Cc",
		"Date",
		"Reply-By",
		"Expires",
		"X-Spam",  # @notranslate
	]
	from_addresses = get_email_addresses_in_main_headers('From')
	for h in 'From', 'Sender', 'X-Sender', 'X-X-Sender':
		if eml[h] is not None:
			hdrs.remove('Return-Path')
			break
	
	for hname in hdrs:
		hvals_mu = []
		for hval in eml.get_all(hname) or []:
			hval = decode_header(hval, eml=eml)
			if hname != 'From' and hname in OriginatorHeaders:
				# Do not display Sender or Reply-To fields if they equal to From.
				addr = email.utils.parseaddr(hval)[1]
				if addr in from_addresses: continue
			if hname in RecipientHeaders or hname in OriginatorHeaders:
				list_mu = []
				for realname, addr in getaddresses([hval]):
					realname = decode_header(realname, eml=eml)
					addr_mu = glib.markup_escape_text(addr)
					mailto_link = urllib2.quote('"%s" <%s>' % (realname.replace('"', '\\"'), addr_mu)) if realname else addr_mu
					mu = '<a href=\'mailto:%s\'>%s</a>' % (mailto_link, addr_mu)
					if realname: mu = glib.markup_escape_text(realname) + ' ' + mu
					list_mu.append(mu)
				hval_mu = ', '.join(list_mu)
			elif hname in DateTimeHeaders:
				# Display Date field in local timezone.
				try:
					timestamp = email.utils.mktime_tz(email.utils.parsedate_tz(hval))
				except TypeError:
					timestamp = None
				else:
					hval = email.utils.formatdate(timestamp, True)
				hval_mu = glib.markup_escape_text(hval)
				if timestamp is not None and timestamp < time.time():
					if hname == 'Reply-By':
						wrn = _("Overdue")
					elif hname == 'Expires':
						wrn = _("(Expired)")
					try: hval_mu += ' ' + PMU_WARN + wrn + PMU_WARN_CLOSE
					except NameError: pass
			else:
				hval_mu = glib.markup_escape_text(hval)
			
			if hname == 'Importance' or hname.find('Priority')>-1:
				hval_lc = hval.lower()
				if hval_lc == 'urgent' or hval_lc.find('high')>-1 or re.search('^[12]', hval):
					# Show urgent, high priority headers emphasized.
					hval_mu = PMU_WARN + glib.markup_escape_text(hval) + PMU_WARN_CLOSE
					win_main.set_icon_name('mail-mark-important')
					stck_imp.show()
				elif hval_lc == 'non-urgent' or hval_lc.find('low')>-1 or re.search('^[45]', hval):
					stck_unimp.show()
				if not UserConfig.show_importance_headers:
					hval_mu = None
			
			if hname == 'X-Spam':
				if re.search(r'\b(no|undefined)\b', hval):
					pass
				else:
					stck_spam.show()
			
			if hval_mu is not None and len(hval_mu):
				hvals_mu.append(hval_mu)
		if len(hvals_mu):
			lns.append(PMU_HEAD + _(hname) + PMU_HEAD_CLOSE + ': ' + ', '.join(hvals_mu))
	return '\n'.join(lns)

def get_filters_by_mime(main, sub, all=True):
	filters = []
	for m, s, marks, cmd, args in cfgparser('filters', regex='^\s*([^;#][^\s/]*)/(\S+)\s+([!\$]*)(\S+)\s*(.+)?', splitgroups=[5]):
		if fnmatch(main, m) and fnmatch(sub, s):
			isbin = marks.find('!')>-1
			isshell = marks.find('$')>-1
			e = None
			if cmd == '-':
				e = ('', None, isbin)
			else:
				if isshell:
					e = ('sh', ['-c', ' '.join([cmd]+args)], isbin)
				else:
					if which(cmd):
						e = (cmd, args, isbin)
			if e is not None:
				if all:
					filters.append(e)
				else:
					return e
	if all:
		return filters
	return None

def get_filter_by_mime(main, sub):
	return get_filters_by_mime(main, sub, all=False)

def get_stock_by_mime(main, sub):
	assoc_main = {
		'multipart': gtk.STOCK_DIRECTORY,
		'message': 'emblem-mail',
	}
	assoc_full = {
		'application/pgp-signature': 'mail-signed',
		'application/ics': 'x-office-calendar',
		'text/calendar': 'x-office-calendar',
		'inode/directory': gtk.STOCK_DIRECTORY,
		'inode/x-empty': 'document-new',
	}
	full = main + '/' + sub
	
	if full == 'multipart/digest':
		return 'emblem-mail'
	if assoc_full.has_key(full):
		return assoc_full[full]
	elif assoc_main.has_key(main):
		return assoc_main[main]
	
	if full in [MIMETYPE_HTML]:
		return main + '-' + sub
	elif main in ['audio', 'image', 'font', 'package', 'text', 'video']:
		return main + '-x-generic'

	return gtk.STOCK_FILE

def sighandler(sign, frame):
	if sign == signal.SIGTERM:
		glib.idle_add(sig_term, priority=glib.PRIORITY_HIGH)

def sig_term():
	act_quit()
	return False

def act_quit():
	if win_comp.get_visible():
		act_close_edit()
	if win_comp.get_visible():
		return True
	win_main.hide()
	win_comp.hide()
	gtk.main_quit()
	return False

def act_close_edit():
	if not win_comp.get_data('email-sent') and not win_comp.get_data('is-saved'):
		if not question(_("Message is not saved.\nClose anyway?"), (None, gtk.STOCK_QUIT if cliArgs.compose else gtk.STOCK_CLOSE), (_("Continue Editing"), gtk.STOCK_EDIT)):
			return True
	win_comp.hide()
	if cliArgs.compose:
		win_main.hide()
		gtk.main_quit()
		return False
	else:
		toggle_rqdn.set_sensitive(True)
		return True

def act_button(func):
	if type(func) != type(()):
		func = (func,)
	if func[0] is not None:
		func[0](*func[1:])

def on_click_button(btn, func):
	act_button(func)
	return False

def on_press_button(btn, evt, func):
	if evt.type == gtk.gdk.BUTTON_PRESS:
		if evt.button == 3 or (evt.button == 1 and evt.state & gtk.gdk.SHIFT_MASK):
			act_button(func)
	return False

def open_comp_hdr_menu(widget, event):
	if event.button == 3 or (event.button == 1 and event.state & gtk.gdk.SHIFT_MASK):
		menu_add_header.popup(None, None, None, event.button, event.time)
		return True

def act_comp_hdr_menuitem(mi, hname=None):
	if hname is None:
		hname = mi.get_data('chname')
	if hname == '':
		menuitem_all_comp_hdr.set_active(True)
	on = mi.active if isinstance(mi, gtk.CheckMenuItem) else None
	box = add_composer_header__direct(hname)
	if on == False:
		box.cancel()
	else:
		glib.idle_add(box.scrollfocus, priority=glib.PRIORITY_DEFAULT_IDLE)
	return True

def act_all_comp_hdr(mi):
	show_advanced_comp_hdr(mi.active)

def act_tgl_comp_hdr():
	on = menuitem_all_comp_hdr.get_active()
	menuitem_all_comp_hdr.set_active(not on)
	show_advanced_comp_hdr(not on)

def show_advanced_comp_hdr(show=True):
	clear_composer_headers('', '')
	for n in range(0, len(panel_comp_header.children())):
		box = panel_comp_header.children()[n]
		if box.hntype == compose_header_box.HNTYPE_CUSTOM:
			if show:
				box.show()
			else:
				box.hide()

def add_composer_header__direct(hname, hval=None, manual_call=True):
	box = None
	for thisbox in panel_comp_header.children():
		if thisbox.hntype == compose_header_box.HNTYPE_LABEL and thisbox['name'] == hname:
			box = thisbox
			if hval is not None: box['value'] = hval
			break
	if box is None:
		if hval is None: hval = ''
		box = compose_header_box(hname, hval)
		panel_comp_header.pack_start(box, False, True)
		if box.hntype == compose_header_box.HNTYPE_MENU:
			for n in range(len(panel_comp_header.children())):
				if panel_comp_header.children()[n].hntype == compose_header_box.HNTYPE_CUSTOM:
					panel_comp_header.reorder_child(box, n)
					break
				# Ignore every 2nd child.
				n += 1
	if manual_call: box.focus()
	box.show_all()
	return box

def add_composer_header(hname, hval=None, manual_call=True):
	box = add_composer_header__direct(hname, hval, manual_call)
	box.tick_my_menuitem(1)
	return box

def add_composer_headers(hname, hvals, manual_call=True):
	for hval in hvals:
		add_composer_header(hname, hval, manual_call)

def reset_composer_headers(hname, hvals, manual_call=True):
	clear_composer_headers(hname)
	for hval in hvals:
		add_composer_header(hname, hval, manual_call)

def set_composer_header(hname, hval):
	for hbox in panel_comp_header.children():
		if hbox['name'] == hname:
			hbox['value'] = hval
			return hbox
	return add_composer_header(hname, hval)

def clear_composer_headers(hname, content=None):
	for box in panel_comp_header.children():
		if (hname is None or box['name'] == hname) and (content is None or content == box['value']):
			box.cancel(manual=False)

def composer_maintain_references_headers():
	references = get_one_header_main(HDR_REF)
	messageid = get_one_header_main(HDR_MID)
	if messageid is not None:
		if references is not None:
			references = references + ' ' + messageid
		else:
			references = messageid
	if references is not None:
		add_composer_header(HDR_REF, references, manual_call=False)

def composer_append_to_list_header(hname, hvals, delimiter=' '):
	hval = delimiter.join(filter(lambda x: x is not None, hvals))
	headers = get_composer_headers(hname)
	if len(headers) == 0:
		reset_composer_headers(hname, [hval])
	else:
		headers[-1] = delimiter.join([headers[-1], hval])
		reset_composer_headers(HDR_REF, headers, manual_call=False)

def composer_substract_from_list_header(hname, hvals, delimiter=' '):
	hvals = filter(lambda x: x is not None, hvals)
	headers = get_composer_headers(hname)
	for idx in reversed(range(len(headers))):
		newvalue = []
		for word in headers[idx].split(delimiter):
			if word in hvals:
				hvals.remove(word)
			else:
				newvalue.append(word)
		headers[idx] = delimiter.join(newvalue)
	reset_composer_headers(hname, headers, manual_call=False)

class compose_header_box(gtk.HBox):
	HNTYPE_LABEL, HNTYPE_MENU, HNTYPE_CUSTOM = range(3)
	
	def __init__(self, chname, val, hntype=None):
		assert isinstance(chname, str)
		assert isinstance(val, str) or isinstance(val, unicode)
		plus = True
		minus = True
		
		super(self.__class__, self).__init__(False, 2)
		if hntype is None:
			if chname in SenderHeaders:
				hntype = self.HNTYPE_LABEL
			elif chname in RecipientHeaders:
				hntype = self.HNTYPE_MENU
			else:
				hntype = self.HNTYPE_CUSTOM
		
		self.hntype = hntype
		if self.hntype == self.HNTYPE_CUSTOM:
			self.wdg_name = gtk.combo_box_entry_new_with_model(UnionHeadersStore, 0)
			self.wdg_name.connect('changed', self.on_name_changed)
		elif self.hntype == self.HNTYPE_MENU:
			self.wdg_name = gtk.Button()
			self.wdg_name.set_relief(gtk.RELIEF_NONE)
			self.wdg_name.connect('button-release-event', self.popup_rcpt_menu)
			self.wdg_name.connect('button-press-event', self.propagate_button_press_event)
		elif self.hntype == self.HNTYPE_LABEL:
			plus = False
			self.wdg_name = gtk.Label()
		self.pack_start(self.wdg_name, False, True)
		
		self.wdg_value = gtk.Entry()
		self.pack_start(self.wdg_value, True, True)
		self.wdg_value.connect('changed', self.on_value_changed)
		self.completer = gtk.EntryCompletion()
		self.wdg_value.set_completion(self.completer)
		self.completer.set_model(gtk.ListStore(str))
		self.completer.set_minimum_key_length(0)
		self.completer.set_text_column(0)
		
		self.btn_datetime = StockButton('', 'x-office-calendar', icon_size=gtk.ICON_SIZE_MENU)
		self.btn_datetime.set_relief(gtk.RELIEF_NONE)
		self.pack_start(self.btn_datetime, False, False)
		self.btn_datetime.connect('clicked', self.pick_datetime)
		self.btn_datetime.connect('button-press-event', self.propagate_button_press_event)
		
		if plus:
			self.btn_add = StockButton('', gtk.STOCK_ADD, icon_size=gtk.ICON_SIZE_MENU)
			self.pack_start(self.btn_add, False, False)
			self.btn_add.set_relief(gtk.RELIEF_NONE)
			self.btn_add.connect('clicked', self.duplicate)
			self.btn_add.connect('button-press-event', self.propagate_button_press_event)
		if minus:
			self.btn_del = StockButton('', gtk.STOCK_REMOVE, icon_size=gtk.ICON_SIZE_MENU)
			self.btn_del.set_relief(gtk.RELIEF_NONE)
			self.pack_start(self.btn_del, False, False)
			self.btn_del.connect('clicked', self.cancel)
			self.btn_del.connect('button-press-event', self.propagate_button_press_event)
		
		self['name'] = chname
		self['value'] = val
	
	def propagate_button_press_event(self, w, evt):
		self.parent.parent.parent.emit('button-press-event', evt)
	
	def pick_datetime(self, w):
		prompt_datetime(self.wdg_value)
	
	def showhide_pick_buttons(self):
		if self['name'] in DateTimeHeaders:
			self.btn_datetime.show()
		else:
			self.btn_datetime.hide()
	
	def on_name_changed(self, x=None):
		name = self['name']
		self.showhide_pick_buttons()
		if name in ValidatorHeaders.keys():
			self['validate'] = ValidatorHeaders[name]
		else:
			self['validate'] = None
		model = self.completer.get_model()
		model.clear()
		autocomplete_items = []
		if type(self['validate']) == list:
			autocomplete_items = self['validate'][:]
		else:
			try: autocomplete_items = self['validate']['autocomplete'][:]
			except (KeyError, TypeError): pass
		for text in autocomplete_items:
			model.append([text])
		self.on_changed()
	
	def on_value_changed(self, entry=None):
		if entry is None: entry = self.wdg_value
		bg_normal = entry.get_data('bg-normal')
		if not bg_normal:
			bg_normal = entry.get_style().base[gtk.STATE_NORMAL]
			entry.set_data('bg-normal', bg_normal)
		valid = self.validate()
		if valid:
			entry.modify_base(gtk.STATE_NORMAL, bg_normal)
			self['valid'] = True
		else:
			bg_invalid = gtk.gdk.Color('#FFA4A4')
			entry.modify_base(gtk.STATE_NORMAL, bg_invalid)
			self['valid'] = False
			self.point_out()
		self.on_changed()
		return False

	def on_changed(self):
		name = self['name']
		val = self['value']
		update_composer_toolbar_toggle_buttons()
		set_unsaved()
	
	def validate(self):
		if not self['validate']:
			return True
		text = self['value']
		if text == '':
			return True
		if type(self['validate']) == list:
			return (text in self['validate'] or '' in self['validate'])
		if self['validate'].has_key('require'):
			if not re.search(self['validate']['require'], text):
				return False
		if self['validate'].has_key('repetative'):
			remainder = text
			while True:
				m = re.match(self['validate']['repetative'], remainder)
				if m is not None:
					remainder = remainder[m.end():]
					if remainder == '':
						break
				else:
					return False
			if remainder != '':
				return False
		if self['validate'].has_key('all'):
			for regexp in self['validate']['all']:
				if not re.search(regexp, text):
					return False
		if self['validate'].has_key('one'):
			one = False
			for regexp in self['validate']['one']:
				if re.search(regexp, text):
					one = True
					break
			if not one:
				return False
		if self['validate'].has_key('deny'):
			for regexp in self['validate']['deny']:
				if re.search(regexp, text):
					return False
		return True
	
	def point_out(self):
		if self.hntype == self.HNTYPE_CUSTOM:
			menuitem_all_comp_hdr.set_active(True)
		self.focus()
		glib.idle_add(self.scrollfocus, priority=glib.PRIORITY_DEFAULT_IDLE)
	
	def popup_rcpt_menu(self, wdg, evt):
		if evt.button == 1:
			wdg.set_relief(gtk.RELIEF_NORMAL)
			mnu = gtk.Menu()
			mnu.connect('deactivate', self.popup_rcpt_menu_disappear, wdg)
			for chname in RecipientHeaders:
				mi = gtk.MenuItem(label=_(chname))
				mi.set_data('name', chname)
				mi.connect('activate', self.popup_rcpt_menuitem_activated, wdg)
				mnu.append(mi)
			mnu.show_all()
			mnu.popup(None, None, self.bottomleft, evt.button, evt.time, wdg)
			return True
		return False
	
	def popup_rcpt_menuitem_activated(self, mi, wdg):
		self['name'] = mi.get_data('name')
		self.popup_rcpt_menu_disappear(mi.parent, wdg)
	
	def popup_rcpt_menu_disappear(self, mnu, wdg):
		wdg.set_relief(gtk.RELIEF_NONE)
		self.focus()
	
	def bottomleft(self, mnu, wdg):
		X, Y = self.window.get_origin()
		x, y, w, h = wdg.get_allocation()
		mx = X + x
		my = Y + y + h
		return (mx, my, True)
	
	def show_all(self):
		super(self.__class__, self).show_all()
		if self.hntype == self.HNTYPE_CUSTOM and not menuitem_all_comp_hdr.get_active():
			self.hide()
		self.showhide_pick_buttons()
	
	def duplicate(self, evtwdg=None):
		newbox = self.__class__(self['name'], self['value'], hntype=self.hntype)
		self.parent.pack_start(newbox, False, True)
		newbox.show_all()
		newbox.focus()
		for n in range(0, len(self.parent.children())):
			if self.parent.children()[n] == self:
				self.parent.reorder_child(newbox, n)
	
	def cancel(self, evtwdg=None, manual=True):
		if self['name'] and self['value']:
			set_unsaved()
		if self.hntype == self.HNTYPE_LABEL:
			self.hide()
			self.tick_my_menuitem(0)
			if not manual:
				self['value'] = ''
		else:
			if manual and self.hntype == self.HNTYPE_MENU:
				n = 0
				for x in self.parent.children():
					if x.hntype == self.HNTYPE_MENU: n += 1
					if n > 1: break
				if n < 2: return False
			self.parent.remove(self)
			update_composer_toolbar_toggle_buttons()
	
	def tick_my_menuitem(self, on):
		for mi in menu_add_header.children():
			if mi.get_data('chname') == self['name']:
				mi.set_active(on)
				break
	
	def focus(self):
		if not self.wdg_value.has_focus():
			self.wdg_value.grab_focus()
			self.wdg_value.set_position(-1)
	
	def scrollfocus(self):
		if self.get_visible():
			scrwin = self.parent.parent
			cntnr = scrwin.child
			vadj = scrwin.get_vadjustment()
			wdg = win_comp.get_focus()
			
			if wdg is not None:
				wleft, wtop = wdg.translate_coordinates(cntnr, 0, 0)
				wbottom = wtop + wdg.get_allocation().height
				top = vadj.value
				bottom = top + vadj.page_size
				if wtop < top:
					vadj.value = wtop
				elif wbottom > bottom:
					vadj.value = wbottom - vadj.page_size
	
	def __getitem__(self, key):
		if key == 'name':
			if self.hntype == self.HNTYPE_CUSTOM:
				it = self.wdg_name.get_active_iter()
				if it is not None:
					return self.wdg_name.get_model().get_value(it, 0)
				else:
					return self.wdg_name.children()[0].get_text()
			else:
				return self.wdg_name.get_data('name')
		elif key == 'value':
			return self.wdg_value.get_text()
		elif key == 'readonly':
			return not self.wdg_value.get_sensitive()
		elif key in ['validate', 'valid']:
			return self.wdg_value.get_data(key)
		else:
			raise IndexError()
	
	def __setitem__(self, key, newvalue):
		if key == 'name':
			old = self[key]
			self.wdg_name.set_data('name', newvalue)
			if self.hntype == self.HNTYPE_CUSTOM:
				self.wdg_name.children()[0].set_text(newvalue)
			else:
				self.wdg_name.set_data('name', newvalue)
				self.wdg_name.set_label(_(newvalue))
			if old != newvalue:
				self.on_name_changed()
		elif key == 'value':
			self.wdg_value.set_text(newvalue)
		elif key == 'readonly':
			self.wdg_name.set_sensitive(not newvalue)
			self.wdg_value.set_sensitive(not newvalue)
		elif key == 'validate':
			self.wdg_value.set_data(key, newvalue)
			self.on_value_changed()
		elif key == 'valid':
			assert isinstance(newvalue, bool)
			self.wdg_value.set_data(key, newvalue)
		else:
			raise IndexError()


class Clock(gtk.HBox):
	def __init__(self):
		super(self.__class__, self).__init__()
		self.spin_hour = gtk.SpinButton()
		self.spin_minute = gtk.SpinButton()
		self.spin_second = gtk.SpinButton()
		self.spin_hour.set_range(0, 23)
		self.spin_minute.set_range(0, 59)
		self.spin_second.set_range(0, 59)
		self.spin_hour.set_increments(1, 6)
		self.spin_minute.set_increments(1, 15)
		self.spin_second.set_increments(1, 15)
		self.spin_hour.set_wrap(True)
		self.spin_minute.set_wrap(True)
		self.spin_second.set_wrap(True)
		self.spin_hour.set_numeric(True)
		self.spin_minute.set_numeric(True)
		self.spin_second.set_numeric(True)
		self.select_time()
		self.pack_start(self.spin_hour, False, False)
		self.pack_start(gtk.Label(':'), False, False)
		self.pack_start(self.spin_minute, False, False)
		self.pack_start(gtk.Label(':'), False, False)
		self.pack_start(self.spin_second, False, False)
		self.show_all()
	
	def select_time(self, ts=None):
		t = time.localtime(ts)
		self.spin_hour.set_value(t.tm_hour)
		self.spin_minute.set_value(t.tm_min)
		self.spin_second.set_value(t.tm_sec)
	
	def get_time(self):
		return (self.spin_hour.get_value_as_int(), self.spin_minute.get_value_as_int(), self.spin_second.get_value_as_int())

def prompt_datetime(entry):
	def select_datetime(ts=None):
		y, m, d, x, x, x, x, x, x = time.localtime(ts)
		calendar.select_month(m-1, y)
		calendar.select_day(d)
		clock.select_time(ts)
	dlg = gtk.MessageDialog(get_current_window(), gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_OTHER, gtk.BUTTONS_OK_CANCEL, _("Select Date and Time in local TimeZone"))
	calendar = gtk.Calendar()
	clock = Clock()
	dt = email.utils.parsedate_tz(entry.get_text())
	if dt is not None:
		select_datetime(email.utils.mktime_tz(dt))
	cbox = dlg.get_content_area()
	cbox.pack_start(calendar, True, True)
	cbox.pack_start(clock, True, True)
	btn_now = StockButton(_("Now"), gtk.STOCK_JUMP_TO)
	btn_now.connect('clicked', lambda x: select_datetime())
	abox = dlg.get_action_area()
	abox.pack_start(btn_now, False, False)
	dlg.show_all()
	resp = dlg.run()
	if resp == gtk.RESPONSE_OK:
		y, m, d = calendar.get_date()
		H, M, S = clock.get_time()
		entry.set_text(email.utils.formatdate(time.mktime((y, m+1, d, H, M, S, -1, -1, -1)), True))
	dlg.destroy()

def get_composer_headers(hname):
	hlist = []
	for hbox in panel_comp_header.children():
		if hbox['name'] not in SenderHeaders or hbox.get_visible():
			if hname is None:
				hlist.append((hbox['name'], hbox['value']))
			elif type(hname) == type([]) and hbox['name'] in hname:
				hlist.append(hbox['value'])
			elif hbox['name'] == hname:
				hlist.append(hbox['value'])
	return hlist

def set_composer_subject(s):
	entry_subject.set_text(s)

def get_composer_subject():
	return entry_subject.get_text()

def on_edit_subject(wdg):
	update_window_title(win_comp, win_comp.get_data('saved-to-file'), entry_subject.get_text())
	set_unsaved()
	timer_once('update_composer_status_message', 5, update_composer_status_message)

def on_change_message(wdg):
	timer_once('update_composer_status_message', 5, update_composer_status_message)

def set_composer_text(s):
	bufr = panel_edit_message.get_buffer()
	bufr.set_text(s)
	bufr.place_cursor(bufr.get_start_iter())

def get_composer_text():
	bufr = panel_edit_message.get_buffer()
	return bufr.get_text(bufr.get_start_iter(), bufr.get_end_iter(), True)

def open_composer():
	if win_comp.get_visible():
		act_close_edit()
	if win_comp.get_visible():
		win_comp.set_urgency_hint(True)
		win_comp.present()
		win_comp.set_urgency_hint(False)
		return False
	
	global NewEmail
	NewEmail = MIMEMultipart('mixed')
	win_comp.set_data('preserve-headers', map(lambda x: x[0].lower(), NewEmail._headers))
	NewEmail.preamble = PREAMBLE
	part0 = MIMEText('')
	part0.set_charset('UTF-8')
	part0.replace_header(HDR_CTE, '')
	NewEmail.attach(part0)
	Attachments.clear()
	
	win_comp.show_all()
	panel_edit_message.set_data('saved-font', get_current_font(panel_edit_message))
	menuitem_all_comp_hdr.set_active(False)
	clear_composer_headers(None)
	add_composer_From_hidden()
	for h in SenderHeaders:
		add_composer_header(h).cancel()
	set_composer_subject('')
	set_composer_text('')

	win_comp.set_data('is-an-mdn', False)
	win_comp.set_data('set-xattr-on-send', [])
	win_comp.set_data('saved-to-file', None)
	on_after_save_draft()
	return True

def quote_message():
	if spanel_content.get_data('last-loaded-text') is not None:
		return re.sub('^', '> ', re.sub('\r', '', spanel_content.get_data('last-loaded-text')), 0, re.MULTILINE)
	return ''

def get_gecos_name():
	return re.sub(',.*,.*,.*', '', pwd.getpwuid(os.getuid()).pw_gecos)

def get_user_signature():
	try:
		sign = ''.join(open(os.path.join(os.environ['HOME'], '.signature'), 'r').readlines())
		sign = re.sub('\n?$', '\n', sign)
	except:
		sign = '--\n' + get_gecos_name() + '\n'
	return sign

def filter_out_addresses(noaddrs, hvals):
	filtered = []
	for realname, addr in getaddresses(hvals):
		if addr not in noaddrs:
			filtered.append(email.utils.formataddr((realname, addr)))
	return filtered

def add_composer_agent_headers():
	add_composer_header('User-Agent', USERAGENT)
	add_composer_header('X-Mailer', USERAGENT)

def add_composer_mailto(mailto):
	for h in 'To', 'Cc', 'Bcc':
		k = h.lower()
		if mailto.has_key(k):
			# urlparse.parse_qs() in get_header_links() may turn GET parameters 
			# (eg. "?cc[]=foo&cc[]=bar") into arrays, so handle them like comma-
			# delimited addresses
			v = ','.join(mailto[k]) if hasattr(mailto[k], '__iter__') else mailto[k]
			recipient_list = []
			for x in v.split(','): recipient_list.append(x)
			add_composer_headers(h, recipient_list)
	if mailto.has_key('subject'):
		set_composer_subject(mailto['subject'])
	if mailto.has_key('body'):
		set_composer_text(mailto['body'])

def guess_my_address():
	if Email is None: return None
	return get_one_header_main('Envelope-To') or get_one_header_main('Delivered-To')

def guess_reply_address():
	if Email is None: return None
	for h in ['Reply-To', 'From', 'Sender', 'X-Sender', 'X-X-Sender']:
		if Email[h] is not None:
			return get_one_header_main(h)
	return None

def add_composer_From_hidden():
	addr = guess_my_address()
	if addr is not None:
		name = get_gecos_name()
		box = add_composer_header('From', email.utils.formataddr((name, addr)))
		box.cancel()
		return True
	return False

def act_compose():
	if open_composer():
		add_composer_agent_headers()
		add_composer_header('To', '')
		set_composer_subject('')
		set_composer_text('\n\n' + get_user_signature())
		on_after_save_draft()
		panel_edit_message.grab_focus()

def act_reply(recip):
	if open_composer():
		add_composer_agent_headers()
		subj = get_one_header_main('Subject') or ''
		body = '\n\n' + get_user_signature()
		my_address = guess_my_address()
		
		if recip == '':
			win_comp.set_data('set-xattr-on-send', [XATTR_FORWARDED])
			fwdname = (subj or _("Email")) + '.eml'
			pre = _("Fwd: ")
			if not subj.lower().startswith(pre.lower()): subj = pre + subj
			set_composer_subject(subj)
			add_composer_header('To', '')
			composer_maintain_references_headers()
			
			part = MIMEMessage(Email)
			part.add_header(HDR_CD, 'attachment', filename=fwdname)
			# TODO - remove sensitive headers?
			NewEmail.attach(part)
			Attachments.append(None, [part, fwdname, 'emblem-mail', None])
		else:
			win_comp.set_data('set-xattr-on-send', [XATTR_REPLIED])
			add_composer_header('Thread-Topic', get_one_header_main('Thread-Topic') or subj)
			pre = _("Re: ")
			if not subj.lower().startswith(pre.lower()): subj = pre + subj
			set_composer_subject(subj)
			body += '\n' + _("Quote:") + '\n\n' + quote_message()
			
			messageid = get_one_header_main(HDR_MID)
			add_composer_header('In-Reply-To', messageid)
			composer_maintain_references_headers()
			
			reply_fulladdress = guess_reply_address()
			reply_address = email.utils.parseaddr(reply_fulladdress)[1]
			listaddress = get_listaddress_main()
			
			if recip == 'one':
				add_composer_header('To', reply_fulladdress or '')
			elif recip == 'all':
				skip_addresses = [my_address, reply_address, '']
				rcpt_addresses = []
				
				if reply_address != '' and reply_address != my_address:
					add_composer_header('To', reply_fulladdress)
				for h in 'To', 'Cc':
					for addrspec in filter_out_addresses(skip_addresses, get_all_headers_main(h)):
						# get_all_headers_main() gives back realnames decoded
						add_composer_header(h, addrspec)
						rcpt_addresses.append(email.utils.parseaddr(addrspec)[1])
				if listaddress is not None and listaddress not in rcpt_addresses:
					add_composer_header('To', listaddress)
			elif recip == 'list':
				add_composer_header('To', listaddress)
		
		set_composer_text(body)
		on_after_save_draft()
		panel_edit_message.grab_focus()

def shorturl(url, maxlength=72):
	if len(url) > maxlength:
		return url[0:maxlength-1] + ''
	else:
		return None

def act_unsubscribe():
	links = get_header_links(','.join(Email.get_all('List-Unsubscribe')), schemata=['mailto', 'http', 'https', '*'])
	if len(links) == 1 and links[0]['split'].scheme == 'mailto':
		if open_composer():
			add_composer_mailto(links[0])
			on_after_save_draft()
	else:
		text = ''
		for link in links:
			uri = urlparse.unquote(link['uri'])
			escuri = glib.markup_escape_text(uri)
			if link['split'].scheme == 'mailto':
				linktext = link['to']
			else:
				short = shorturl(uri, 80)
				if short is None:
					linktext = escuri
				else:
					linktext = glib.markup_escape_text(short)
			text += '\n\n<a href=\'%s\'>%s</a>' % (escuri, linktext)
		dlg = gtk.MessageDialog(win_main, gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_OTHER, gtk.BUTTONS_CLOSE)
		dlg.set_title(_("Unsubscribe"))
		dlg.set_markup(_("Select a link to unsubscribe") + '\n\n' + _("Beware, open links only from trusted source. Spammers know their spam reached target if you follow fake unsubscribe links.") + text)
		try:
			label = dlg.get_content_area().children()[0].children()[1].children()[0]
			label.set_selectable(False)
			dlg.get_action_area().children()[0].grab_focus()
		except: pass
		dlg.run()
		dlg.destroy()

def scroll_textview(tv, rect, scrwin):
	vadj = scrwin.get_vadjustment()
	vadj.set_value(vadj.upper - vadj.page_size)

def act_report_spam(considered_as_spam = True):
	emailfile = os.path.abspath(cliArgs.FILE)
	run_async('gemlv-report-%s' % 'spam' if considered_as_spam else 'ham', [emailfile], None)

def runcmd_thread(args, input_fd, out_buffer, vb):
	reader, writer = get_pipe_handlers(1)
	pid = os.fork()
	if pid == 0:
		reader.close()
		os.dup2(input_fd, sys.stdin.fileno())
		os.dup2(writer.fileno(), sys.stdout.fileno())
		os.dup2(writer.fileno(), sys.stderr.fileno())
		os.closerange(3, 255)
		try:
			os.execvp(args[0], args)
		except OSError as e:
			stderr(str(e))
		os._exit(127)
	
	writer.close()
	while True:
		ln = reader.readline()
		if ln == '': break
		gtk.threads_enter()
		out_buffer.insert(out_buffer.get_end_iter(), ln)
		gtk.threads_leave()
	reader.close()
	status = WaitExecStatus(pid)

	gtk.threads_enter()
	out_buffer.insert(out_buffer.get_end_iter(), _("exit code: %s") % (status.code))
	out_buffer.set_data('process-exit-status', status)
	glib.idle_add(lambda: finished_razor_thread(vb), priority=glib.PRIORITY_DEFAULT_IDLE)
	gtk.threads_leave()

def get_extension_by_mime(mime):
	if mime is None:
		e = None
	elif mime.startswith('multipart/'):
		e = '.eml'
	else:
		e = guess_extension(mime)
	if e is None:
		e = '.dat'
	return e

def get_mime_by_filepath(path):
	t = get_xattr(path, XATTR_TYPE)
	if t is None or t.find('/')<1:
		t = Magic.file(os.path.realpath(path))
		if t is None or t.find('/')<1:
			return MIMETYPE_OCTETSTREAM
	return t

def get_mime_by_data(data):
	return Magic.buffer(data)

def act_open():
	eml = get_part_by_itpath()
	if eml is None: return
	mime = eml.get_content_type()
	fd, tmppath = mkstemp(prefix = PROGNAME + '-', suffix = get_extension_by_mime(mime))
	try:
		save_to_filedescriptor(eml, fd)
		fh = os.fdopen(fd, 'r')
		set_xattrs(fh, {XATTR_CHARSET: eml.get_content_charset(), XATTR_TYPE: mime}, tmppath)
		fh.close()
	except OSError as e:
		os.unlink(tmppath)
		e.filename = tmppath
		display_error(e)
		return
	run_async(cliArgs.opener, cliArgs.opener_args + [tmppath], [os.unlink, tmppath])

def basenameify(s):
	# Replace ASCII slash (/) to a similar multibyte char (U+2215 DIVISION SLASH)
	return s.replace('/', u'\u2215')

def calc_attachment_name(part, n=None):
	name = decode_mimetext(part.get_filename())
	if name is None:
		sfx = ''
		if n is not None: sfx = '-' + str(n)
		name = "%s - attachment%s%s" % (basenameify(get_one_header_main('Subject') or _("Email")), sfx, get_extension_by_mime(part.get_content_type()))
	return name

def part_filename_by_iteratorpath(itpath, prefix='part', add_extension=True, add_subject=False):
	part = Parts[itpath][0]
	fname = decode_mimetext(part.get_filename())
	if fname is None:
		fname = ''
		if add_subject:
			fname += basenameify(get_one_header_main('Subject') or '')
			if fname:
				fname += ' - '
		oid = '-'.join(map(str, itpath))
		fname += '%s-%s' % (prefix, oid)
		if add_extension not in [False, None]:
			if add_extension is True:
				fname += get_extension_by_mime(part.get_content_type())
			else:
				fname += '.' + add_extension
	return fname

def act_save_struct():
	itpaths = selection_parts.get_selected_rows()[1]
	savedir = choose_save_folder()
	if savedir is not None:
		for n in range(len(itpaths)):
			act_save_struct_inner(savedir, Parts.get_iter(itpaths[n]))

def act_save_struct_inner(savedir, iterator):
	part = Parts[iterator][0]
	itpath = Parts.get_path(iterator)
	myname = decode_mimetext(part.get_filename())
	if myname is not None:
		myname = os.path.basename(myname)
	if Parts.iter_has_child(iterator):
		if myname is None:
			myname = part_filename_by_iteratorpath(itpath, prefix='multipart', add_extension=False)
		body = part.get_payload(decode=True)
		if body is None and (part.preamble is not None or part.epilogue is not None):
			savefile = os.path.join(savedir, part_filename_by_iteratorpath(itpath, prefix='part', add_extension='txt'))
			save_to_file(part, savefile, consider_preamble=True)
		mysavedir = os.path.join(savedir, myname)
		try:
			mkdir(mysavedir)
		except OSError as e:
			display_error(e)
		else:
			for nth in range(0, Parts.iter_n_children(iterator)):
				subiter = Parts.iter_nth_child(iterator, nth)
				act_save_struct_inner(mysavedir, subiter)
			moddatetime = get_header_parameter(part[HDR_CD], 'modification-date')
			posixmode = get_header_parameter(part[HDR_CD], 'posix-mode')
			try:
				if moddatetime:
					mod_timestamp = email.utils.mktime_tz(email.utils.parsedate_tz(moddatetime))
					os.utime(mysavedir, (-1, mod_timestamp))
				if posixmode:
					os.chmod(mysavedir, int(posixmode, 8))
			except OSError as e:
				display_error(e)
	else:
		if myname is None:
			body = part.get_payload(decode=True)
			if body is None or len(body) == 0:
				# Skip empty noname parts.
				return
			myname = part_filename_by_iteratorpath(itpath, prefix='part', add_extension=True)
		savefile = os.path.join(savedir, myname)
		save_to_file(part, savefile)

def act_save():
	itpaths = selection_parts.get_selected_rows()[1]
	if len(itpaths) == 1:
		itpath = itpaths[0]
		eml = get_part_by_itpath(itpath)
		savefile = choose_save_file(calc_attachment_name(eml))
		if savefile is not None:
			save_to_file(eml, savefile)
	elif len(itpaths) > 1:
		savedir = choose_save_folder()
		if savedir is not None:
			for n in range(0, len(itpaths)):
				eml = get_part_by_itpath(itpaths[n])
				basename = calc_attachment_name(eml, n)
				savefile = os.path.join(savedir, basename)
				save_to_file(eml, savefile)

def get_xattr(file_, attrname):
	if xattr is not None:
		try:
			return xattr.getxattr(file_, attrname)
		except IOError as e:
			if e.errno not in [os.errno.ENODATA, os.errno.ENOTSUP, os.errno.ENOSYS]:
				raise e
	return None

def set_xattrs(fh, attrs, filename='-'):
	allok = True
	if xattr is not None:
		for attrname, attrval in attrs.iteritems():
			try:
				if attrval is None:
					xattr.removexattr(fh, attrname)
				else:
					xattr.setxattr(fh, attrname, attrval)
			except IOError as e:
				stderr(_("Notice: can not set xattr '%s' on '%s': %s") % (attrname, filename, str(e)))
				allok = False
				if e.errno not in [os.errno.ENODATA, os.errno.ENOTSUP, os.errno.ENOSYS]:
					raise e
	return allok

def save_to_file(eml, filename, ask_overwrite=True, consider_preamble=False):
	if ask_overwrite:
		if os.path.lexists(filename):
			if not question(_("This file already exists:\n%s\nOverwrite?") % (os.path.basename(filename)), (None, gtk.STOCK_SAVE)):
				return None
	try:
		if eml.get_content_type() == MIMETYPE_SYMLINK:
			link_target = eml.get_payload(decode=True)
			os.symlink(link_target, filename)
		else:
			fh = open(filename, 'w')
			fd = fh.fileno()
			save_to_filedescriptor(eml, fd, consider_preamble)
			if eml.get_content_maintype() == 'multipart':
				mimetype = MIMETYPE_EMAIL
			else:
				mimetype = eml.get_content_type()
			messageid = eml[HDR_MID]
			if not messageid and hasattr(Email, '__getitem__'):
				messageid = Email[HDR_MID]
			set_xattrs(fh, {XATTR_CHARSET: eml.get_content_charset(), XATTR_TYPE: mimetype, XATTR_ORIGIN: messageid}, filename)
			fh.flush()
			moddatetime = get_header_parameter(eml[HDR_CD], 'modification-date')
			posixmode = get_header_parameter(eml[HDR_CD], 'posix-mode')
			if moddatetime:
				mod_timestamp = email.utils.mktime_tz(email.utils.parsedate_tz(moddatetime))
				futimes(fd, (-1, mod_timestamp))
			if posixmode:
				os.fchmod(fd, int(posixmode, 8))
			fh.close()
		return True
	except IOError as e:
		display_error(e)
	except OSError as e:
		e.filename = filename
		display_error(e)
	return False

def save_to_filedescriptor(eml, fd, consider_preamble=False):
	s = eml.get_payload(decode=True)
	if s is None:
		if consider_preamble:
			s = '\n'.join([eml.preamble or '', eml.epilogue or ''])
		else:
			s = eml.as_string()
	written = os.write(fd, s)
	if written != len(s):
		raise OSError(5, 'Write Error')
	os.fdatasync(fd)

def act_view_source():
	if panel_content.get_data('view-unfiltered'):
		filt = None
	else:
		filt = ('', None, False)
	load_part(get_part_by_itpath(), filt)

def act_wrap(tv, i=1):
	modes = cyclelist([gtk.WRAP_WORD, gtk.WRAP_WORD_CHAR, gtk.WRAP_NONE], at=tv.get_wrap_mode())
	tv.set_wrap_mode(modes.turn(i))

def get_current_font(txtv):
	pctx = txtv.get_pango_context()
	fdsc = pctx.get_font_description()
	s = fdsc.to_string()
	m = re.search('\s(\d+)(\s|$)', s)
	if m: pt = int(m.group(1))
	else: pt = 12
	return {'family': fdsc.get_family().lower(), 'string': s.lower(), 'size': pt, 'desc': fdsc,}

def act_font_switch(tv):
	font = get_current_font(tv)
	if font['family'] != 'monospace':
		tv.set_data('saved-font', font)
		f = tv.get_data('saved-font-monospace')
		if f is None: f = 'monospace 12'
		else: f = f['string']
	else:
		f = tv.get_data('saved-font')['string']
	change_font(tv, f)

def act_font(tv):
	dlg = gtk.FontSelectionDialog(_("Select Font"))
	dlg.set_transient_for(get_current_window())
	dlg.set_modal(True)
	dlg.set_font_name(tv.get_data('saved-font')['string'])
	if dlg.run() == gtk.RESPONSE_OK:
		font_name = dlg.get_font_name()
		change_font(tv, font_name)
		font = get_current_font(tv)
		if font['family'] == 'monospace':
			key = 'saved-font-monospace'
		else:
			key = 'saved-font'
		tv.set_data(key, font)
	dlg.destroy()

def on_scroll_on_button_font(wdg, evt, textview, modmask):
	if modmask is None or (evt.state & modmask) != 0:
		delta = +1 if evt.direction == gtk.gdk.SCROLL_UP else -1
		pctx = textview.get_pango_context()
		font = pctx.get_font_description()
		font.set_size(font.get_size() + delta * pango.SCALE)
		textview.modify_font(font)
		return True

def change_font(tv, s):
	tv.modify_font(pango.FontDescription(s))

def on_select_parts(selection):
	itpaths = selection.get_selected_rows()[1]
	if len(itpaths) > 1:
		panel_btnbox.show()
		lbl_right.set_markup(_("Multiple (%s) selected attachments") % (len(itpaths)))
		btn_open.hide()
		btn_save.set_label(_("Save All"))
		panel_content_image.hide()
		spanel_content.hide()
		btn_open2.set_sensitive(False)
		btn_save2.set_sensitive(True)
		menubutton_filters.set_sensitive(False)
	else:
		panel_btnbox.hide()
		panel_content_image.hide()
		spanel_content.show()
		if len(itpaths) == 1:
			btn_open2.set_sensitive(True)
			btn_save2.set_sensitive(True)
			itpath = itpaths[0]
			eml = get_part_by_itpath(itpath)
			load_part(eml)
			menubutton_filters.set_sensitive(True)
			populate_filters_menu(eml)
		else:
			btn_open2.set_sensitive(False)
			btn_save2.set_sensitive(False)
			clear_content()
			menubutton_filters.set_sensitive(False)

def act_show_view_headers(chkmi):
	show_view_headers(chkmi.active)

def show_view_headers(show=True):
	if show:
		spanel_view_header.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
		panel_view_header.set_size_request(-1, -1)
		panel_view_header.set_line_wrap(False)
		s = ''
		for hname, hval in Email._headers:
			hval = decode_header(hval, eml=Email)
			s += PMU_HEAD + glib.markup_escape_text(hname) + PMU_HEAD_CLOSE + ': ' + glib.markup_escape_text(hval) + '\n'
		panel_view_header.set_markup(s)
	else:
		spanel_view_header.set_policy(gtk.POLICY_NEVER, gtk.POLICY_AUTOMATIC)
		resize_panel_view_header(spanel_view_header)
		panel_view_header.set_line_wrap(True)
		panel_view_header.set_markup(get_headers_markup(Email))
	panel_view_header.set_data('all-headers', show)

def populate_header_menu(label, menu):
	menu.append(gtk.SeparatorMenuItem())
	mi = gtk.CheckMenuItem(_("Show All Headers"))
	mi.set_active(panel_view_header.get_data('all-headers') == True)
	if panel_view_header.get_data('all-headers'): mi.set_active(True)
	mi.connect('toggled', act_show_view_headers)
	menu.append(mi)
	menu.show_all()

def populate_filters_menu(eml):
	for mi in menu_filters.children():
		menu_filters.remove(mi)
	uniqfilt = {}
	for filt in get_filters_by_mime(eml.get_content_maintype(), eml.get_content_subtype()):
		if filt[0] == '': continue
		if uniqfilt.has_key(filt[0]) and uniqfilt[filt[0]] == filt[1]: continue
		uniqfilt[filt[0]] = filt[1]
		lbl = filt[0]
		if lbl == 'sh':
			lbl = ' '.join(re.findall('(^\S+|\d*[<>]+(?:&\d+|\s*\S+)|[;\|&]+\s*\S+)', filt[1][1]))
		mi = gtk.MenuItem(lbl)
		mi.connect('activate', lambda mi, eml, filt: load_part(eml, filt), eml, filt)
		menu_filters.append(mi)
	menu_filters.show_all()
	disable_filters_menu(True if len(menu_filters.children()) == 0 else False)

def disable_filters_menu(b=True):
	menubutton_filters.children()[0].children()[1].set_sensitive(not b)

def get_part_by_itpath(itpath = None):
	if itpath is None:
		try:
			itpath = selection_parts.get_selected_rows()[1][0]
		except IndexError:
			return None
	model = Parts
	return model.get_value(model.get_iter(itpath), 0)

def load_toolitems(toolbar, toolitems):
	items = []
	for label, stock, tip, fnc_left, fnc_right in toolitems:
		hid = None
		if type(fnc_left) == str:
			tbi = gtk.SeparatorToolItem()
			if fnc_left == 'space':
				tbi.set_draw(False)
				tbi.set_expand(True)
			elif fnc_left == 'separator':
				tbi.set_draw(True)
				tbi.set_expand(False)
		elif isinstance(stock, gtk.ToolItem):
			tbi = stock
			if tip is not None:
				tbi.set_tooltip_text(_(tip))
			try:
				hid = tbi.connect('clicked', on_click_button, fnc_left)
			except TypeError:
				# this ToolItem does not upport 'clicked' signal
				pass
		else:
			Lstocklabel = None
			st = gtk.stock_lookup(stock)
			if st:
				Lstocklabel = re.sub('_', '', st[1])
			if label is not None:
				Llabel = _(label)
			else:
				Llabel = Lstocklabel
			if tip is not None:
				Ltip = _(tip)
			else:
				if label is not None:
					Ltip = Llabel
				else:
					Ltip = Lstocklabel
			if fnc_left is None and fnc_right is None:
				tbi = gtk.ToolItem()
				tbi.set_border_width(3)
				tbi.add(gtk.image_new_from_icon_name(stock, toolbar.get_icon_size()))
				tbi.set_tooltip_text(Ltip)
			else:
				tbi = StockToolButton(label=Llabel, stock=stock, tooltip=Ltip)
				tbi.set_data('stock', stock)
				tbi.set_data('label', label)
				hid = tbi.connect('clicked', on_click_button, fnc_left)
				tbi.child.connect('button-press-event', on_press_button, fnc_right)
		tbi.set_data('clicked-handler', hid)
		toolbar.insert(tbi, -1)
		items.append(tbi)
	return items

def setup_treeview__icon_label(tv, label_edit_cb=None):
	colnum_txt = 1
	tvc = gtk.TreeViewColumn()
	tv.append_column(tvc)
	cr_pix = gtk.CellRendererPixbuf()
	cr_txt = gtk.CellRendererText()
	if label_edit_cb is not None:
		cr_txt.set_property('editable', True)
		cr_txt.connect('edited', label_edit_cb, colnum_txt)
	tvc.pack_start(cr_pix, False)
	tvc.pack_start(cr_txt, True)
	tvc.add_attribute(cr_txt, 'markup', colnum_txt)
	tvc.add_attribute(cr_pix, 'icon-name', 2)
	tvc.add_attribute(cr_pix, 'pixbuf', 3)


def validate_all_comp_headers():
	for n in range(0, len(panel_comp_header.children())):
		box = panel_comp_header.children()[n]
		if box.get_visible():
			valid = box.validate()
			if not valid:
				box.point_out()
				return False
	return True

def act_send():
	msg = ''
	if not validate_all_comp_headers():
		return
	if not get_composer_subject():
		msg += _("No Subject.") + '\n'
	if len(filter(lambda x: len(x.strip()), get_composer_headers(RecipientHeaders))) < 1:
		msg += _("No any Recipient.") + '\n'
	if msg != '':
		msg += _("Send anyway?")
		if not question(msg, (_("Send"), 'mail-send')):
			return
	build_newemail()
	
	dlg = gtk.MessageDialog(win_comp, gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_INFO, gtk.BUTTONS_CANCEL)
	dlg.connect('delete-event', lambda w, e: True)
	with BasicReuseable(_("Sending...")) as s:
		dlg.set_title(s)
		dlg.set_markup(s)
	set_dialog_icon_name(dlg, 'mail-send-receive')
	
	carea = dlg.get_content_area()
	progressbar = gtk.ProgressBar()
	details = gtk.ScrolledWindow()
	details_text = gtk.Label()
	details_text.set_alignment(0, 0)
	details_text.set_selectable(True)
	details.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
	details.add_with_viewport(details_text)
	carea.pack_start(progressbar, False, True)
	carea.pack_start(details, True, True)
	
	aarea = dlg.get_action_area()
	btn_cancel = aarea.children()[0]
	btn_show_details = StockButton(label=_("Show Details"), stock=gtk.STOCK_INFO)
	btn_show_details.connect('clicked', act_show_details_on_send_panel, dlg, details)
	
	aarea.pack_start(btn_show_details, False, True)
	dlg.show_all()
	details.hide()
	btn_show_details.hide()
	
	thrd = threading.Thread(target=sending_thread, args=(dlg, progressbar, btn_cancel, btn_show_details, details_text))
	thrd.start()

def sending_thread(dlg, progressbar, btn_cancel, btn_show_details, details_text):
	global StopSending
	StopSending = False
	child_read, parent_write, parent_read, child_write = get_pipe_handlers(2)
	pid = os.fork()
	if pid == 0:
		parent_read.close()
		parent_write.close()
		os.dup2(child_read.fileno(), sys.stdin.fileno())
		os.dup2(child_write.fileno(), sys.stdout.fileno())
		os.dup2(child_write.fileno(), sys.stderr.fileno())
		os.closerange(3, 255)
		try:
			os.execvp('sendmail', ['sendmail', '-ti'])
		except OSError as e:
			stderr(str(e))
		os._exit(127)
	
	gtk.threads_enter()
	sn = btn_cancel.connect('clicked', sending_cancel, pid, parent_write)
	gtk.threads_leave()
	
	child_read.close()
	child_write.close()
	set_blocking(parent_write, False)
	resp = ''
	text = NewEmail.as_string()
	pos = 0
	bufsize = 4096
	length = len(text)
	while pos < length and not StopSending:
		try:
			parent_write.write(text[pos:pos+bufsize])
			pos += bufsize
		except ValueError as e:
			resp += '>>> ' + str(e) + '\n'
			break
		except IOError as e:
			if e.errno == os.errno.EAGAIN:
				while not StopSending:
					ready = select.select([], [parent_write], [], 1.0)
					if len(ready[1]) > 0:
						break
			else:
				raise e
		gtk.threads_enter()
		progressbar.set_fraction((min(pos, length) + 0.0) / length)
		gtk.threads_leave()
	set_blocking(parent_write, True)
	if not StopSending:
		try:
			parent_write.close()
		except IOError as e:
			resp += '>>> ' + str(e) + '\n'
	
	resp += ''.join(parent_read.readlines())
	parent_read.close()
	status = WaitExecStatus(pid)
	
	gtk.threads_enter()
	progressbar.hide()
	btn_cancel.hide()
	btn_close = gtk.Button(stock=gtk.STOCK_CLOSE)
	btn_close.connect('clicked', lambda x: dlg.destroy())
	dlg.get_action_area().pack_start(btn_close, False, False)
	btn_close.show_all()
	if status.code == 0 and status.signal == 0:
		set_dialog_icon_name(dlg, gtk.STOCK_APPLY)
		with BasicReuseable(_("Email is sent.")) as s:
			dlg.set_title(s)
			dlg.set_markup(s)
		win_comp.set_data('email-sent', True)
		if win_comp.get_data('is-an-mdn'):
			menubutton_mdn.set_markup(menubutton_mdn.get_data('saved-label'))
		if hasattr(cliArgs, 'FILE'):
			MsgId = NewEmail[HDR_MID]
			for xattrname in win_comp.get_data('set-xattr-on-send'):
				set_xattrs(cliArgs.FILE, {xattrname: MsgId}, cliArgs.FILE)
	else:
		set_dialog_icon_name(dlg, gtk.STOCK_DIALOG_ERROR)
		dlg.set_markup(' '.join([_("Sendmail error: %s") % (status.code,), _("signal: %s") % (status.signal,) if status.signal!=0 else '']))
	btn_show_details.show()
	details_text.set_markup('<tt>' + glib.markup_escape_text(resp) + '</tt>')
	gtk.threads_leave()
	
def act_show_details_on_send_panel(btn, dlg, details):
	# display sendemail output in details box
	if details.get_visible():
		btn.set_label(_("Show Details"))
		details.hide()
		dlg.set_resizable(False)
	else:
		btn.set_label(_("Hide Details"))
		dlg.set_resizable(True)
		details.show()

def sending_cancel(btn, pid, writer_fh):
	global StopSending
	StopSending = True
	os.kill(pid, signal.SIGINT)

def iterate_composer_headers():
	for hname, hval in get_composer_headers(None) + [('Subject', get_composer_subject())]:
		if len(hname) > 0 and len(hval) > 0:
			yield (hname, hval)

def build_newemail():
	preserve_headers = win_comp.get_data('preserve-headers')
	for hname, hval in NewEmail._headers:
		if hname.lower() not in preserve_headers:
			del NewEmail[hname]
	for hname, hval in iterate_composer_headers():
		enchunks = []
		for chunk in hval.split(' '):
			try:
				enchunk = make_header([(chunk, None)])
			except UnicodeDecodeError:
				enchunk = make_header([(chunk, 'UTF-8')])
			enchunks.append(str(enchunk))
		NewEmail.add_header(hname, ' '.join(enchunks))
	
	# if there is not Message-ID but we must set at least one xattr
	if not NewEmail[HDR_MID] and win_comp.get_data('set-xattr-on-send'):
		NewEmail.add_header(HDR_MID, email.utils.make_msgid())
	
	text = get_composer_text()
	enc = analyze_for_optimal_encoding(text)
	text = text.encode(enc)
	part0 = NewEmail.get_payload()[0]
	part0.replace_header(HDR_CTE, enc)
	part0.set_payload(text)

def act_save_edit(save_as=False):
	filename = win_comp.get_data('saved-to-file')
	ask_overwrite = False
	if filename is None or save_as:
		ask_overwrite = True
		subj = get_composer_subject()
		if subj: subj = ' - ' + subj
		filename = choose_save_file(_("Draft") + subj + '.eml')
	if filename is not None:
		build_newemail()
		if save_to_file(NewEmail, filename, ask_overwrite=ask_overwrite) == True:
			win_comp.set_data('saved-to-file', filename)
			on_after_save_draft()

def on_after_save_draft():
	set_unsaved(False)
	panel_edit_message.get_buffer().set_modified(False)
	update_window_title(win_comp, win_comp.get_data('saved-to-file'), get_composer_subject())
	update_composer_status_message()

def update_composer_status_message():
	build_newemail()  # FIXME: it's sometimes an unneccessary duplicate
	size = len(NewEmail.as_string())
	tb_comp_label.set_label(_("Size: %s") % (human_size(size),))

def update_composer_toolbar_toggle_buttons():
	ninja_toggle(toggle_unimportant, False)
	ninja_toggle(toggle_unimportant, False)
	ninja_toggle(toggle_rqdn, False)
	
	for hname, hval in iterate_composer_headers():
		if hname == 'Importance':
			if hval.lower().find('low')>-1:
				ninja_toggle(toggle_unimportant, True)
			if hval.lower().find('high')>-1:
				ninja_toggle(toggle_important, True)
		if hname == HDR_GDR:
			ninja_toggle(toggle_rqdn, True)

def update_window_title(window, filename, subject_text):
	window.set_title('%s - %s' % (subject_text or os.path.basename(filename or '') or _("Unsaved"), PROGNAME))

def act_addressbook():
	def dblclick(wdg, evt):
		if evt.button == 1 and evt.type == gtk.gdk._2BUTTON_PRESS:
			flt_pathinfo = trv.get_path_at_pos(int(evt.x), int(evt.y))
			if flt_pathinfo is not None:
				iterator_path = flt.convert_path_to_child_path(flt_pathinfo[0])
				iterator = mod.get_iter(iterator_path)
				clear_composer_headers('To', '')
				add_composer_header('To', mod[iterator][0])
	def click_add(btn):
		clear_composer_headers('To', '')
		add_composer_headers('To', map(lambda x: mod[mod.get_iter(x)][0], sel.get_selected_rows()[1]))
	
	win = gtk.Window()
	box = gtk.VBox(False, 3)
	ent = gtk.Entry()
	scr = gtk.ScrolledWindow()
	mod = gtk.ListStore(str)
	flt = mod.filter_new()
	trv = gtk.TreeView(flt)
	sel = trv.get_selection()
	bbx = gtk.HBox(True, 2)
	bad = StockButton(stock=gtk.STOCK_ADD)
	bcl = StockButton(stock=gtk.STOCK_CLOSE)
	
	try:
		for ln in open(os.path.join(os.environ['HOME'], 'Mail', '.addressbook'), 'r'):
			mod.append([ln.strip()])
	except IOError as e:
		display_error(e)
		return
	
	win.set_transient_for(win_comp)
	win.set_modal(True)
	win.set_default_size(280, 400)
	win.set_border_width(4)
	sel.set_mode(gtk.SELECTION_MULTIPLE)
	sel.connect('changed', lambda sel: bad.set_sensitive(bool(len(sel.get_selected_rows()[1])>0)))
	scr.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
	trv.set_headers_visible(False)
	trv.set_rules_hint(True)
	trv.insert_column_with_attributes(0, '', gtk.CellRendererText(), text=0)
	flt.set_visible_func(lambda mo, it, ent: mo[it][0].find(ent.get_text())>-1, ent)
	bad.set_sensitive(False)
	win.connect('delete-event', lambda w, x: win.destroy())
	add_key_binding(win, 'Escape', lambda a,b,c,d: win.destroy())
	ent.connect('changed', lambda w: flt.refilter())
	trv.connect('button-press-event', dblclick)
	bcl.connect('clicked', lambda w: win.destroy())
	bad.connect('clicked', click_add)
	
	win.add(box)
	box.pack_start(ent, False, True)
	box.pack_start(scr, True, True)
	scr.add_with_viewport(trv)
	box.pack_start(bbx, False, True)
	bbx.pack_start(bad, True, False)
	bbx.pack_start(bcl, True, False)
	win.show_all()

def walk_multipart(eml, leaf_only=False, depth=0):
	if not leaf_only:
		yield (depth, eml)
	if type(eml._payload) == list:
		for part in eml._payload:
			for x in walk_multipart(part, leaf_only, depth+1):
				yield x
	else:
		if leaf_only:
			yield (depth, eml)

def debug_multipart(eml):
	for depth, part in walk_multipart(eml):
		stderr('%s- [%s] %d %s' % (depth*2*' ', part.get_content_type(), len(part.get_payload()), decode_mimetext(part.get_filename())))

def act_attach():
	filename = choose_open_file()
	if filename is not None:
		attach_path(filename, filename)
	update_composer_status_message()

def byte_is_identical_qp(b):
	if ord(b) < ord('!') or ord(b) > ord('~') or b == '=':
		return False
	return True

def analyze_for_optimal_encoding(buf):
	# Guess the optimal transfer encoding.
	approx_encoded_size_b64 = len(buf) * 1.37
	approx_encoded_size_qp = sum(map(lambda b: 1 if byte_is_identical_qp(b) else 3, buf))
	# add an extra equal mark and a linefeed for each 76th output byte
	approx_encoded_size_qp += 2 * (approx_encoded_size_qp / 76)
	
	if approx_encoded_size_b64 < approx_encoded_size_qp:
		return 'base64'
	else:
		return 'quoted-printable'

def attach_blob(data, parent_iter=None):
	mime = get_mime_by_data(data)
	ct_main, ct_sub = mime.split('/')
	basename = 'file%s' % (get_extension_by_mime(mime),)
	
	part = MIMEBase(ct_main, ct_sub)
	attachment_email = email.message_from_string(data)
	if mime == MIMETYPE_EMAIL or attachment_email.is_multipart():
		part.attach(attachment_email)
	else:
		enc = analyze_for_optimal_encoding(data[0:2048])
		part.add_header(HDR_CTE, enc)
		part.set_payload(data.encode(enc))
	attach__internal(parent_iter=parent_iter, basename=basename, part=part, mime=mime)
	return True

def is_safe_symlink(target, root):
	# Return True if target is within root or target itself is root.
	# target and root are absolute paths
	assert os.path.isabs(target)
	assert os.path.isabs(root)
	sep = re.escape(os.path.sep)
	par = re.escape(os.path.pardir)
	return not bool(re.search('(^|'+sep+')'+par+'('+sep+'|$)', os.path.relpath(target, root)))

def read_symlink_target_abs(symlink):
	assert os.path.isabs(symlink)
	target = os.readlink(symlink)
	if os.path.isabs(target):
		return target
	else:
		return os.path.normpath(os.path.join(symlink, os.path.pardir, target))

def make_relative_symlink(point_to, symlink_path):
	assert os.path.isabs(point_to)
	return os.path.relpath(point_to, os.path.join(symlink_path, os.path.pardir))

def attach_path(original_path, root_attachment_path, parent_iter=None):
	root_attachment_path = os.path.abspath(root_attachment_path)
	attachment_path = original_path
	mime = None
	isalink = False
	try:
		if os.path.islink(original_path):
			symlink_target_raw = os.readlink(original_path)
			symlink_target_abs = read_symlink_target_abs(os.path.abspath(original_path))
			visited_paths = [symlink_target_abs]
			while True:
				if is_safe_symlink(symlink_target_abs, root_attachment_path):
					# it's a symlink pointing to a (maybe transitive) target which is inside the base directory we are attaching recursively at the moment.
					# attach it as a symlink.
					mime = MIMETYPE_SYMLINK
					isalink = True
					# generate a symlink target to point directly to the first safe transitive target.
					symlink_content = make_relative_symlink(symlink_target_abs, original_path)
					break
				if not os.path.exists(symlink_target_abs):
					# it's a broken symlink. attach it as a symlink pointing to the nonexistent target.
					mime = MIMETYPE_SYMLINK
					isalink = True
					symlink_content = symlink_target_raw
					break
				if os.path.islink(symlink_target_abs):
					# it's a symlink, let's follow.
					symlink_target_abs_prev = symlink_target_abs
					symlink_target_raw = os.readlink(symlink_target_abs)
					symlink_target_abs = read_symlink_target_abs(symlink_target_abs)
					if symlink_target_abs in visited_paths:
						# it's a loopy symlink. attach it as a symlink pointing to the last transitive target before the cycle.
						mime = MIMETYPE_SYMLINK
						isalink = True
						symlink_content = make_relative_symlink(symlink_target_abs_prev, original_path)
						break
					visited_paths.append(symlink_target_abs)
				else:
					# it's a symlink (transitively) pointing not to a 'safe' file (in sense 
					# of not being within the directory currently being attached),
					# neither to an other symlink but something which exists (likely a normal file or a directory),
					# so attach the resolved 'unsafe' file instead of the original symlink.
					attachment_path = symlink_target_abs
					# TODO what should happen with unsafe files which linked multiple times?
					break
		
		content_disposition_params = {}
		with BasicReuseable(os.lstat(attachment_path)) as s:
			content_disposition_params['modification_date'] = email.utils.formatdate(s.st_mtime, True)
			if not isalink:
				content_disposition_params['posix_mode'] = '%05o' % (s.st_mode & 07777,)
	except OSError as e:
		display_error(e)
		return False
	
	if mime is None:
		mime = get_mime_by_filepath(attachment_path)
	ct_main, ct_sub = mime.split('/')
	
	if os.path.isdir(attachment_path) and not isalink:
		part = MIMEMultipart('related')
	else:
		part = MIMEBase(ct_main, ct_sub)
		
		if isalink:
			part.set_payload(symlink_content)
		else:
			# Check whther this file is an email file.
			attachment_email = email.message_from_file(open(attachment_path, 'r'))
			if mime == MIMETYPE_EMAIL or attachment_email.is_multipart():
				# File being attached is an Email (according to mime type or by detected multipart)
				# TODO - remove sensitive headers?
				part.attach(attachment_email)
			else:
				del attachment_email
				part.set_payload('')
				enc = None
				try:
					fh = open(attachment_path, 'r')
				except (IOError, OSError) as e:
					display_error(e)
					return False
				while True:
					# Encode n*3 bytes at once to avoid base64 paddings.
					buf = fh.read(4096*3)
					if buf == '': break
					if enc is None:
						enc = analyze_for_optimal_encoding(buf)
						part.add_header(HDR_CTE, enc)
					part._payload += buf.encode(enc)
				fh.close()
	
	basename = os.path.basename(original_path)
	iterator = attach__internal(parent_iter=parent_iter, content_disposition_params=content_disposition_params, basename=basename, part=part, mime=mime)
	
	if os.path.isdir(attachment_path) and not isalink:
		for entry in os.listdir(attachment_path):
			if not attach_path(os.path.join(attachment_path, entry), root_attachment_path, iterator):
				return False
	return True

def attach__internal(parent_iter=None, content_disposition_params={}, basename=None, part=None, mime=None):
	global NewEmail
	if parent_iter is None:
		parent_part = NewEmail
	else:
		while True:
			parent_part = Attachments[parent_iter][0]
			if type(parent_part.get_payload()) == list: break
			parent_iter = Attachments.iter_parent(parent_iter)
	
	ct_main, ct_sub = mime.split('/')
	part.add_header(HDR_CD, 'attachment', filename=basename, **content_disposition_params)
	parent_part.attach(part)
	set_unsaved()
	
	iterator = Attachments.append(parent_iter, [part, basename, get_stock_by_mime(ct_main, ct_sub), None])
	if parent_iter is not None:
		panel_attachments.expand_row(Attachments.get_path(parent_iter), False)
	
	debug_multipart(NewEmail)
	subparts = part.get_payload(decode=False)
	if mime == MIMETYPE_EMAIL or (type(subparts) == list and len(subparts) > 0):
		attachment_email = subparts[0]
		if isinstance(attachment_email, email.message.Message):
			amid = attachment_email.get(HDR_MID)
			if amid is not None:
				# Add Message-ID to main email's References.
				composer_append_to_list_header(HDR_REF, [amid])
				part.add_header(HDR_MID, amid)
			# Add parts to the attachments panel which are already attached to this email file.
			add_already_attached_parts(iterator, attachment_email)
	
	return iterator

def add_already_attached_parts(root_iter, eml, callback=lambda x: True):
	if callback(eml):
		ct_main, ct_sub = eml.get_content_maintype(), eml.get_content_subtype()
		name = decode_mimetext(eml.get_filename()) or '[%s/%s]' % (ct_main, ct_sub)
		icon = get_stock_by_mime(ct_main, ct_sub)
		iterator = Attachments.append(root_iter, [eml, name, icon, None])
		subparts = eml.get_payload()
		if type(subparts) == list:
			for subpart in subparts:
				add_already_attached_parts(iterator, subpart, callback=callback)

def drop_attachment_acceptable(targets):
	acceptable_types = MIMETYPE_URILIST, MIMETYPE_OCTETSTREAM
	for expect_type in acceptable_types:
		if expect_type in targets:
			return expect_type
	return False

def drop_attachment_motion(wdg, context, x, y, time):
	#stderr('Dropping %s' % (context.targets,))
	if drop_attachment_acceptable(context.targets):
		wdg.drag_highlight()
		context.drag_status(gtk.gdk.ACTION_COPY, time)
	else:
		context.drag_abort(time)
	return True

def drop_attachment_drop(wdg, context, x, y, time):
	target = drop_attachment_acceptable(context.targets)
	accept = bool(target)
	context.drop_reply(accept, time)
	if accept:
		wdg.drag_get_data(context, target, time)
		wdg.drag_unhighlight()
	else:
		display_error(_("Can not manage any of these types: %s") % (context.targets,))
		context.finish(accept, False, time)
	return accept

def drop_attachment_data(wdg, context, x, y, data, intid, time):
	#print map(lambda x: (x, getattr(data, 'get_'+x)()), ['target', 'format', 'data_type', 'selection', 'text'])
	success = False
	if data.get_length() > -1:
		typ = data.get_data_type()
		parent_iter = context.get_data('treeview-drop-dest-iterator')
		if typ == MIMETYPE_URILIST:
			success = None
			for uri in data.get_uris():
				filepath = file_uri_to_path(uri)
				if filepath is not None:
					if not attach_path(filepath, filepath, parent_iter):
						success = False
						break
				else:
					display_error(_("Unrecognized URI:")+'\n'+uri)
			if success is None:
				# All uri are attached successfuly.
				success = True
		elif typ == MIMETYPE_OCTETSTREAM:
			# TODO get filename from somewhere
			success = bool(attach_blob(data.data, parent_iter))
	context.finish(success, False, time)
	update_composer_status_message()
	return True

def drop_attachment_reorder_data(wdg, context, x, y, data, intid, time):
	treestore, iterator_path = data.tree_get_row_drag_data()
	context.set_data('treeview-iterator-path', iterator_path)
	return False

def drop_attachment_reorder_drop(wdg, context, x, y, time):
	if 'GTK_TREE_MODEL_ROW' in context.targets:
		success = False
		subject_path = context.get_data('treeview-iterator-path')
		if subject_path is not None:
			drop_info = wdg.get_dest_row_at_pos(x, y)
			if drop_info is not None:
				relative_iterator_path, relation = drop_info
				relative_iterator = Attachments.get_iter(relative_iterator_path)
				relative_part = Attachments[relative_iterator][0]
				if relation in [gtk.TREE_VIEW_DROP_BEFORE, gtk.TREE_VIEW_DROP_AFTER]:
					parent_iter = Attachments.iter_parent(relative_iterator)
					if parent_iter is None:
						parent_part = NewEmail
					else:
						parent_part = Attachments[parent_iter][0]
					if relation == gtk.TREE_VIEW_DROP_BEFORE:
						newindex = parent_part._payload.index(relative_part)
					elif relation == gtk.TREE_VIEW_DROP_AFTER:
						newindex = parent_part._payload.index(relative_part) + 1
				elif relation in [gtk.TREE_VIEW_DROP_INTO_OR_BEFORE, gtk.TREE_VIEW_DROP_INTO_OR_AFTER]:
					parent_part = relative_part
					newindex = 0
				if type(parent_part.get_payload()) == list:
					# Reorder subject_part attachment.
					subject_part = Attachments[subject_path][0]
					old_parent_iter = Attachments.iter_parent(Attachments.get_iter(subject_path))
					if old_parent_iter is None:
						old_parent_part = NewEmail
					else:
						old_parent_part = Attachments[old_parent_iter][0]
					if old_parent_part == parent_part:
						idx = old_parent_part._payload.index(subject_part)
						if idx < newindex:
							newindex -= 1
					old_parent_part._payload.remove(subject_part)
					parent_part._payload.insert(newindex, subject_part)
					success = True
		context.finish(success, False, time)
		event_is_handled = not success
		return event_is_handled
	else:
		# We assume this is an external drop.
		# Save TreeView-relative coordinates.
		context.set_data('treeview-drop-dest-iterator', get_iterator_from_pos(wdg, x, y))
	# Report the event is unhandled.
	return False

def rename_attachment(cellrenderer, iterator, new_text, colnum):
	eml = Attachments[iterator][0]
	header_params = {}
	if eml[HDR_CD]:
		header_params = dict(eml.get_params(header=HDR_CD))
		eml._headers.remove((HDR_CD, eml[HDR_CD]))
	header_params['filename'] = new_text
	eml.add_header(HDR_CD, 'attachment', **header_params)
	Attachments[iterator][colnum] = new_text
	return True

def on_keypress_attachments(tv, evt):
	if evt.keyval == gtk.gdk.keyval_from_name('Delete'):
		sel = panel_attachments.get_selection()
		for itpath in reversed(sel.get_selected_rows()[1]):
			try:
				iterator = Attachments.get_iter(itpath)
			except ValueError:
				# Child was deleted in meantime.
				continue
			if Attachments[iterator][0].get_content_type() == 'message/disposition-notification':
				win_comp.get_window().beep()
				continue
			part = Attachments[iterator][0]
			if part.get_content_type() == MIMETYPE_EMAIL:
				composer_substract_from_list_header(HDR_REF, [part.get(HDR_MID)])
			parent_iter = Attachments.iter_parent(iterator)
			if parent_iter is None:
				parent_part = NewEmail
			else:
				parent_part = Attachments[parent_iter][0]
			parent_part._payload.remove(part)
			del Attachments[iterator]
		update_composer_status_message()
		return True
	return False

def drag_part_begin(wdg, context):
	targets = wdg.drag_source_get_target_list()
	dragged_parts = []
	common_mime = None
	itpaths = selection_parts.get_selected_rows()[1]
	for itpath in itpaths:
		part = Parts[itpath][0]
		dragged_parts.append(part)
		mime = part.get_content_type()
		if common_mime is not False:
			if common_mime is None:
				common_mime = mime
			elif common_mime != mime:
				common_mime = False
	if common_mime:
		targets.insert(0, (common_mime, 0, len(targets)))
	if len(dragged_parts) > 1:
		context.set_icon_stock(gtk.STOCK_DND_MULTIPLE, 0, 0)
	
	atom_xds = gtk.gdk.atom_intern('XdndDirectSave0')
	atom_filename = gtk.gdk.atom_intern(MIMETYPE_TEXT)
	# TODO support multiple files
	filename0 = part_filename_by_iteratorpath(itpaths[0], add_extension=True, add_subject=True)
	stderr("Dragging [%s] %s" % (','.join(x[0] for x in targets), repr(filename0)))
	
	# Put dragged file's name into XWindow property (XDirectSave standard)
	context.source_window.property_change(atom_xds, atom_filename, 8, gtk.gdk.PROP_MODE_REPLACE, str(filename0))
	context.set_data('dragged-parts', dragged_parts)
	context.set_data('atom-xds', atom_xds)
	context.set_data('atom-filename', atom_filename)

def drag_part_data(wdg, context, data, intid, time):
	targettype = data.get_target()
	dragged_parts = context.get_data('dragged-parts')
	part0 = dragged_parts[0]
	stderr("Dropping [%s]" % (targettype,))
	if targettype == MIMETYPE_OCTETSTREAM:
		filedata = part0.get_payload(decode=True)
		if filedata is None:
			filedata = part0.as_string()
		atom = gtk.gdk.atom_intern(MIMETYPE_OCTETSTREAM)
		data.set(atom, 8, filedata)
	elif targettype == 'XdndDirectSave0':
		typ, fmt, dest_filename = context.source_window.property_get(context.get_data('atom-xds'), context.get_data('atom-filename'))
		if dest_filename is not None:
			xds_return_code = 'F'
			# Don't handle XDirectSave.
			# We pretended to support it just to have the remote app read our filename.
			if False:
				# TODO support GIO
				filepath = file_uri_to_path(dest_filename)
				if filepath is not None:
					saved = save_to_file(part0, filepath)
					xds_return_code = 'S' if saved else 'E'
			# Fail XDirectSave, remote app should ask us for other target type.
			data.set(data.target, 8, xds_return_code)
	else:
		stderr("Unknown drop target: "+targettype)

def drag_part_end(wdg, context):
	context.source_window.property_delete(context.get_data('atom-xds'))

def act_encrypt():
	pass

def act_sign():
	pass

def act_dispos_notif():
	if open_composer():
		NewEmail.set_type('multipart/report')
		NewEmail.set_param('report-type', 'disposition-notification', header='Content-Type')
		
		win_comp.set_data('is-an-mdn', True)
		win_comp.set_data('set-xattr-on-send', [XATTR_MDNSENT])
		add_composer_agent_headers()
		pndr_box = add_composer_header(HDR_PNDR, 'yes')
		pndr_box['readonly'] = True
		toggle_rqdn.set_sensitive(False)
		
		dnt_addresses = Email.get_all(HDR_DNT)
		my_address = guess_my_address()
		if dnt_addresses:
			for realname, addr in getaddresses(dnt_addresses):
				add_composer_header('To', email.utils.formataddr((decode_header(realname, eml=Email), addr)))
		else:
			add_composer_header('To', guess_reply_address())
		lang = get_one_header_main('Accept-Language')
		if lang:
			savelang = os.environ['LANGUAGE']
			os.environ['LANGUAGE'] = lang
		Ltxt_subj = _("Disposition Notification: {subject}")
		Ltxt_body = _("The message was sent on {date} to {me} with subject \"{subject}\" "
			"delivered on {delivery_date} and has been displayed. "
			"This is no guarantee that the message has been read or understood.")
		if lang:
			os.environ['LANGUAGE'] = savelang
		prms = {
			'date': get_one_header_main('Date') or '[somewhen]',
			'me': my_address or '[someone]',
			'subject': get_one_header_main('Subject'),
			'delivery_date': get_one_header_main('Delivery-Date') or '[somewhen]',
			}
		subject_text = Ltxt_subj.format(**prms)
		message_text = ''.join(map(lambda x: x+'\n', textwrap.wrap(Ltxt_body.format(**prms), 79)))
		set_composer_subject(subject_text)
		set_composer_text(message_text)
		
		dn_part = MIMEBase('message', 'disposition-notification')
		dn_fields = ['Disposition: manual-action/MDN-sent-manually; displayed']
		finalrecipient = my_address
		dn_fields += ['Final-Recipient: RFC822;%s' % (finalrecipient)]
		if Email[HDR_OR]:
			origrcpt = get_one_header_main(HDR_OR)
			dn_fields += ['%s: RFC822;%s' % (HDR_OR, origrcpt)]
		if Email[HDR_MID]:
			messageid = get_one_header_main(HDR_MID)
			dn_fields += ['Original-Message-ID: %s' % (messageid)]
		dn_text = ''.join(map(lambda x: x+'\n', dn_fields))
		dn_part.set_payload(dn_text)
		NewEmail.attach(dn_part)
		Attachments.append(None, [dn_part, _("Disposition Notification"), 'mail-mark-read', None])
		
		on_after_save_draft()
		panel_edit_message.grab_focus()

def act_req_dispos_notif():
	if toggle_rqdn.get_active():
		box_gdr = set_composer_header(HDR_GDR, 'Yes')
		box_gdr['readonly'] = True
		
		Froms = get_composer_headers('From')
		From = Froms[0]
		if From == '':
			From = '[' + _("missing email address") + ']'
		box_dnt = set_composer_header(HDR_DNT, From)
	else:
		clear_composer_headers(HDR_GDR)
		clear_composer_headers(HDR_DNT)

def turn_clicked_signal(ti, on):
	hid = ti.get_data('clicked-handler')
	if on:
		ti.handler_unblock(hid)
	else:
		ti.handler_block(hid)

def ninja_toggle(ti, on):
	turn_clicked_signal(ti, False)
	ti.set_active(on)
	turn_clicked_signal(ti, True)

def on_toggled(wdg):
	if wdg in [toggle_unimportant, toggle_important]:
		return on_toggled_importance(wdg)

def on_toggled_importance(wdg):
	if wdg.get_active():
		if wdg == toggle_important:
			toggle_unimportant.set_active(False)
		elif wdg == toggle_unimportant:
			toggle_important.set_active(False)
		return True
	return False

def act_importance():
	n = 1
	if toggle_important.get_active(): n = 2
	elif toggle_unimportant.get_active(): n = 0
	reset_composer_headers('Importance', [] if n == 1 else [Importances[n]])
	reset_composer_headers('Priority', [] if n == 1 else [Priorities[n]])

def act_edit_external():
	menubutton_send.set_sensitive(False)
	panel_edit_message.set_sensitive(False)
	menubutton_edit_external.set_sensitive(False)
	
	err = None
	fd, tmppath = mkstemp(prefix = PROGNAME + '-', suffix = '.txt')
	try:
		filehandler = os.fdopen(fd, 'w')
		filehandler.write(get_composer_text())
		set_xattrs(filehandler, {XATTR_CHARSET: 'UTF-8', XATTR_TYPE: MIMETYPE_TEXT}, tmppath)
		filehandler.close()
	except IOError as e:
		err = e
	except OSError as e:
		e.filename = tmppath
		err = e
	if err is not None:
		display_error(e)
		os.unlink(tmppath)
		on_edit_external_done(None)
		return
	thread = ExecThreadRunner(cliArgs.opener, cliArgs.opener_args + [tmppath], [cb_edit_external, tmppath])
	thread.start()

def cb_edit_external(status, filepath):
	if main_thread_alive():
		gtk.threads_enter()
		filehandler = None
		try:
			filehandler = open(filepath, 'r')
		except IOError as e:
			display_error(e)
			on_edit_external_done(None)
		else:
			on_edit_external_done(''.join(filehandler.readlines()))
			filehandler.close()
		try:
			os.unlink(filepath)
		except OSError as e:
			display_error(e)
		gtk.threads_leave()
	else:
		try:
			os.unlink(filepath)
		except OSError as e:
			stderr(str(e))

def on_edit_external_done(data):
	if data is not None:
		set_composer_text(data)
	menubutton_send.set_sensitive(True)
	panel_edit_message.set_sensitive(True)
	menubutton_edit_external.set_sensitive(True)

def set_unsaved(unsaved=True):
	win_comp.set_data('is-saved', not unsaved)
	win_comp.set_data('email-sent', False)
	s = menubutton_save_draft.get_label()
	endmark = '*'
	endmark_re = re.escape(endmark)
	if unsaved:
		s = re.sub('(%s)?$' % (endmark_re), endmark, s)
	else:
		s = re.sub(endmark_re + '$', '', s)
	menubutton_save_draft.set_label(s)

def on_edit_message(tb):
	if tb.get_modified():
		set_unsaved()



### Main ###

PROGNAME = 'gemlv'
VERSION = '0.1'
USERAGENT = PROGNAME + '/' + VERSION
gettext.textdomain(PROGNAME)
_ = gettext.gettext
setproctitle.setproctitle(PROGNAME)
PMU_MIME = '<i><span color=\'gray30\'>'
PMU_MIME_CLOSE = '</span></i>'
PMU_NAME = '<b>'
PMU_NAME_CLOSE = '</b>'
PMU_HEAD = '<b>'
PMU_HEAD_CLOSE = '</b>'
PMU_WARN = '<span foreground=\'darkred\' weight=\'bold\'>'
PMU_WARN_CLOSE = '</span>'
PMU_SUBJ = '<big>'
PMU_SUBJ_CLOSE = '</big>'
HDR_CD = 'Content-Disposition'
HDR_CTE = 'Content-Transfer-Encoding'
HDR_DNT = 'Disposition-Notification-To'
HDR_GDR = 'Generate-Delivery-Report'
HDR_PNDR = 'Prevent-NonDelivery-Report'
HDR_OR = 'Original-Recipient'
HDR_MID = 'Message-ID'
HDR_REF = 'References'
MIMETYPE_OCTETSTREAM = 'application/octet-stream'
MIMETYPE_EMAIL = 'message/rfc822'
MIMETYPE_URILIST = 'text/uri-list'
MIMETYPE_TEXT = 'text/plain'
MIMETYPE_HTML = 'text/html'
MIMETYPE_SYMLINK = 'inode/symlink'
Importances = ['low','normal','high']
Priorities = ['non-urgent','normal','urgent']
RE_EMAIL = '(?P<LP>\w[\w\.+-]*(?<![\.-]))@(?P<DP>(?:(?!-)[a-z\d-]+(?<!-)\.?)+)'
VAL_EMAIL = {
	'require': '^' + RE_EMAIL + '$',
	}
VAL_ADDRESSES = {
	'repetative': r'^(?i)\s*(?:(?P<DQ>\x22|)(?P<N>(?<=\x22)(?:[^\x22\n\\]|\\[\x22\\])*|[^\x22\x27<\n\\]+)(?P=DQ))?\s*(?(N)<|(?:(?P<LT><)|))' + RE_EMAIL + '(?(N)>|(?(LT)>))\s*(?:,\s*|$)',
	}
VAL_ADDRESS = {
	'require': VAL_ADDRESSES['repetative'] + '$',
	}
VAL_AGE = {
	'require': '^\d+[smhdwy]$',
	}
VAL_DATE = {
	'require': '^[a-zA-Z]+,\s*([12]\d|3[01]|0?[1-9])\s+[a-zA-Z]+\s+\d{4}\s+([01]\d|2[0-3])(:([0-5]\d)){2}\s+[+-]\d{4}(\s+\([A-Z]+\))?$',
	}
VAL_IMPORTANCE = {
	'autocomplete': Importances,
	'require': '^(%s)$' % '|'.join('[%c%c]%s' % (x[0].upper(), x[0], x[1:]) for x in Importances),
	}
Email = None
PartPrimary = None
PartSecondary = None
LastFolder = os.getcwd()
OriginatorHeaders = ['From', 'Sender', 'Return-Path', 'X-Sender', 'X-X-Sender', 'Reply-To']
SenderHeaders = ['From', 'Reply-To', 'Organization']
RecipientHeaders = ['To', 'Cc', 'Bcc']
DateTimeHeaders = ['Date', 'Reply-By', 'Expires', 'Deliver-At-Date']
PopularHeaders = ['Subject']
AdvancedHeaders = [
	HDR_REF, 'In-Reply-To', HDR_DNT,
	'Generate-Delivery-Report', 'Prevent-NonDelivery-Report',
	'Priority', 'Importance', 'Precedence',
	'Newsgroups', 'Followup-To', 'Thread-Topic',
	'Content-Language', 'Accept-Language',
	'Deliver-At-Age', 'Deliver-At-Date', 'Reply-By', 'Expires',
	'User-Agent', 'X-Mailer',
	]
EditExcludedHeaders = [
	'Auto-Submitted',
	'Delivered-To',
	'DKIM-Signature',
	'Domainkey-Signature',
	'Message-ID',
	'Received',
	'Received-*',
	'X-Originating-IP',
	# TODO
	#'Content-Type',
	#'X-MS-*',
	#'X-*',
]
ValidatorHeaders = {
	'From': VAL_ADDRESS,
	'Reply-To': VAL_ADDRESS,
	HDR_DNT: VAL_ADDRESS,
	'To': VAL_ADDRESSES,
	'Cc': VAL_ADDRESSES,
	'Bcc': VAL_ADDRESSES,
	'Deliver-At-Age': VAL_AGE,
	'Priority': Priorities,
	'Importance': VAL_IMPORTANCE,
	'Precedence': ['list', 'junk', 'bulk'],
}
for h in DateTimeHeaders:
	ValidatorHeaders[h] = VAL_DATE
XATTR_CHARSET = 'user.mime_encoding'
XATTR_TYPE = 'user.mime_type'
XATTR_ORIGIN = 'user.xdg.origin.email.message-id'
XATTR_MDNSENT = 'user.gemlv.mdn_sent'
XATTR_REPLIED = 'user.gemlv.replied'
XATTR_FORWARDED = 'user.gemlv.forwarded'
NewEmail = None
PREAMBLE = _("This is a MIME multipart Email.")

class PropertyStoreClass(object): pass
UserConfig = PropertyStoreClass()
UserConfig.show_importance_headers = False

class BasicReuseable():
	def __init__(self, value):
		self.value = value
	def __enter__(self):
		return self.value
	def __exit__(self, exc_type, exc_value, exc_traceback):
		pass

Timers = {}


### Parse Arguments ###

argparser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
argparser.add_argument('--compose', action='store_true', help=_("Write a new Email"))
argparser.add_argument('--from', metavar='FROM', help=_("New Email's writer's name and address"))
argparser.add_argument('--to', metavar='ADDRESSES', help=_("New Email's Recipients, comma-separated list"))
argparser.add_argument('--cc', metavar='ADDRESSES', help=_("Carbon Copy Recipients, comma-separated list"))
argparser.add_argument('--bcc', metavar='ADDRESSES', help=_("Blind Carbon Copy Recipients, comma-separated list"))
argparser.add_argument('--subject', metavar='STRING', help=_("Subject"))
argparser.add_argument('--message', metavar='STRING', help=_("Message body"))
argparser.add_argument('--mailto', metavar='URL', help=_("Full 'mailto:' link"))
argparser.add_argument('--attach', metavar='FILES', help=_("Attachments, comma-separated list"))
argparser.add_argument('--localedir', metavar='DIR', help=_("L10n base directory"))
argparser.add_argument('--opener', metavar='COMMAND', default='mimeopen-gui', help=_("File opener command"))
argparser.add_argument('FILE', nargs='?', help=_("Raw Email file for read or continue editing"))
sysargv = sys.argv[1:]
if os.path.basename(sys.argv[0]).find('compose') > -1 and '--compose' not in sysargv:
	sysargv.insert(0, '--compose')
if os.path.basename(sys.argv[0]).find('mailto') > -1:
	sysargv.insert(0, '--compose')
	sysargv.insert(1, '--mailto')
cliArgs = argparser.parse_args(args=sysargv)
del sysargv
for attr in 'to', 'cc', 'bcc', 'attach':
	if getattr(cliArgs, attr) is not None:
		setattr(cliArgs, attr, re.split('\s*,\s*', getattr(cliArgs, attr)))
if not cliArgs.compose and not cliArgs.FILE:
	stderr(_("Either compose mode or FILE is needed."))
	os._exit(1)
if cliArgs.localedir:
	gettext.bindtextdomain(PROGNAME, os.path.abspath(cliArgs.localedir))
openerargs = cliArgs.opener.split()
cliArgs.opener, cliArgs.opener_args = openerargs[0], openerargs[1:]
if xattr is None:
	stderr(_("Notice: no module xattr loaded"))
if hasattr(magic, 'open'):
	Magic = magic.open(magic.MAGIC_MIME_TYPE)
	Magic.load()
else:
	class magic0(object):
		def file(self, path):
			return magic.from_file(path, mime=True)
	Magic = magic0()
signal.signal(signal.SIGTERM, sighandler)
gtk.gdk.threads_init()


### Build GUI ###

win_main = gtkWindow()
win_main.set_default_size(832, 450)
start_evt = win_main.connect('map-event', win_main_show)
win_main.connect('delete-event', lambda a,b: act_quit())
add_key_binding(win_main, '<Control>q', lambda a,b,c,d: act_quit())
add_key_binding(win_main, '<Control>s', lambda a,b,c,d: act_save())
add_key_binding(win_main, '<Control>o', lambda a,b,c,d: act_open())
add_key_binding(win_main, '<Control>n', lambda a,b,c,d: act_compose())
add_key_binding(win_main, '<Control><Shift>r', lambda a,b,c,d: act_reply('one'))
add_key_binding(win_main, '<Control>r', lambda a,b,c,d: act_reply('all'))
add_key_binding(win_main, '<Control>f', lambda a,b,c,d: act_reply(''))
add_key_binding(win_main, '<Control>u', lambda a,b,c,d: act_view_source())
add_key_binding(win_main, '<Control>h', lambda a,b,c,d: show_view_headers(not panel_view_header.get_data('all-headers')))

box_main = gtk.VBox(False, 5)
toolbar = gtk.Toolbar()
spanel_view_header = gtk.ScrolledWindow()
panel_view = gtk.VPaned()
panel_view_upper = gtk.VBox()
panel_view_headerbox = gtk.HBox()
panel_view_header = gtk.Label()
panel_view_avatar = gtk.VBox()
panel_view_subject = gtk.Label(' ')
spanel_view_subject = Marquee(panel_view_subject)
panel_body = gtk.HPaned()
spanel_parts = gtk.ScrolledWindow()
Parts = gtk.TreeStore(gobject.TYPE_PYOBJECT, str, str, gtk.gdk.Pixbuf)
panel_parts = gtk.TreeView(Parts)
selection_parts = panel_parts.get_selection()
panel_right = gtk.VBox()
lbl_content_location = gtk.Label()
panel_btnbox = gtk.Frame()
panel_btnbox2 = gtk.VBox()
panel_btnbox3 = gtk.HBox()
lbl_right = gtk.Label()
btnbox_right = gtk.VBox(True, 10)
btn_open = StockButton(stock=gtk.STOCK_OPEN)
btn_save = StockButton(stock=gtk.STOCK_SAVE)
btn_save_struct = StockButton(label=_("Keep Structure"), stock=gtk.STOCK_SAVE)
panel_content_image = gtk.Frame()
spanel_content = gtk.ScrolledWindow()
panel_content = gtk.TextView()
tb_controls = gtk.Toolbar()
menubutton_filters = gtk.MenuToolButton(gtk.STOCK_ZOOM_FIT)
menu_filters = gtk.Menu()

win_main.add(box_main)
box_main.pack_start(toolbar, False, True)
box_main.pack_start(panel_view, True, True)
panel_view.pack1(panel_view_upper, False, True)
panel_view_upper.pack_start(panel_view_headerbox, True, True)
panel_view_headerbox.pack_start(spanel_view_header, True, True)
panel_view_headerbox.pack_start(panel_view_avatar, False, False)
panel_view_avatar.pack_start(gtk.Image(), False, False)
spanel_view_header.add_with_viewport(panel_view_header)
panel_view_upper.pack_start(spanel_view_subject, False, True)
panel_view.pack2(panel_body, True, True)
panel_body.pack1(spanel_parts, True, True)
panel_body.pack2(panel_right, True, True)
spanel_parts.add_with_viewport(panel_parts)
panel_right.pack_start(lbl_content_location, False, True)
panel_right.pack_start(panel_btnbox, True, True)
panel_btnbox.add(panel_btnbox2)
panel_btnbox2.pack_start(panel_btnbox3, True, False)
panel_btnbox3.pack_start(lbl_right, True, False)
panel_btnbox3.pack_start(btnbox_right, True, False)
btnbox_right.pack_start(btn_open, False, False)
btnbox_right.pack_start(btn_save, False, False)
btnbox_right.pack_start(btn_save_struct, False, False)
panel_right.pack_start(panel_content_image, True, True)
panel_content_image.add(gtk.Image())
panel_right.pack_start(spanel_content, True, True)
spanel_content.add_with_viewport(panel_content)
panel_right.pack_start(tb_controls, False, True)

win_main.set_icon_name('emblem-mail')
win_main.set_geometry_hints(min_width=100, min_height=250)
toolbar.set_style(gtk.TOOLBAR_BOTH)
panel_view.set_position(124)
spanel_view_header.set_policy(gtk.POLICY_NEVER, gtk.POLICY_AUTOMATIC)
spanel_view_header.connect('size-allocate', resize_panel_view_header)
panel_view_header.set_line_wrap(True)
panel_view_header.set_padding(4, 2)
panel_view_header.set_alignment(0, 0)
panel_view_header.set_justify(gtk.JUSTIFY_LEFT)
panel_view_header.set_selectable(True)
panel_view_header.connect('populate-popup', populate_header_menu)
panel_view_header.connect('scroll-event', on_scroll_on_button_font, panel_view_header, gtk.gdk.CONTROL_MASK)
panel_view_avatar.children()[0].set_padding(6, 1)
panel_view_subject.set_selectable(True)
panel_view_subject.set_padding(5, 4)
panel_view_subject.set_alignment(0, 0)
panel_view_subject.set_justify(gtk.JUSTIFY_LEFT)
panel_body.set_position(175)
spanel_parts.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
spanel_content.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
panel_parts.set_headers_visible(False)
panel_parts.drag_source_set(gtk.gdk.BUTTON1_MASK, [(MIMETYPE_OCTETSTREAM, 0, 0), ('XdndDirectSave0', 0, 1)], gtk.gdk.ACTION_COPY)
panel_parts.connect('drag-begin', drag_part_begin)
panel_parts.connect('drag-data-get', drag_part_data)
panel_parts.connect('drag-end', drag_part_end)
selection_parts.set_mode(gtk.SELECTION_MULTIPLE)
selection_parts.connect('changed', on_select_parts)
lbl_content_location.set_alignment(0, 0)
lbl_content_location.set_padding(2, 5)
lbl_right.set_alignment(0, 0)
lbl_right.set_justify(gtk.JUSTIFY_LEFT)
btn_open.connect('clicked', lambda wdg: act_open())
btn_save.connect('clicked', lambda wdg: act_save())
btn_save_struct.connect('clicked', lambda wdg: act_save_struct())
panel_content_image.connect('size-allocate', on_allocate_panel_content_image)
panel_content.set_editable(False)
panel_content.set_wrap_mode(gtk.WRAP_WORD)
panel_content.connect('scroll-event', on_scroll_on_button_font, panel_content, gtk.gdk.CONTROL_MASK)
tb_controls.set_icon_size(gtk.ICON_SIZE_MENU)
tb_controls.set_style(gtk.TOOLBAR_ICONS)
menubutton_filters.set_homogeneous(False)
menubutton_filters.set_menu(menu_filters)
menubutton_filters.set_arrow_tooltip_text(_("Filters"))


toolbuttons = [
	("Compose", gtk.STOCK_EDIT, None, act_compose, None),
	("Send MDN", 'mail-reply-sender', "Send a Message Disposition Notification", act_dispos_notif, None),
	("Reply", 'mail-reply-sender', "Reply\nRight click: Send a Message Disposition Notification", (act_reply, 'one'), act_dispos_notif),
	("Reply to All", 'mail-reply-all', None, (act_reply, 'all'), None),
	("Reply to List", 'mail-reply-all', None, (act_reply, 'list'), None),
	("Forward", 'mail-forward', None, (act_reply, ''), None),
	(None, None, None, 'separator', None),
	("Unsubscribe", 'stop', None, act_unsubscribe, None),
	("Report Spam", 'mail-mark-junk', None, act_report_spam, None),
	("Report Ham", 'mail-mark-notjunk', None, (act_report_spam, False), None),
	(None, None, None, 'space', None),
	(None, gtk.STOCK_CLOSE, None, act_quit, None),
]
x, menubutton_mdn, x, x, menubutton_replytolist, x, x_, menubutton_unsubscribe, menubutton_spam, menubutton_ham, x_, menubutton_quit \
= load_toolitems(toolbar, toolbuttons)
l = menubutton_mdn.get_label()
menubutton_mdn.set_data('saved-label', l)
menubutton_mdn.set_markup(PMU_WARN + l + PMU_WARN_CLOSE)
setup_treeview__icon_label(panel_parts)

def ToolItemDeclaration_wrap(tv):
	return ("Wrap", gtk.STOCK_JUSTIFY_LEFT, "Soft / Hard / No Wrap\nRight click: No / Soft / Hard Wrap", (act_wrap, tv), (act_wrap, tv, -1))
def ToolItemDeclaration_font(tv):
	return (None, gtk.STOCK_SELECT_FONT, "Change Font\nRight click: monospace\nScroll: zoom +/-", (act_font, tv), (act_font_switch, tv))

toolbuttons = [
	(None, 'emblem-generic', "Unimportant", None, None),
	(None, 'emblem-important', "Important", None, None),
	(None, 'mail-reply-sender', "Replied", None, None),
	(None, 'mail-forward', "Forwarded", None, None),
	(None, 'mail-mark-read', "MDN is sent", None, None),
	(None, 'mail-mark-junk', "Spam", None, None),
	(None, None, None, 'space', None),
	(None, gtk.STOCK_OPEN, None, act_open, None),
	(None, gtk.STOCK_SAVE, "Save\nRight click: Save and Keep Structure", act_save, act_save_struct),
	(None, None, None, 'separator', None),
	("Unfilter", menubutton_filters, "Filter / Unfilter", act_view_source, None),
	ToolItemDeclaration_wrap(panel_content),
	ToolItemDeclaration_font(panel_content),
]
stck_unimp, stck_imp, stck_repl, stck_fwd, stck_mdn, stck_spam, x_, btn_open2, btn_save2, x_, x, x, btn_font \
= load_toolitems(tb_controls, toolbuttons)
btn_font.connect('scroll-event', on_scroll_on_button_font, panel_content, None)


### Build Composer GUI ###

win_comp = gtkWindow()
win_comp.set_default_size(*win_main.get_default_size())
win_comp.connect('delete-event', lambda a,b: act_close_edit())
add_key_binding(win_comp, '<Control>'+('q' if cliArgs.compose else 'w'), lambda a,b,c,d: act_close_edit())
add_key_binding(win_comp, '<Control>s', lambda a,b,c,d: act_save_edit())
add_key_binding(win_comp, '<Control><Shift>s', lambda a,b,c,d: act_save_edit(True))
add_key_binding(win_comp, 'F4', lambda a,b,c,d: act_edit_external())
add_key_binding(win_comp, '<Control>h', lambda a,b,c,d: act_tgl_comp_hdr())

box_compose = gtk.VBox()
tb_compose = gtk.Toolbar()
panel_compose = gtk.VPaned()
panel_upper = gtk.HPaned()
spanel_comp_header = gtk.ScrolledWindow()
menu_add_header = gtk.Menu()
panel_comp_header = gtk.VBox(False, 0)
UnionHeadersStore = gtk.ListStore(str)
spanel_attachments = gtk.ScrolledWindow()
Attachments = gtk.TreeStore(gobject.TYPE_PYOBJECT, str, str, gtk.gdk.Pixbuf)
panel_attachments = gtk.TreeView(Attachments)
panel_edit = gtk.VBox()
panel_subject = gtk.HBox(False, 5)
panel_subject.set_border_width(4)
entry_subject = gtk.Entry()
frame_edit = gtk.Frame()
spanel_edit_message = gtk.ScrolledWindow()
panel_edit_message = gtk.TextView()
tb_comp_controls = gtk.Toolbar()

win_comp.add(box_compose)
box_compose.pack_start(tb_compose, False, True)
box_compose.pack_start(panel_compose, True, True)
panel_compose.pack1(panel_upper, True, True)
panel_upper.pack1(spanel_comp_header, True, True)
spanel_comp_header.add_with_viewport(panel_comp_header)
panel_upper.pack2(spanel_attachments, False, True)
spanel_attachments.add_with_viewport(panel_attachments)
panel_attachments.set_headers_visible(False)
panel_compose.pack2(panel_edit, True, True)
panel_edit.pack_start(panel_subject, False, True)
panel_subject.pack_start(gtk.Label(_("Subject")), False, True)
panel_subject.pack_start(entry_subject, True, True)
panel_edit.pack_start(frame_edit, True, True)
frame_edit.add(spanel_edit_message)
spanel_edit_message.add(panel_edit_message)
box_compose.pack_start(tb_comp_controls, False, True)

win_comp.set_icon_name('mail-message-new')
win_comp.set_geometry_hints(min_width=132, min_height=200)
tb_compose.set_style(gtk.TOOLBAR_BOTH)
panel_upper.set_position(win_comp.get_default_size()[1]-150)
spanel_comp_header.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_ALWAYS)
spanel_comp_header.connect('button-press-event', open_comp_hdr_menu)
panel_comp_header.set_border_width(4)
spanel_attachments.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
spanel_attachments.drag_dest_set(0, [], 0)
#spanel_attachments.drag_dest_set(gtk.DEST_DEFAULT_MOTION | gtk.DEST_DEFAULT_HIGHLIGHT, [('text/uri-list', 0, 0), ('GTK_TEXT_BUFFER_CONTENTS', 0, 0)], gtk.gdk.ACTION_COPY)
spanel_attachments.connect('drag-motion', drop_attachment_motion)
spanel_attachments.connect('drag-drop', drop_attachment_drop)
spanel_attachments.connect('drag-data-received', drop_attachment_data)
panel_attachments.get_selection().set_mode(gtk.SELECTION_MULTIPLE)
panel_attachments.set_reorderable(True)
panel_attachments.connect('drag-data-received', drop_attachment_reorder_data)
panel_attachments.connect('drag-drop', drop_attachment_reorder_drop)
panel_attachments.connect('focus-out-event', lambda w, e: w.get_selection().unselect_all())
panel_attachments.connect('key-press-event', on_keypress_attachments)
panel_upper.set_position(win_comp.get_default_size()[0]-200)
panel_compose.set_position(125)
entry_subject.connect('changed', on_edit_subject)
spanel_edit_message.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
panel_edit_message.get_buffer().connect('modified-changed', on_edit_message)
panel_edit_message.get_buffer().connect('changed', on_change_message)
panel_edit_message.connect('scroll-event', on_scroll_on_button_font, panel_edit_message, gtk.gdk.CONTROL_MASK)
frame_edit.set_shadow_type(gtk.SHADOW_IN)
tb_comp_controls.set_icon_size(gtk.ICON_SIZE_MENU)
tb_comp_controls.set_style(gtk.TOOLBAR_ICONS)

for name in SenderHeaders:
	mi = gtk.CheckMenuItem(_("Specify %s") % (_(name)))
	mi.set_data('chname', name)
	mi.connect('toggled', act_comp_hdr_menuitem)
	menu_add_header.append(mi)
mi = StockMenuItem(stock_id=gtk.STOCK_ADD, label=_("Add Recipient"))
mi.connect('activate', act_comp_hdr_menuitem, 'To')
menu_add_header.append(mi)
menu_add_header.append(gtk.SeparatorMenuItem())
mi = StockMenuItem(stock_id=gtk.STOCK_ADD, label=_("Add Custom Header"))
mi.connect('activate', act_comp_hdr_menuitem, '')
menu_add_header.append(mi)
menuitem_all_comp_hdr = gtk.CheckMenuItem(_("Show Custom Headers"))
menuitem_all_comp_hdr.connect('toggled', act_all_comp_hdr)
menu_add_header.append(menuitem_all_comp_hdr)
menu_add_header.show_all()

toolbuttons = [
	("Send", 'mail-send', None, act_send, None),
	(None, gtk.STOCK_SAVE, "Save\nRight click: Save As...", act_save_edit, (act_save_edit, True)),
	("Addressbook", 'x-office-address-book', None, act_addressbook, None),
	("Attach File", 'mail-attachment', None, act_attach, None),
	(None, None, None, 'space', None),
	(None, gtk.STOCK_CLOSE, None, act_close_edit, None),
]
menubutton_send, menubutton_save_draft, x, x, x_, x \
= load_toolitems(tb_compose, toolbuttons)
setup_treeview__icon_label(panel_attachments, label_edit_cb=rename_attachment)

for h in SenderHeaders + RecipientHeaders + PopularHeaders + AdvancedHeaders:
	UnionHeadersStore.append([h])

toolbuttons = [
	(None, LabelToolItem(), None, None, None),
	(None, None, None, 'space', None),
	(None, StockToggleToolButton('dialog-password'), "Encrypt", act_encrypt, None),
	(None, StockToggleToolButton('mail-signed'), "Crypto-Sign", act_sign, None),
	(None, StockToggleToolButton('mail-mark-read'), "Disposition Notification", act_req_dispos_notif, None),
	(None, None, None, 'separator', None),
	("Unimportant", StockToggleToolButton('emblem-generic'), "Unimportant", act_importance, None),
	("Important", StockToggleToolButton('emblem-important'), "Important", act_importance, None),
	(None, None, None, 'separator', None),
	(None, gtk.STOCK_EDIT, "Edit with External Program", act_edit_external, None),
	ToolItemDeclaration_wrap(panel_edit_message),
	ToolItemDeclaration_font(panel_edit_message),
]
tb_comp_label, x_, x, x, toggle_rqdn, x_, toggle_unimportant, toggle_important, x_, menubutton_edit_external, x, btn_font2 \
= load_toolitems(tb_comp_controls, toolbuttons)
toggle_rqdn.connect('toggled', on_toggled)
toggle_unimportant.connect('toggled', on_toggled)
toggle_important.connect('toggled', on_toggled)
btn_font2.connect('scroll-event', on_scroll_on_button_font, panel_edit_message, None)


if cliArgs.compose:
	setproctitle.setproctitle(PROGNAME+'-compose')
	open_composer()
	if cliArgs.FILE:
		# Open existing Email for edit.
		win_comp.set_data('saved-to-file', cliArgs.FILE)
		on_after_save_draft()
		try:
			edit_eml = email_from_file(cliArgs.FILE)
		except RuntimeError:
			sys.exit(1)
		
		# Import headers.
		# TODO - remove technical headers like Content-Type
		supersedes = []
		for hname, hval in edit_eml._headers:
			hname_lc = hname.lower()
			hval = decode_header(hval, eml=edit_eml)
			if hname_lc == 'message-id':
				supersedes.append(hval)
			elif hname_lc == 'subject':
				set_composer_subject(hval)
			if any(fnmatch(hname_lc, hdr.lower()) for hdr in EditExcludedHeaders):
				# Do not include these headers in an incompleted email.
				pass
			else:
				add_composer_header(hname, hval)
		reset_composer_headers('Supersedes', [', '.join(supersedes)])
		
		body_found = False
		def detect_body_part(part):
			if not body_found and part.get_content_type() == MIMETYPE_TEXT:
				set_composer_text(decode_readably(part.get_payload(decode=True), part))
				# Prevent this part to be treated as attachment. This is the body part.
				return False
			# Attach this part.
			NewEmail.attach(part)
			# Allow this part to be appeared in attachments panel.
			return True
		
		# Import attachments.
		parts = edit_eml.get_payload(decode=False)
		if type(parts) == list:
			for part in parts:
				add_already_attached_parts(None, part, detect_body_part)
		else:
			# Not a multipart email, set body to payload.
			set_composer_text(decode_readably(edit_eml.get_payload(decode=True), edit_eml))
	else:
		# Open a clear composer window.
		add_composer_agent_headers()
		if not cliArgs.message:
			set_composer_text('\n\n' + get_user_signature())
	
	if cliArgs.mailto:
		mailto = get_mailto(cliArgs.mailto)
		add_composer_mailto(mailto)
	if getattr(cliArgs, 'from'):
		reset_composer_headers('From', [getattr(cliArgs, 'from')])
	if cliArgs.to:
		add_composer_headers('To', cliArgs.to)
	if cliArgs.cc:
		add_composer_headers('Cc', cliArgs.cc)
	if cliArgs.bcc:
		add_composer_headers('Bcc', cliArgs.bcc)
	if len(get_composer_headers(RecipientHeaders)) < 1:
		# Add an empty To header unless any recipient was given.
		add_composer_header('To')
	if cliArgs.subject:
		set_composer_subject(cliArgs.subject)
	if cliArgs.message:
		set_composer_text(cliArgs.message)
	if cliArgs.attach:
		for path in cliArgs.attach:
			attach_path(path, path)
		del path
	on_after_save_draft()
	panel_edit_message.grab_focus()
else:
	win_main.show_all()
	menubutton_mdn.hide()
	menubutton_replytolist.hide()
	menubutton_unsubscribe.hide()
	panel_view_avatar.hide()
	lbl_content_location.hide()
	panel_btnbox.hide()
	panel_content_image.hide()
	stck_unimp.hide()
	stck_imp.hide()
	stck_repl.hide()
	stck_fwd.hide()
	stck_mdn.hide()
	stck_spam.hide()

gtk.main()
if len(threading.enumerate()) > 1:
	stderr(_("Waiting background threads to complete."))
