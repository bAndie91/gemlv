#!/usr/bin/env python

import os
import sys
import signal
import select
import fcntl
import gtk
import gobject
import glib
import pango
import gettext
import email
import re
import tempfile
import mimetypes


class StockToolButton(gtk.ToolButton):
	def __init__(self, label=None, stock=None, tooltip=None):
		super(self.__class__, self).__init__()
		if stock is not None:
			if stock in gtk.stock_list_ids():
				if stock is not None: self.set_stock_id(stock)
			else:
				self.set_icon_name(stock)
		if label is not None:
			self.set_label(label)
		if tooltip is not None:
			self.set_tooltip_text(tooltip)
	def set_pixbuf(self, pxb):
		a = self.get_children()[0]
		a = a.get_children()[0]
		img, a = a.get_children()
		img.set_from_pixbuf(pxb)
		img.props.visible = True

class StockButton(gtk.Button):
	def __init__(self, label=None, stock=None, use_underline=True):
		if stock is not None and stock in gtk.stock_list_ids():
			stock_tmp = stock
		else:
			stock_tmp=gtk.STOCK_ABOUT
		super(self.__class__, self).__init__(stock=stock_tmp, use_underline=use_underline)
		if label is not None:
			self.set_markup(label)
		if stock is None:
			self.set_icon('')
		elif stock not in gtk.stock_list_ids():
			self.set_icon(stock)
	def __get_children(self):
		align = self.get_children()[0]
		hbox = align.get_children()[0]
		return hbox.get_children()
	def set_label(self, label):
		_, lbl = self.__get_children()
		lbl.set_label(label)
	def set_markup(self, label):
		_, lbl = self.__get_children()
		lbl.set_markup(label)
	def set_icon(self, icon):
		img, _ = self.__get_children()
		if type(icon) == str:
			if icon == '':
				img.props.visible = False
			else:
				img.set_from_icon_name(icon, gtk.ICON_SIZE_BUTTON)
				img.props.visible = True
		else:
			img.set_from_pixbuf(icon)
			img.props.visible = True

class cfgparser:
	def __init__(self, name, **kvargs):
		self.fh = None
		self.var = {'regex': '^\s*([^;#].*)', 'split': [1],}
		for k in 'regex', 'splitgroups':
			if not self.var.has_key(k): self.var[k] = None
			if kvargs.has_key(k): self.var[k] = kvargs[k]
		suff = '.conf'
		for t in (name + suff,), (os.environ['HOME'], '.config', PROGNAME, name + suff), (os.path.sep, 'etc', PROGNAME, name + suff):
			n = os.path.join(*t)
			try:
				self.fh = open(n, 'r')
			except:
				self.fh = None
				pass
			if self.fh is not None:
				break
	
	def __iter__(self):
		return self
	
	def next(self):
		if self.fh is None:
			raise StopIteration
		else:
			while True:
				ln = self.fh.readline()
				if ln == '':
					raise StopIteration
				m = re.match(self.var['regex'], ln)
				if m:
					grps = []
					n = 0
					for grp in m.groups():
						n += 1
						if n in self.var['splitgroups']:
							if grp is None:
								grp = []
							else:
								grp = re.split('\s+', grp)
						grps.append(grp)
					return grps
	
	def __del__(self):
		try:
			self.fh.close()
		except:
			pass

class pipereader:
	def __init__(self, inputstr, cmd, args=[], exitdict=None):
		self.exitdict = exitdict
		args.insert(0, os.path.basename(cmd))
		child_read, parent_write, parent_read, child_write = get_pipe_handlers(2)
		pid = os.fork()
		if pid == 0:
			parent_read.close()
			parent_write.close()
			os.dup2(child_read.fileno(), sys.stdin.fileno())
			os.dup2(child_write.fileno(), sys.stdout.fileno())
			try:
				os.execvp(cmd, args)
			except OSError, e:
				sys.stderr.write(str(e))
			os._exit(127)
		else:
			child_read.close()
			child_write.close()
			parent_write.write(inputstr)
			parent_write.close()
			self.pid = pid
			self.reader = parent_read
	
	def __iter__(self):
		return self
	
	def next(self):
		s = self.reader.readline()
		if s == '':
			raise StopIteration
		else:
			return s
	
	def __del__(self):
		self.reader.close()
		_, status = os.waitpid(self.pid, 0)
		if self.exitdict is not None:
			sig = status & 0x7F
			core = status & 0x80 >> 7
			excode = status >> 8
			exitdict['status'] = excode
			exitdict['signal'] = sig
			exitdict['coredumped'] = core

class cyclelist(list):
	def __init__(self, lst, **kvargs):
		if type(lst) != type([]):
			raise TypeError('need list, %s found' % (str(type(lst))))
		if len(lst) < 1:
			raise ValueError('need non-empty list')
		super(self.__class__, self).__init__(lst)
		self.idx = 0
		if kvargs.has_key('at'):
			self.whirl(kvargs['at'])
	
	def whirl(self, val):
		for i in range(0, len(self)):
			if self[i] == val:
				self.idx = i
				return val
		return None
	
	def turn(self, n=1):
		self.idx = (self.idx + n) % len(self)
		return self[self.idx]
	
	def __getitem__(self, i):
		return super(self.__class__, self).__getitem__(i % len(self))

	def __setitem__(self, i, v):
		return super(self.__class__, self).__setitem__(i % len(self), v)
	
	def __str__(self):
		return str(self[self.idx])

def display_error(e):
	text = None
	if isinstance(e, OSError) or isinstance(e, IOError):
		text = "%s (#%d)\n%s" % (e.strerror, e.errno, e.filename)
	elif isinstance(e, Exception):
		text = e.message
	elif type(e) == type([]):
		text = ''.join(e)
	if text is None:
		text = str(e)
	dlg = gtk.MessageDialog(main_win, gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_ERROR, gtk.BUTTONS_OK, text)
	dlg.set_title(_("Error"))
	dlg.run()
	dlg.destroy()

def get_pipe_handlers(npairs):
	pipes = []
	for n in range(0, npairs):
		r, w = os.pipe()
		pipes.append(os.fdopen(r, 'r'))
		pipes.append(os.fdopen(w, 'w'))
	return pipes

def joinNone(glue, dflt, lst):
	lst2 = []
	for e in lst:
		lst2.append(dflt if e is None else e)
	return glue.join(lst2)

def bye(*ignore):
	gtk.main_quit()

def main_win_show(widget, event):
	main_win.disconnect(start_evt)
	panel_content.set_data('saved-font', get_current_font(panel_content))
	if len(sys.argv) > 1:
		load_file(sys.argv[1])

def load_file(filename):
	fp = open(filename, 'r')
	Email = email.message_from_file(fp)
	fp.close()
	clear_parts(Parts)
	if Email.is_multipart():
		spanel_parts.show()
		load_parts(Email, Parts, Parts.get_iter_root())
		panel_parts.expand_all()
		if PartPrimary is not None:
			selection_parts.select_iter(PartPrimary)
		elif PartSecondary is not None:
			selection_parts.select_iter(PartSecondary)
		else:
			load_part(Email)
	else:
		spanel_parts.hide()
		load_part(Email)

def clear_parts(model):
	model.clear()

def load_parts(eml, model, parent):
	global PartPrimary
	global PartSecondary
	
	label = ''
	if eml.get_filename(): label += glib.markup_escape_text(eml.get_filename()) + ' '
	label += '<i><span color="gray30">' + eml.get_content_type() + '</span></i>'
	stock = get_stock_by_mime(eml.get_content_maintype(), eml.get_content_subtype())
	pixb = None
	
	iterator = model.append(parent, [eml, label, stock, pixb])
	if PartPrimary is None and eml.get_content_type() == 'text/plain':
		PartPrimary = iterator
	if PartSecondary is None and eml.get_content_type() == 'text/html':
		PartSecondary = iterator
	if type(eml.get_payload()) == type([]):
		for part in eml.get_payload():
			load_parts(part, model, iterator)

def clear_content(s=''):
	bufr = panel_content.get_buffer()
	bufr.set_text(s)
	panel_content.set_sensitive(False)
	return bufr

def load_part(eml, filt = None):
	if eml is None: return
	bufr = clear_content(_("Loading..."))
	panel_content.set_data('view-unfiltered', False)
	if filt is None:
		filt = get_filter_by_mime(eml.get_content_maintype(), eml.get_content_subtype())
	
	if filt is None:
		if type(eml.get_payload()) == type([]) and not(eml.preamble is None and eml.epilogue is None):
			bufr.set_text(joinNone("\n", '', [eml.preamble, eml.epilogue]))
			panel_content.set_sensitive(True)
		else:
			panel_btnbox.show()
			spanel_content.hide()
			btn_open.show()
			btn_save.set_label(gtk.stock_lookup(gtk.STOCK_SAVE)[1])
	elif filt == '':
		panel_content.set_data('view-unfiltered', True)
		bufr.set_text(eml.get_payload(decode=1))
		panel_content.set_sensitive(True)
	else:
		bufr.set_text('')
		cmd, args = filt[:]
		for s in pipereader(eml.get_payload(decode=1), cmd, args):
			bufr.insert(bufr.get_end_iter(), s)
		panel_content.set_sensitive(True)

def which(cmd):
	def is_executable(p):
		return (os.path.isfile(p) and os.access(p, os.X_OK))
	
	ap, bn = os.path.split(cmd)
	if ap:
		if is_executable(cmd):
			return cmd
	else:
		for d in os.environ['PATH'].split(os.path.pathsep):
			p = os.path.join(d, cmd)
			if is_executable(p):
				return p
	return None

def get_filter_by_mime(main, sub):
	for m, s, cmd, args in cfgparser('filters', regex='^\s*([^;#][^\s/]*)/(\S+)\s+(\S+)\s*(.+)?', splitgroups=[4]):
		if (main == '*' or main == m) and (sub == '*' or sub == s):
			if cmd == '-':
				return ''
			if which(cmd):
				return cmd, args
	return None

def get_stock_by_mime(main, sub):
	assoc_main = {
		'multipart': gtk.STOCK_DIRECTORY,
		'message': 'emblem-mail',
	}
	assoc_full = {
		'application/pgp-signature': 'mail-signed',
	}
	full = main + '/' + sub

	if assoc_full.has_key(full):
		return assoc_full[full]
	elif assoc_main.has_key(main):
		return assoc_main[main]
	
	if full in ['text/html']:
		return main + '-' + sub
	elif main in ['audio', 'image', 'font', 'package', 'text', 'video']:
		return main + '-x-generic'

	return gtk.STOCK_FILE

def add_key_binding(widget, keyname, callback):
	accelgroup = gtk.AccelGroup()
	key, modifier = gtk.accelerator_parse(keyname)
	accelgroup.connect_group(key, modifier, gtk.ACCEL_VISIBLE, callback)
	widget.add_accel_group(accelgroup)

def act_button(func):
	if type(func) != type(()):
		func = (func,)
	if func[0] is not None:
		func[0](*func[1:])

def on_click_button(btn, func):
	act_button(func)
	return False

def on_press_button(btn, evt, func):
	if evt.type == gtk.gdk.BUTTON_PRESS:
		if evt.button == 3 or (evt.button == 1 and evt.state & gtk.gdk.SHIFT_MASK):
			act_button(func)
	return False

def act_reply(recip):
	pass

def act_compose():
	pass

def act_wrap(i=1):
	modes = cyclelist([gtk.WRAP_WORD, gtk.WRAP_WORD_CHAR, gtk.WRAP_NONE], at=panel_content.get_wrap_mode())
	panel_content.set_wrap_mode(modes.turn(i))

def save_to_file(filename):
	pass

def get_extension_by_mime(mime):
	e = mimetypes.guess_extension(mime)
	if e is None: e = '.dat'
	return e

def act_open():
	eml = get_part_by_itpath()
	mime = eml.get_content_type()
	fd, tmppath = tempfile.mkstemp(prefix = PROGNAME + '-', suffix = get_extension_by_mime(mime))
	try:
		save_to_filehandle(eml, fd)
	except OSError, e:
		os.unlink(tmppath)
		e.filename = tmppath
		display_error(e)
		return
	run_async('mimeopen-gui', [tmppath], [os.unlink, tmppath])

def act_save():
	pass

def run_async(cmd, args, postrun):
	pid1 = os.fork()
	if pid1 == 0:
		os.closerange(0, 255)
		pid2 = os.fork()
		if pid2 == 0:
			pid3 = os.fork()
			if pid3 == 0:
				args.insert(0, os.path.basename(cmd))
				os.execvp(cmd, args)
				os._exit(127)
			else:
				_, status = os.waitpid(pid3, 0)
				excode = status >> 8
				postrun[0](*postrun[1:])
				os._exit(excode)
		else:
			os._exit(0)
	else:
		os.waitpid(pid1, 0)

def save_to_filehandle(eml, fd):
	s = eml.get_payload(decode=1)
	if s is None:
		s = eml.as_string()
	written = os.write(fd, s)
	if written != len(s):
		raise OSError(5, 'Write Error')
	os.close(fd)

def act_view_source():
	if panel_content.get_data('view-unfiltered'):
		filt = None
	else:
		filt = ''
	load_part(get_part_by_itpath(), filt)

def get_current_font(txtv):
	pctx = txtv.get_pango_context()
	fdsc = pctx.get_font_description()
	s = fdsc.to_string()
	m = re.match('\s(\d+)(\s|$)', s)
	if m: pt = int(m.group(1))
	else: pt = 12
	return {'family': fdsc.get_family().lower(), 'string': s.lower(), 'size': pt, 'desc': fdsc,}

def act_font_switch():
	font = get_current_font(panel_content)
	if font['family'] != 'monospace':
		panel_content.set_data('saved-font', font)
		f = panel_content.get_data('saved-font-monospace')
		if f is None: f = 'monospace 12'
		else: f = f['string']
	else:
		f = panel_content.get_data('saved-font')['string']
	change_font(f)

def act_font():
	dlg = gtk.FontSelectionDialog(_("Select Font"))
	dlg.set_font_name(panel_content.get_data('saved-font')['string'])
	dlg.set_modal(True)
	dlg.run()
	font_name = dlg.get_font_name()
	dlg.destroy()
	change_font(font_name)
	font = get_current_font(panel_content)
	if font['family'] == 'monospace':
		key = 'saved-font-monospace'
	else:
		key = 'saved-font'
	panel_content.set_data(key, font)

def change_font(s):
	panel_content.modify_font(pango.FontDescription(s))

def on_select_parts(selection):
	itpaths = selection.get_selected_rows()[1]
	if len(itpaths) > 1:
		panel_btnbox.show()
		spanel_content.hide()
		btn_open.hide()
		btn_save.set_label(_("Save All"))
		btn_open2.set_sensitive(False)
		btn_save2.set_sensitive(True)
	else:
		panel_btnbox.hide()
		spanel_content.show()
		if len(itpaths) == 1:
			btn_open2.set_sensitive(True)
			btn_save2.set_sensitive(True)
			itpath = itpaths[0]
			load_part(get_part_by_itpath(itpath))
		else:
			btn_open2.set_sensitive(False)
			btn_save2.set_sensitive(False)
			clear_content()

def get_part_by_itpath(itpath = None):
	if itpath is None:
		try:
			itpath = selection_parts.get_selected_rows()[1][0]
		except IndexError:
			return None
	model = Parts
	return model.get_value(model.get_iter(itpath), 0)

def on_click_parts(tree, event):
	if event.button == 3:
		x = int(event.x)
		y = int(event.y)
		pathinfo = tree.get_path_at_pos(x, y)
		if pathinfo is not None:
			path, col, cellx, celly = pathinfo
			tree.grab_focus()
			tree.set_cursor(path, col, 0)
#			popup_menu = 
#			popup_menu.popup(None, None, None, event.button, event.time)
		return True

def load_toolitems(toolbar, toolitems):
	for label, stock, tip, fnc_left, fnc_right in toolitems:
		if type(fnc_left) == str:
			tbi = gtk.SeparatorToolItem()
			if fnc_left == 'space':
				tbi.set_draw(False)
				tbi.set_expand(True)
			elif fnc_left == 'separator':
				tbi.set_draw(True)
				tbi.set_expand(False)
		else:
			stocklabel = False
			if label is None:
				s = gtk.stock_lookup(stock)
				if s:
					label = s[1]
					stocklabel = True
				else:
					label = ''
			else:
				label = _(label)
			if tip is None:
				tip = label
				if stocklabel:
					tip = re.sub('_', '', tip)
			else:
				tip = _(tip)
			tbi = StockToolButton(label=label, stock=stock, tooltip=tip)
			tbi.child.connect('clicked', on_click_button, fnc_left)
			tbi.child.connect('button-press-event', on_press_button, fnc_right)
		tbi.set_data('stock', stock)
		toolbar.insert(tbi, -1)



### Main ###

PROGNAME = 'gemlv'
_ = gettext.gettext
Email = None
Parts = gtk.TreeStore(gobject.TYPE_PYOBJECT, str, str, gtk.gdk.Pixbuf)
PartPrimary = None
PartSecondary = None

main_win = gtk.Window()
main_win.set_default_size(720, 450)
main_win.connect('delete-event', bye)
add_key_binding(main_win, '<Control>q', bye)
start_evt = main_win.connect('map-event', main_win_show)

box_main = gtk.VBox(False, 5)
toolbar = gtk.Toolbar()
panel_header = gtk.Label("headers")
panel_body = gtk.HPaned()
spanel_parts = gtk.ScrolledWindow()
panel_btnbox = gtk.HBox()
btnbox_right = gtk.VBox(True, 10)
spanel_content = gtk.ScrolledWindow()
panel_parts = gtk.TreeView(Parts)
selection_parts = panel_parts.get_selection()
panel_right = gtk.VBox()
panel_content = gtk.TextView()
btn_open = StockButton(stock=gtk.STOCK_OPEN)
btn_save = StockButton(stock=gtk.STOCK_SAVE)
tb_controls = gtk.Toolbar()

main_win.add(box_main)
box_main.pack_start(toolbar, False, True)
box_main.pack_start(panel_header, False, True)
box_main.pack_start(panel_body, True, True)
panel_body.pack1(spanel_parts, True, True)
panel_body.pack2(panel_right, True, True)
spanel_parts.add(panel_parts)
panel_right.pack_start(panel_btnbox, True, False)
panel_btnbox.pack_start(btnbox_right, True, False)
btnbox_right.pack_start(btn_open, False, False)
btnbox_right.pack_start(btn_save, False, False)
panel_right.pack_start(spanel_content, True, True)
spanel_content.add(panel_content)
panel_right.pack_start(tb_controls, False, True)

toolbar.set_style(gtk.TOOLBAR_BOTH)
panel_body.set_position(175)
spanel_parts.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
spanel_content.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
panel_parts.set_headers_visible(False)
panel_parts.connect('button-press-event', on_click_parts)
selection_parts.set_mode(gtk.SELECTION_MULTIPLE)
selection_parts.connect('changed', on_select_parts)
btn_open.connect('clicked', lambda wdg: act_open())
btn_save.connect('clicked', lambda wdg: act_save())
panel_content.set_editable(False)
panel_content.set_wrap_mode(gtk.WRAP_WORD)
tb_controls.set_icon_size(gtk.ICON_SIZE_MENU)
tb_controls.set_style(gtk.TOOLBAR_ICONS)


toolbuttons = [
	("Compose", gtk.STOCK_EDIT, None, act_compose, None),
	# 'mail-send'
	# 'mail-mark-junk'
	# 'mail-mark-notjunk'
	# 'mail-attachment'
	# 'x-office-address-book'
	("Reply", 'mail-reply-sender', None, (act_reply, 'one'), None),
	("Reply To All", 'mail-reply-all', None, (act_reply, 'all'), None),
	("Forward", 'mail-forward', None, (act_reply, ''), None),
	(None, None, None, 'space', None),
	("Quit", gtk.STOCK_QUIT, None, bye, None),
]
load_toolitems(toolbar, toolbuttons)

tvc = gtk.TreeViewColumn()
panel_parts.append_column(tvc)
cr_pix = gtk.CellRendererPixbuf()
cr_txt = gtk.CellRendererText()
tvc.pack_start(cr_pix, False)
tvc.pack_start(cr_txt, True)
tvc.add_attribute(cr_txt, 'markup', 1)
tvc.add_attribute(cr_pix, 'icon-name', 2)
tvc.add_attribute(cr_pix, 'pixbuf', 3)

toolbuttons = [
	(None, None, None, 'space', None),
	(None, gtk.STOCK_OPEN, None, act_open, None),
	(None, gtk.STOCK_SAVE, None, act_save, None),
	(None, None, None, 'separator', None),
	("Unfilter", gtk.STOCK_ZOOM_FIT, "Filter / Unfilter", act_view_source, None),
	("Wrap", gtk.STOCK_JUSTIFY_LEFT, "Soft / Hard / No Wrap", act_wrap, (act_wrap, -1)),
	(None, gtk.STOCK_SELECT_FONT, "Change Font\nRight click: monospace", act_font, act_font_switch),
]
load_toolitems(tb_controls, toolbuttons)
for tbi in tb_controls.get_children():
	s = tbi.get_data('stock')
	if s == gtk.STOCK_OPEN:
		btn_open2 = tbi
	elif s == gtk.STOCK_SAVE:
		btn_save2 = tbi


main_win.show_all()
panel_btnbox.hide()
gtk.main()
