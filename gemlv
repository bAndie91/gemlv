#!/usr/bin/env python

import os
import sys
import signal
import select
import fcntl
import gtk
import gobject
import glib
import pango
import gettext
import email
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
import re
from tempfile import mkstemp
from mimetypes import guess_extension
import magic
from fnmatch import fnmatch
import argparse
try:
	import xattr
except ImportError:
	sys.stderr.write(_("Notice: no module xattr loaded") + "\n")
	xattr = None


### helper classes, functions ###

class StockToolButton(gtk.ToolButton):
	def __init__(self, label=None, stock=None, tooltip=None):
		super(self.__class__, self).__init__()
		if stock is not None:
			if stock in gtk.stock_list_ids():
				if stock is not None: self.set_stock_id(stock)
			else:
				self.set_icon_name(stock)
		if label is not None:
			self.set_label(label)
		if tooltip is not None:
			self.set_tooltip_text(tooltip)
	def set_pixbuf(self, pxb):
		a = self.get_children()[0]
		a = a.get_children()[0]
		img, a = a.get_children()
		img.set_from_pixbuf(pxb)
		img.props.visible = True

class StockButton(gtk.Button):
	def __init__(self, label=None, stock=None, use_underline=True, icon_size=None):
		if stock is not None and stock in gtk.stock_list_ids():
			stock_tmp = stock
		else:
			stock_tmp = gtk.STOCK_ABOUT
		super(self.__class__, self).__init__(stock=stock_tmp, use_underline=use_underline)
		if label is not None:
			self.set_markup(label)
		if stock is None:
			self.set_icon('')
		elif stock not in gtk.stock_list_ids():
			self.set_icon(stock)
		if icon_size is not None:
			self.set_icon(stock, icon_size)
	def __get_children(self):
		align = self.get_children()[0]
		hbox = align.get_children()[0]
		return hbox.get_children()
	def set_label(self, label):
		_, lbl = self.__get_children()
		lbl.set_label(label)
	def set_markup(self, label):
		_, lbl = self.__get_children()
		lbl.set_markup(label)
	def set_icon(self, icon, size=gtk.ICON_SIZE_BUTTON):
		img, _ = self.__get_children()
		if type(icon) == str:
			if icon == '':
				img.props.visible = False
			else:
				img.set_from_icon_name(icon, size)
				img.props.visible = True
		else:
			img.set_from_pixbuf(icon)
			img.props.visible = True

class cfgparser:
	def __init__(self, name, **kvargs):
		self.var = {'regex': '^\s*([^;#].*)', 'split': [1],}
		for k in 'regex', 'splitgroups':
			if not self.var.has_key(k): self.var[k] = None
			if kvargs.has_key(k): self.var[k] = kvargs[k]
		suff = '.conf'
		self.filehandlers = []
		for t in (os.environ['HOME'], '.config', PROGNAME, name + suff), (os.path.sep, 'etc', PROGNAME, name + suff), (name + suff,),:
			n = os.path.join(*t)
			try:
				fh = open(n, 'r')
				self.filehandlers.append(fh)
			except IOError:
				pass
	
	def __iter__(self):
		return self
	
	def next(self):
		if len(self.filehandlers) == 0:
			raise StopIteration
		else:
			fh = self.filehandlers[0]
			while True:
				ln = fh.readline()
				if ln == '':
					fh.close()
					self.filehandlers.reverse()
					self.filehandlers.pop()
					self.filehandlers.reverse()
					if len(self.filehandlers) == 0:
						raise StopIteration
					fh = self.filehandlers[0]
					continue
				m = re.match(self.var['regex'], ln)
				if m:
					grps = []
					n = 0
					for grp in m.groups():
						n += 1
						if n in self.var['splitgroups']:
							if grp is None:
								grp = []
							else:
								grp = re.split('\s+', grp)
						grps.append(grp)
					return grps
	
	def __del__(self):
		for fh in self.filehandlers:
			fh.close()

class pipereader:
	def __init__(self, inputstr, cmd, args=[], exitdict=None):
		self.exitdict = exitdict
		args = args[:]
		args.insert(0, os.path.basename(cmd))
		child_read, parent_write, parent_read, child_write = get_pipe_handlers(2)
		pid = os.fork()
		if pid == 0:
			parent_read.close()
			parent_write.close()
			os.dup2(child_read.fileno(), sys.stdin.fileno())
			os.dup2(child_write.fileno(), sys.stdout.fileno())
			try:
				os.execvp(cmd, args)
			except OSError, e:
				sys.stderr.write(str(e))
			os._exit(127)
		else:
			child_read.close()
			child_write.close()
			parent_write.write(inputstr)
			parent_write.close()
			self.pid = pid
			self.reader = parent_read
	
	def __iter__(self):
		return self
	
	def next(self):
		s = self.reader.readline()
		if s == '':
			raise StopIteration
		else:
			return s
	
	def __del__(self):
		self.reader.close()
		_, status = os.waitpid(self.pid, 0)
		if self.exitdict is not None:
			sig = status & 0x7F
			core = status & 0x80 >> 7
			excode = status >> 8
			exitdict['status'] = excode
			exitdict['signal'] = sig
			exitdict['coredumped'] = core

class cyclelist(list):
	def __init__(self, lst, **kvargs):
		if type(lst) != type([]):
			raise TypeError('need list, %s found' % (str(type(lst))))
		if len(lst) < 1:
			raise ValueError('need non-empty list')
		super(self.__class__, self).__init__(lst)
		self.idx = 0
		if kvargs.has_key('at'):
			self.whirl(kvargs['at'])
	
	def whirl(self, val):
		for i in range(0, len(self)):
			if self[i] == val:
				self.idx = i
				return val
		return None
	
	def turn(self, n=1):
		self.idx = (self.idx + n) % len(self)
		return self[self.idx]
	
	def __getitem__(self, i):
		return super(self.__class__, self).__getitem__(i % len(self))

	def __setitem__(self, i, v):
		return super(self.__class__, self).__setitem__(i % len(self), v)
	
	def __str__(self):
		return str(self[self.idx])

def add_key_binding(widget, keyname, callback):
	accelgroup = gtk.AccelGroup()
	key, modifier = gtk.accelerator_parse(keyname)
	accelgroup.connect_group(key, modifier, gtk.ACCEL_VISIBLE, callback)
	widget.add_accel_group(accelgroup)

def display_error(e):
	text = None
	if isinstance(e, OSError) or isinstance(e, IOError):
		text = "%s (#%d)\n%s" % (e.strerror, e.errno, e.filename)
	elif isinstance(e, Exception):
		text = e.message
	elif type(e) == type([]):
		text = ''.join(e)
	if text is None:
		text = str(e)
	dlg = gtk.MessageDialog(None, gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_ERROR, gtk.BUTTONS_OK, text)
	dlg.set_title(_("Error"))
	dlg.run()
	dlg.destroy()

def question(msg, stock_yes=None):
	dlg = gtk.MessageDialog(None, gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_QUESTION, gtk.BUTTONS_YES_NO, msg)
	dlg.set_title(_("Question"))
	if stock_yes is not None:
		dlg.get_widget_for_response(gtk.RESPONSE_YES).hide()
		btn_yes = StockButton(label=stock_yes[0], stock=stock_yes[1])
		dlg.add_action_widget(btn_yes, gtk.RESPONSE_YES)
		btn_yes.show()
	resp = dlg.run()
	dlg.destroy()
	return (resp == gtk.RESPONSE_YES)

def choose_dialog(action, filename=None):
	global LastFolder
	selected = None
	
	btn_accept_stock = gtk.STOCK_SAVE
	if action == gtk.FILE_CHOOSER_ACTION_OPEN:
		btn_accept_stock = gtk.STOCK_OPEN
	dlg = gtk.FileChooserDialog(action=action, buttons=(gtk.STOCK_CANCEL, gtk.RESPONSE_REJECT, btn_accept_stock, gtk.RESPONSE_ACCEPT))
	if LastFolder is not None: dlg.set_current_folder(LastFolder)
	if filename is not None: dlg.set_current_name(filename)
	btn_cwd = StockButton(label=_("Working Dir"), stock=gtk.STOCK_JUMP_TO)
	dlg.add_action_widget(btn_cwd, gtk.RESPONSE_NO)
	btn_cwd.show()
	while True:
		resp = dlg.run()
		if resp == gtk.RESPONSE_ACCEPT:
			selected = dlg.get_filename()
			break
		elif resp == gtk.RESPONSE_NO:
			dlg.set_current_folder(os.getcwd())
		else:
			break
	LastFolder = dlg.get_current_folder()
	dlg.destroy()
	return selected

def choose_save_file(filename=None):
	return choose_dialog(gtk.FILE_CHOOSER_ACTION_SAVE, filename)

def choose_save_folder():
	return choose_dialog(gtk.FILE_CHOOSER_ACTION_SELECT_FOLDER)

def choose_open_file():
	return choose_dialog(gtk.FILE_CHOOSER_ACTION_OPEN)

def get_pipe_handlers(npairs):
	pipes = []
	for n in range(0, npairs):
		r, w = os.pipe()
		pipes.append(os.fdopen(r, 'r'))
		pipes.append(os.fdopen(w, 'w'))
	return pipes

def joinNone(glue, dflt, lst):
	lst2 = []
	for e in lst:
		lst2.append(dflt if e is None else e)
	return glue.join(lst2)

def which(cmd):
	def is_executable(p):
		return (os.path.isfile(p) and os.access(p, os.X_OK))
	
	ap, bn = os.path.split(cmd)
	if ap:
		if is_executable(cmd):
			return cmd
	else:
		for d in os.environ['PATH'].split(os.path.pathsep):
			p = os.path.join(d, cmd)
			if is_executable(p):
				return p
	return None

def run_async(cmd, args, postrun):
	args = args[:]
	args.insert(0, os.path.basename(cmd))
	pid1 = os.fork()
	if pid1 == 0:
		os.closerange(0, 255)
		pid2 = os.fork()
		if pid2 == 0:
			pid3 = os.fork()
			if pid3 == 0:
				os.execvp(cmd, args)
				os._exit(127)
			else:
				_, status = os.waitpid(pid3, 0)
				excode = status >> 8
				postrun[0](*postrun[1:])
				os._exit(excode)
		else:
			os._exit(0)
	else:
		os.waitpid(pid1, 0)

### private functions ###

def win_main_show(widget, event):
	win_main.disconnect(start_evt)
	panel_content.set_data('saved-font', get_current_font(panel_content))
	if args.FILE:
		load_file(args.FILE)

def load_file(filename):
	global Email
	fh = open(filename, 'r')
	Email = email.message_from_file(fh)
	fh.close()
	
	panel_header.set_markup(get_headers_markup(Email))
	clear_parts(Parts)
	if Email.is_multipart():
		pos = panel_body.get_data('saved-position')
		if pos is not None:
			panel_body.set_position(pos)
			panel_body.set_data('saved-position', None)
	else:
		panel_body.set_data('saved-position', panel_body.get_position())
		panel_body.set_position(0)
	
	load_parts(Email, Parts, Parts.get_iter_root())
	panel_parts.expand_all()
	if Email.is_multipart():
		if PartPrimary is not None:
			selection_parts.select_iter(PartPrimary)
		elif PartSecondary is not None:
			selection_parts.select_iter(PartSecondary)
		else:
			selection_parts.select_path((0,))
	else:
		selection_parts.select_path((0,))

def clear_parts(model):
	model.clear()

def load_parts(eml, model, parent):
	global PartPrimary
	global PartSecondary
	
	label = PMU_MIME + glib.markup_escape_text(eml.get_content_type()) + PMU_MIME_CLOSE
	filename = eml.get_filename()
	if filename is not None: label = glib.markup_escape_text(filename) + ' ' + label
	stock = get_stock_by_mime(eml.get_content_maintype(), eml.get_content_subtype())
	pixb = None
	
	iterator = model.append(parent, [eml, label, stock, pixb])
	if PartPrimary is None and eml.get_content_type() == 'text/plain':
		PartPrimary = iterator
	if PartSecondary is None and eml.get_content_type() == 'text/html':
		PartSecondary = iterator
	if type(eml.get_payload()) == type([]):
		for part in eml.get_payload():
			load_parts(part, model, iterator)

def clear_content(s=''):
	bufr = panel_content.get_buffer()
	bufr.set_text(s)
	panel_content.set_sensitive(False)
	return bufr

def decode_properly(s, eml):
	charset = eml.get_content_charset()
	if charset is None:
		s = s.decode('utf-8', 'replace')
	elif charset.lower() not in ['utf-8', 'utf_8', 'utf8']:
		s = s.decode(charset, 'replace')
	return s

def get_content_properly(eml):
	s = eml.get_payload(decode=1)
	if s is None:
		s = eml.as_string()
	return decode_properly(s, eml)

def set_content_text(s, eml=None):
	if s is None:
		s = get_content_properly(eml)
	elif eml is not None:
		s = decode_properly(s, eml)
	panel_content.get_buffer().set_text(s)
	panel_content.set_sensitive(True)

def load_part(eml, filt=None):
	if eml is None: return
	clear_content(_("Loading failed"))
	panel_content.set_data('view-unfiltered', False)

	if filt is None:
		filt = get_filter_by_mime(eml.get_content_maintype(), eml.get_content_subtype())
	
	if filt is None:
		if type(eml.get_payload()) == type([]) and not(eml.preamble is None and eml.epilogue is None):
			set_content_text(joinNone("\n", '', [eml.preamble, eml.epilogue]), eml)
		else:
			label = _("Content type: %s%s%s") % (PMU_MIME, glib.markup_escape_text(eml.get_content_type()), PMU_MIME_CLOSE)
			filename = eml.get_filename()
			if filename is not None: label = (_("Filename: %s%s%s") % (PMU_NAME, glib.markup_escape_text(filename), PMU_NAME_CLOSE)) + "\n" + label
			lbl_right.set_markup(label)
			
			panel_btnbox.show()
			btn_open.show()
			btn_save.set_label(gtk.stock_lookup(gtk.STOCK_SAVE)[1])
			spanel_content.hide()
	else:
		cmd, args = filt[:]
		if cmd == '':
			panel_content.set_data('view-unfiltered', True)
			set_content_text(None, eml)
			panel_btnbox.hide()
			spanel_content.show()
			panel_content.set_sensitive(True)
		else:
			bufr = panel_content.get_buffer()
			bufr.set_text('')
			for s in pipereader(get_content_properly(eml), cmd, args):
				bufr.insert(bufr.get_end_iter(), s)
			panel_content.set_sensitive(True)

def decode_header(s):
	chunks = []
	for chars, encoding in email.Header.decode_header(s):
		if encoding is None: encoding = 'utf-8'
		chunks.append(chars.decode(encoding, 'replace'))
	return ' '.join(chunks)

def get_one_header_main(hname, dflt=None):
	hval = get_part_by_itpath((0,))[hname]
	if hval is None:
		return dflt
	return decode_header(hval)

def get_headers_markup(eml):
	lns = []
	hdrs = [
		"X-X-Sender",
		"X-Sender",
		"Sender",
		"From",
		"Organization",
		"Reply-To",
		"To",
		"Cc",
		"Subject",
		"Date",
	]
	hdr_from = []
	for hname in hdrs:
		if eml[hname]:
			hvals = []
			for hval in eml.get_all(hname):
				hval = decode_header(hval)
				if hname == 'From':
					hdr_from.append(hval)
				elif hname == 'Reply-To':
					if hval in hdr_from: continue
				elif hname == 'Date':
					#hval = TODO timezone...
					pass
				hvals.append(hval)
			if len(hvals):
				lns.append(PMU_HEAD + _(hname) + PMU_HEAD_CLOSE + ': ' + ', '.join(map(glib.markup_escape_text, hvals)))
	return "\n".join(lns)

def get_filters_by_mime(main, sub, all=True):
	filters = []
	for m, s, cmd, args in cfgparser('filters', regex='^\s*([^;#][^\s/]*)/(\S+)\s+(\S+)\s*(.+)?', splitgroups=[4]):
		if fnmatch(main, m) and fnmatch(sub, s):
			e = None
			if cmd == '-':
				e = ('', None)
			elif which(cmd):
				e = (cmd, args)
			if e is not None:
				if all:
					filters.append(e)
				else:
					return e
	if all:
		return filters
	return None

def get_filter_by_mime(main, sub):
	return get_filters_by_mime(main, sub, all=False)

def get_stock_by_mime(main, sub):
	assoc_main = {
		'multipart': gtk.STOCK_DIRECTORY,
		'message': 'emblem-mail',
	}
	assoc_full = {
		'application/pgp-signature': 'mail-signed',
		'application/ics': 'x-office-calendar',
		'text/calendar': 'x-office-calendar',
	}
	full = main + '/' + sub

	if assoc_full.has_key(full):
		return assoc_full[full]
	elif assoc_main.has_key(main):
		return assoc_main[main]
	
	if full in ['text/html']:
		return main + '-' + sub
	elif main in ['audio', 'image', 'font', 'package', 'text', 'video']:
		return main + '-x-generic'

	return gtk.STOCK_FILE

def act_quit():
	if win_comp.get_visible():
		act_close_edit()
	if win_comp.get_visible():
		return True
	gtk.main_quit()
	return False

def act_close_edit():
	if not win_comp.get_data('email-sent') and not win_comp.get_data('is-saved'):
		if not question(_("Message is not saved.\nClose anyway?"), (None, gtk.STOCK_QUIT if args.compose else gtk.STOCK_CLOSE)):
			return True
	if args.compose:
		gtk.main_quit()
		return False
	else:
		win_comp.hide()
		return True

def act_button(func):
	if type(func) != type(()):
		func = (func,)
	if func[0] is not None:
		func[0](*func[1:])

def on_click_button(btn, func):
	act_button(func)
	return False

def on_press_button(btn, evt, func):
	if evt.type == gtk.gdk.BUTTON_PRESS:
		if evt.button == 3 or (evt.button == 1 and evt.state & gtk.gdk.SHIFT_MASK):
			act_button(func)
	return False

def open_comp_hdr_menu(widget, event):
	if event.button == 3 or (event.button == 1 and event.state & gtk.gdk.SHIFT_MASK):
		menu_add_header.popup(None, None, None, event.button, event.time)
		return True

def act_comp_hdr_menuitem(mi, hname=None):
	if hname is None:
		hname = mi.get_data('chname')
	on = mi.active if isinstance(mi, gtk.CheckMenuItem) else None
	box = add_composer_header__direct(hname)
	if on == False:
		box.cancel()
	if hname == '':
		pass
		# TODO: show_advanced_comp_hdr()
	return True

def add_composer_header__direct(hname, hval=None):
	box = None
	for thisbox in panel_comp_hdr.children():
		if thisbox.hntype == compose_header_box.HNTYPE_LABEL and thisbox['name'] == hname:
			box = thisbox
			if hval is not None: box['value'] = hval
			break
	if box is None:
		if hval is None: hval = ''
		box = compose_header_box(hname, hval)
		panel_comp_hdr.pack_start(box, False, True)
		if box.hntype == compose_header_box.HNTYPE_LABEL:
			pass
			# TODO: reorder to above the 1st HNTYPE_CUSTOM
	box.show_all()
	return box

def add_composer_header(hname, hval=None):
	box = add_composer_header__direct(hname, hval)
	box.tick_my_menuitem(1)
	return box

def set_composer_headers(hname, hvals):
	clear_composer_headers(hname)
	for hval in hvals:
		add_composer_header(hname, hval)

def clear_composer_headers(hname):
	for box in panel_comp_hdr.children():
		if hname is None or box['name'] == hname:
			box.cancel()

class compose_header_box(gtk.HBox):
	HNTYPE_LABEL, HNTYPE_MENU, HNTYPE_CUSTOM = range(3)
	
	def __init__(self, chname, val):
		assert isinstance(chname, str)
		assert isinstance(val, str)
		plus = True
		minus = True
		
		super(self.__class__, self).__init__(False, 2)
		if chname is None or chname == '' or chname in AdvancedHeaders:
			self.hntype = self.HNTYPE_CUSTOM
			self.wdg_name = gtk.combo_box_entry_new_with_model(UnionHeadersStore, 0)
		elif chname in RecipientHeaders:
			self.hntype = self.HNTYPE_MENU
			self.wdg_name = gtk.Button()
			self.wdg_name.set_relief(gtk.RELIEF_NONE)
			self.wdg_name.connect('button-release-event', self.popup_rcpt_menu)
		else:
			self.hntype = self.HNTYPE_LABEL
			plus = False
			self.wdg_name = gtk.Label()
		self.pack_start(self.wdg_name, False, True)
		
		self.wdg_value = gtk.Entry()
		self.pack_start(self.wdg_value, True, True)
		#TODO wdg_value.set_completion()
		
		if plus:
			self.wdg_add = StockButton('', gtk.STOCK_ADD, icon_size=gtk.ICON_SIZE_MENU)
			self.pack_start(self.wdg_add, False, False)
			self.wdg_add.set_relief(gtk.RELIEF_NONE)
			self.wdg_add.connect('clicked', self.duplicate)
		if minus:
			self.wdg_del = StockButton('', gtk.STOCK_REMOVE, icon_size=gtk.ICON_SIZE_MENU)
			self.wdg_del.set_relief(gtk.RELIEF_NONE)
			self.pack_start(self.wdg_del, False, False)
			self.wdg_del.connect('clicked', self.cancel)
		
		self['name'] = chname
		self['value'] = val
	
	def popup_rcpt_menu(self, wdg, evt):
		wdg.set_relief(gtk.RELIEF_NORMAL)
		mnu = gtk.Menu()
		mnu.connect('deactivate', self.popup_rcpt_menu_disappear, wdg)
		for chname in RecipientHeaders:
			mi = gtk.MenuItem(label=_(chname))
			mi.set_data('name', chname)
			mi.connect('activate', self.popup_rcpt_menuitem_activated, wdg)
			mnu.append(mi)
		mnu.show_all()
		mnu.popup(None, None, self.bottomleft, evt.button, evt.time, wdg)
	
	def popup_rcpt_menuitem_activated(self, mi, wdg):
		self['name'] = mi.get_data('name')
		self.popup_rcpt_menu_disappear(mi.parent, wdg)
	
	def popup_rcpt_menu_disappear(self, mnu, wdg):
		wdg.set_relief(gtk.RELIEF_NONE)
		self.wdg_value.grab_focus()
	
	def bottomleft(self, mnu, wdg):
		X, Y = self.window.get_origin()
		x, y, w, h = wdg.get_allocation()
		mx = X + x
		my = Y + y + h
		return (mx, my, True)
	
	def duplicate(self, evtwdg=None):
		newbox = self.__class__(self['name'], self['value'])
		self.parent.pack_start(newbox, False, True)
		newbox.show_all()
		newbox.wdg_value.grab_focus()
		for n in range(0, len(self.parent.children())):
			if self.parent.children()[n] == self:
				self.parent.reorder_child(newbox, n)
	
	def cancel(self, evtwdg=None):
		if self.hntype == self.HNTYPE_LABEL:
			self.hide()
			self.tick_my_menuitem(0)
		else:
			self.parent.remove(self)
	
	def tick_my_menuitem(self, on):
		# FIXME: call out of the class
		for mi in menu_add_header.children():
			if mi.get_data('chname') == self['name']:
				mi.set_active(on)
				break
	
	def __getitem__(self, key):
		if key == 'name':
			if self.hntype == self.HNTYPE_CUSTOM:
				it = self.wdg_name.get_active_iter()
				if it is not None:
					return self.wdg_name.get_model().get_value(it, 0)
				else:
					return self.wdg_name.children()[0].get_text()
			else:
				return self.wdg_name.get_data('name')
		elif key == 'value':
			return self.wdg_value.get_text()
		else:
			raise IndexError()

	def __setitem__(self, key, newvalue):
		if key == 'name':
			self.wdg_name.set_data('name', newvalue)
			if self.hntype == self.HNTYPE_CUSTOM:
				self.wdg_name.children()[0].set_text(newvalue)
			else:
				self.wdg_name.set_data('name', newvalue)
				self.wdg_name.set_label(_(newvalue))
		elif key == 'value':
			return self.wdg_value.set_text(newvalue)
		else:
			raise IndexError()


def get_composer_headers(hname):
	hlist = []
	for chld in panel_comp_hdr.children():
		if hname is None or chld['name'] == hname:
			hlist.append((hname, chld['value']))
	return hlist

def set_composer_subject(s):
	entry_subject.set_text(s)

def set_composer_text(s):
	bufr = panel_edit_message.get_buffer()
	bufr.set_text(s)
	bufr.place_cursor(bufr.get_start_iter())

def open_composer():
	if win_comp.get_visible():
		if not win_comp.get_data('email-sent') and not win_comp.get_data('is-saved'):
			win_comp.set_urgency_hint(True)
			win_comp.present()
			return False
		else:
			win_comp.hide()
	
	global NewEmail
	NewEmail = MIMEMultipart()
	NewEmail.preamble = PREAMBLE
	part0 = MIMEText('')
	part0.set_charset('UTF-8')
	NewEmail.attach(part0)
	
	win_comp.show_all()
	clear_composer_headers(None)
	for h in SenderHeaders: add_composer_header(h).cancel()
	set_composer_subject('')
	set_composer_text('')

	win_comp.set_data('saved-to-file', None)
	on_after_save_draft()
	win_comp.set_focus(panel_edit_message)
	return True

def quote_message_plain():
	#TODO
	return "> "

def get_user_signature():
	try:
		sign = ''.join(open(os.path.join(os.environ['HOME'], '.signature'), 'r').readlines())
	except:
		sign = ''
	return sign

def act_compose():
	if open_composer():
		set_composer_subject('')
		set_composer_text("\n\n" + get_user_signature())

def act_reply(recip):
	if open_composer():
		if recip == '':
			set_composer_subject(_("Fwd: ") + get_one_header_main('Subject', ''))
			# TODO attach original email (file)
		else:
			set_composer_subject(_("Re: ") + get_one_header_main('Subject', ''))
			set_composer_headers('To', ["from"])
		if recip == 'all':
			set_composer_headers('Cc', ["cc1", "cc2"])
			if mail_list:
				set_composer_headers('To', ["mail_list"])
		body = "\n\n" + get_user_signature() + "\n"
		if recip in ['one', 'all']:
			body += "\n" + _("Quote:\n") + quote_message_plain()
		set_composer_text(body)

def act_mark_spam():
	pass

def get_extension_by_mime(mime):
	if mime is None:
		e = None
	else:
		e = guess_extension(mime)
	if e is None:
		e = '.dat'
	return e

def get_mime_by_filepath(path):
	t = Magic.file(path)
	if t is None: return 'application/octet-stream'
	return t

def act_open():
	eml = get_part_by_itpath()
	if eml is None: return
	mime = eml.get_content_type()
	fd, tmppath = mkstemp(prefix = PROGNAME + '-', suffix = get_extension_by_mime(mime))
	try:
		save_to_filedescriptor(eml, fd)
		fh = os.fdopen(fd)
		set_xattr_charset(fh, eml.get_content_charset(), tmppath)
		fh.close()
	except OSError, e:
		os.unlink(tmppath)
		e.filename = tmppath
		display_error(e)
		return
	run_async('mimeopen-gui', [tmppath], [os.unlink, tmppath])

def calc_attachment_name(part, n=None):
	name = part.get_filename()
	if name is None:
		name = "%s_attachment%s%s" % (get_one_header_main('Subject', _("Email")), '' if n is None else '-'+str(n), get_extension_by_mime(part.get_content_type()))
	return name

def act_save():
	itpaths = selection_parts.get_selected_rows()[1]
	if len(itpaths) == 1:
		itpath = itpaths[0]
		eml = get_part_by_itpath(itpath)
		savefile = choose_save_file(calc_attachment_name(eml))
		if savefile is not None:
			save_to_file(eml, savefile)
	elif len(itpaths) > 1:
		savedir = choose_save_folder()
		if savedir is not None:
			for n in range(0, len(itpaths)):
				eml = get_part_by_itpath(itpaths[n])
				savefile = os.path.join(savedir, calc_attachment_name(eml, n))
				save_to_file(eml, savefile)

def set_xattr_charset(fh, charset, filename='-'):
	if xattr is not None:
		try:
			if charset is None:
				xattr.removexattr(fh, XATTR_CHARSET)
			else:
				xattr.setxattr(fh, XATTR_CHARSET, charset)
		except IOError, e:
			sys.stderr.write((_("Notice: can not set xattr '%s' on '%s': %s") % (XATTR_CHARSET, filename, str(e))) + "\n")
			pass

def save_to_file(eml, filename, ask_overwrite=True):
	if ask_overwrite:
		if os.path.exists(filename):
			if not question(_("This file already exists:\n%s\nOverwrite?") % (os.path.basename(filename)), (None, gtk.STOCK_SAVE)):
				return None
	try:
		fh = open(filename, 'w')
		save_to_filedescriptor(eml, fh.fileno())
		set_xattr_charset(fh, eml.get_content_charset(), filename)
		fh.close()
		return True
	except IOError, e:
		display_error(e)
	except OSError, e:
		e.filename = filename
		display_error(e)
	return False

def save_to_filedescriptor(eml, fd):
	s = eml.get_payload(decode=1)
	if s is None:
		s = eml.as_string()
	written = os.write(fd, s)
	if written != len(s):
		raise OSError(5, 'Write Error')

def act_view_source():
	if panel_content.get_data('view-unfiltered'):
		filt = None
	else:
		filt = ('', None)
	load_part(get_part_by_itpath(), filt)

def act_wrap(tv, i=1):
	modes = cyclelist([gtk.WRAP_WORD, gtk.WRAP_WORD_CHAR, gtk.WRAP_NONE], at=panel_content.get_wrap_mode())
	tv.set_wrap_mode(modes.turn(i))

def get_current_font(txtv):
	pctx = txtv.get_pango_context()
	fdsc = pctx.get_font_description()
	s = fdsc.to_string()
	m = re.match('\s(\d+)(\s|$)', s)
	if m: pt = int(m.group(1))
	else: pt = 12
	return {'family': fdsc.get_family().lower(), 'string': s.lower(), 'size': pt, 'desc': fdsc,}

def act_font_switch(tv):
	font = get_current_font(tv)
	if font['family'] != 'monospace':
		tv.set_data('saved-font', font)
		f = tv.get_data('saved-font-monospace')
		if f is None: f = 'monospace 12'
		else: f = f['string']
	else:
		f = tv.get_data('saved-font')['string']
	change_font(tv, f)

def act_font(tv):
	dlg = gtk.FontSelectionDialog(_("Select Font"))
	dlg.set_font_name(tv.get_data('saved-font')['string'])
	dlg.set_modal(True)
	dlg.run()
	font_name = dlg.get_font_name()
	dlg.destroy()
	change_font(tv, font_name)
	font = get_current_font(tv)
	if font['family'] == 'monospace':
		key = 'saved-font-monospace'
	else:
		key = 'saved-font'
	tv.set_data(key, font)

def change_font(tv, s):
	tv.modify_font(pango.FontDescription(s))

def on_select_parts(selection):
	itpaths = selection.get_selected_rows()[1]
	if len(itpaths) > 1:
		panel_btnbox.show()
		lbl_right.set_markup(_("Multiple (%s) selected attachments") % (len(itpaths)))
		btn_open.hide()
		btn_save.set_label(_("Save All"))
		spanel_content.hide()
		btn_open2.set_sensitive(False)
		btn_save2.set_sensitive(True)
		menubutton_filters.set_sensitive(False)
	else:
		panel_btnbox.hide()
		spanel_content.show()
		if len(itpaths) == 1:
			btn_open2.set_sensitive(True)
			btn_save2.set_sensitive(True)
			itpath = itpaths[0]
			eml = get_part_by_itpath(itpath)
			load_part(eml)
			menubutton_filters.set_sensitive(True)
			populate_filters_menu(eml)
		else:
			btn_open2.set_sensitive(False)
			btn_save2.set_sensitive(False)
			clear_content()
			menubutton_filters.set_sensitive(False)

def act_show_headers(chkmi):
	if chkmi.active:
		spanel_header.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
		panel_header.set_line_wrap(False)
		s = ''
		for hname, hval in Email._headers:
			hval = decode_header(hval)
			s += PMU_HEAD + glib.markup_escape_text(hname) + PMU_HEAD_CLOSE + ': ' + glib.markup_escape_text(hval) + "\n"
		panel_header.set_markup(s)
	else:
		spanel_header.set_policy(gtk.POLICY_NEVER, gtk.POLICY_AUTOMATIC)
		panel_header.set_line_wrap(True)
		panel_header.set_markup(get_headers_markup(Email))
	panel_header.set_data('all-headers', chkmi.active)

def populate_header_menu(label, menu):
	menu.append(gtk.SeparatorMenuItem())
	mi = gtk.CheckMenuItem(_("All Headers"))
	mi.set_active(panel_header.get_data('all-headers') == True)
	mi.connect('toggled', act_show_headers)
	menu.append(mi)
	menu.show_all()

def populate_filters_menu(eml):
	for mi in menu_filters.children():
		menu_filters.remove(mi)
	uniqfilt = {}
	for filt in get_filters_by_mime(eml.get_content_maintype(), eml.get_content_subtype()):
		if filt[0] == '': continue
		if uniqfilt.has_key(filt[0]) and uniqfilt[filt[0]] == filt[1]: continue
		uniqfilt[filt[0]] = filt[1]
		mi = gtk.MenuItem(filt[0])
		mi.connect('activate', lambda mi, eml, filt: load_part(eml, filt), eml, filt)
		menu_filters.append(mi)
	menu_filters.show_all()
	disable_filters_menu(True if len(menu_filters.children()) == 0 else False)

def disable_filters_menu(b=True):
	menubutton_filters.children()[0].children()[1].set_sensitive(not b)

def get_part_by_itpath(itpath = None):
	if itpath is None:
		try:
			itpath = selection_parts.get_selected_rows()[1][0]
		except IndexError:
			return None
	model = Parts
	return model.get_value(model.get_iter(itpath), 0)

def load_toolitems(toolbar, toolitems):
	for label, stock, tip, fnc_left, fnc_right in toolitems:
		if type(fnc_left) == str:
			tbi = gtk.SeparatorToolItem()
			if fnc_left == 'space':
				tbi.set_draw(False)
				tbi.set_expand(True)
			elif fnc_left == 'separator':
				tbi.set_draw(True)
				tbi.set_expand(False)
		elif isinstance(stock, gtk.ToolItem):
			tbi = stock
			if tip is not None:
				tbi.set_tooltip_text(tip)
			tbi.connect('clicked', on_click_button, fnc_left)
		else:
			stocklabel = None
			s = gtk.stock_lookup(stock)
			if s:
				stocklabel = re.sub('_', '', s[1])
			if label is not None:
				label = _(label)
			else:
				label = stocklabel
			if tip is not None:
				tip = _(tip)
			else:
				if label is not None:
					tip = label
				else:
					tip = stocklabel
			tbi = StockToolButton(label=label, stock=stock, tooltip=tip)
			tbi.set_data('stock', stock)
			tbi.connect('clicked', on_click_button, fnc_left)
			tbi.child.connect('button-press-event', on_press_button, fnc_right)
		toolbar.insert(tbi, -1)

def setup_treeview__icon_label(tv, label_edit_cb=None):
	colnum_txt = 1
	tvc = gtk.TreeViewColumn()
	tv.append_column(tvc)
	cr_pix = gtk.CellRendererPixbuf()
	cr_txt = gtk.CellRendererText()
	if label_edit_cb is not None:
		cr_txt.set_property('editable', True)
		cr_txt.connect('edited', label_edit_cb, colnum_txt)
	tvc.pack_start(cr_pix, False)
	tvc.pack_start(cr_txt, True)
	tvc.add_attribute(cr_txt, 'markup', colnum_txt)
	tvc.add_attribute(cr_pix, 'icon-name', 2)
	tvc.add_attribute(cr_pix, 'pixbuf', 3)


def act_send():
	pass

def act_save_edit(save_as=False):
	global NewEmail
	filename = win_comp.get_data('saved-to-file')
	ask_overwrite = False
	if filename is None or save_as:
		ask_overwrite = True
		filename = choose_save_file(_("Draft") + '.eml')
	if filename is not None:
		if save_to_file(NewEmail, filename, ask_overwrite=ask_overwrite) == True:
			win_comp.set_data('saved-to-file', filename)
			on_after_save_draft()

def on_after_save_draft():
	win_comp.set_data('is-saved', True)
	panel_edit_message.get_buffer().set_modified(False)

def act_attach():
	filename = choose_open_file()
	if filename is not None:
		attach_path(filename)

def attach_path(path):
	if os.path.isdir(path):
		for entry in os.listdir(path):
			if not attach_path(os.path.join(path, entry)):
				return False
	else:
		global NewEmail
		basename = os.path.basename(path)
		ct_main, ct_sub = get_mime_by_filepath(path).split('/')
		part = MIMEBase(ct_main, ct_sub)
		part.add_header(HDR_CD, 'attachment', filename=basename)
		# Load file into MIME part's payload
		part.set_payload('')
		fh = open(path, 'r')
		while True:
			buf = fh.read(4096)
			if buf == '': break
			part._payload += buf
		fh.close()
		NewEmail.attach(part)

		stock = get_stock_by_mime(ct_main, ct_sub)
		pixb = None
		Attachments.append([part, basename, stock, pixb])

def drop_attachment_motion(wdg, context, x, y, time):
	wdg.drag_highlight()
	context.drag_status(gtk.gdk.ACTION_COPY, time)
	return True

def drop_attachment_accept(wdg, context, x, y, time):
	accepted = False
	for desired in ['text/uri-list']:
		if desired in context.targets:
			wdg.drag_get_data(context, desired, time)
			accepted = True
			break
	context.drop_reply(accepted, time)
	wdg.drag_unhighlight()
	return True

def drop_attachment(wdg, context, x, y, data, info, time):
	success = None
	if data.get_length() > -1:
		typ = data.get_data_type()
		if typ == 'text/uri-list':
			for uri in data.get_uris():
				if uri.startswith('file:///'):
					if not attach_path(uri[7:]):
						success = False
						break
			if success is None:
				success = True
		else:
			success = False
	else:
		success = False
	context.finish(success, False, time)
	return True

def rename_attachment(cellrenderer, iterator, new_text, colnum):
	eml = Attachments[iterator][0]
	eml._headers.remove((HDR_CD, eml[HDR_CD]))
	eml.add_header(HDR_CD, 'attachment', filename=new_text)
	Attachments[iterator][colnum] = new_text
	return True

def on_keypress_attachments(tv, evt):
	if evt.keyval == gtk.gdk.keyval_from_name('Delete'):
		sel = panel_attachments.get_selection()
		for iterator in sel.get_selected_rows()[1]:
			NewEmail._payload.remove(Attachments[iterator][0])
			del(Attachments[iterator])
		return True
	return False

def act_edit_external():
	pass

def on_edit_message(tb):
	if tb.get_modified():
		win_comp.set_data('is-saved', False)



### Main ###

PROGNAME = 'gemlv'
_ = gettext.gettext
PMU_MIME = '<i><span color="gray30">'
PMU_MIME_CLOSE = '</span></i>'
PMU_NAME = '<b>'
PMU_NAME_CLOSE = '</b>'
PMU_HEAD = '<b>'
PMU_HEAD_CLOSE = '</b>'
Email = None
PartPrimary = None
PartSecondary = None
LastFolder = os.getcwd()
SenderHeaders = ['From', 'Reply-To', 'Organization']
RecipientHeaders = ['To', 'Cc', 'Bcc']
PopularHeaders = ['Subject']
AdvancedHeaders = [
	'References', 'In-Reply-To', 'Disposition-Notification-To',
	'Priority', 'Importance', 'Precedence',
	'Newsgroups', 'Followup-To', 'Thread-Topic',
	'Language', 'Accept-Language', 'Content-Language',
	'Expires',
	'User-Agent', 'X-Mailer',
	]
XATTR_CHARSET = 'user.mime_encoding'
NewEmail = None
PREAMBLE = _("This is a MIME multipart Email.")
Magic = magic.open(magic.MAGIC_MIME_TYPE)
HDR_CD = 'Content-Disposition'


### Parse Arguments ###

argparser = argparse.ArgumentParser()
argparser.add_argument('--compose', action='store_true', help=_("Write a new Email"))
argparser.add_argument('--from', metavar='FROM', help=_("New Email's Sender name and address"))
argparser.add_argument('--to', metavar='ADDRESSES', help=_("New Email's Recipients, comma-separated list"))
argparser.add_argument('--subject', metavar='STRING', help=_("Subject"))
argparser.add_argument('--message', metavar='STRING', help=_("Message body"))
argparser.add_argument('--attach', metavar='FILES', help=_("Attachments, comma-separated list"))
argparser.add_argument('FILE', nargs='?', help=_("Raw Email file for read or continue editing"))
args = argparser.parse_args()
for attr in 'to', 'attach':
	if getattr(args, attr) is not None:
		setattr(args, attr, re.split('\s*,\s*', getattr(args, attr)))
if not args.compose and not args.FILE:
	sys.stderr.write(_("Either compose mode or FILE is needed.") + "\n")
	os._exit(1)


### Build GUI ###

win_main = gtk.Window()
win_main.set_default_size(800, 450)
start_evt = win_main.connect('map-event', win_main_show)
win_main.connect('delete-event', lambda a,b: act_quit())
add_key_binding(win_main, '<Control>q', lambda a,b,c,d: act_quit())
add_key_binding(win_main, '<Control>s', lambda a,b,c,d: act_save())
add_key_binding(win_main, '<Control>o', lambda a,b,c,d: act_open())
add_key_binding(win_main, '<Control>n', lambda a,b,c,d: act_compose())
add_key_binding(win_main, '<Control><Shift>r', lambda a,b,c,d: act_reply('one'))
add_key_binding(win_main, '<Control>r', lambda a,b,c,d: act_reply('all'))
add_key_binding(win_main, '<Control>f', lambda a,b,c,d: act_reply(''))
add_key_binding(win_main, '<Control>u', lambda a,b,c,d: act_view_source())

box_main = gtk.VBox(False, 5)
toolbar = gtk.Toolbar()
spanel_header = gtk.ScrolledWindow()
panel_header = gtk.Label()
panel_body = gtk.HPaned()
spanel_parts = gtk.ScrolledWindow()
Parts = gtk.TreeStore(gobject.TYPE_PYOBJECT, str, str, gtk.gdk.Pixbuf)
panel_parts = gtk.TreeView(Parts)
selection_parts = panel_parts.get_selection()
panel_right = gtk.VBox()
lbl_right = gtk.Label()
panel_btnbox = gtk.HBox()
btnbox_right = gtk.VBox(True, 10)
btn_open = StockButton(stock=gtk.STOCK_OPEN)
btn_save = StockButton(stock=gtk.STOCK_SAVE)
spanel_content = gtk.ScrolledWindow()
panel_content = gtk.TextView()
tb_controls = gtk.Toolbar()
menubutton_filters = gtk.MenuToolButton(gtk.STOCK_ZOOM_FIT)
menu_filters = gtk.Menu()

win_main.add(box_main)
box_main.pack_start(toolbar, False, True)
box_main.pack_start(spanel_header, False, True)
spanel_header.add_with_viewport(panel_header)
box_main.pack_start(panel_body, True, True)
panel_body.pack1(spanel_parts, True, True)
panel_body.pack2(panel_right, True, True)
spanel_parts.add_with_viewport(panel_parts)
panel_right.pack_start(panel_btnbox, True, False)
panel_btnbox.pack_start(lbl_right, True, False)
panel_btnbox.pack_start(btnbox_right, True, False)
btnbox_right.pack_start(btn_open, False, False)
btnbox_right.pack_start(btn_save, False, False)
panel_right.pack_start(spanel_content, True, True)
spanel_content.add_with_viewport(panel_content)
panel_right.pack_start(tb_controls, False, True)

win_main.set_icon_name('emblem-mail')
toolbar.set_style(gtk.TOOLBAR_BOTH)
spanel_header.set_size_request(-1, 104)
spanel_header.set_policy(gtk.POLICY_NEVER, gtk.POLICY_AUTOMATIC)
panel_header.set_line_wrap(True)
panel_header.set_padding(4, 2)
panel_header.set_alignment(0, 0)
panel_header.set_justify(gtk.JUSTIFY_LEFT)
panel_header.set_selectable(True)
panel_header.connect('populate-popup', populate_header_menu)
panel_body.set_position(175)
spanel_parts.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
spanel_content.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
panel_parts.set_headers_visible(False)
selection_parts.set_mode(gtk.SELECTION_MULTIPLE)
selection_parts.connect('changed', on_select_parts)
lbl_right.set_alignment(0, 0)
lbl_right.set_justify(gtk.JUSTIFY_LEFT)
btn_open.connect('clicked', lambda wdg: act_open())
btn_save.connect('clicked', lambda wdg: act_save())
panel_content.set_editable(False)
panel_content.set_wrap_mode(gtk.WRAP_WORD)
tb_controls.set_icon_size(gtk.ICON_SIZE_MENU)
tb_controls.set_style(gtk.TOOLBAR_ICONS)
menubutton_filters.set_homogeneous(False)
menubutton_filters.set_menu(menu_filters)
menubutton_filters.set_arrow_tooltip_text(_("Filters"))


toolbuttons = [
	("Compose", gtk.STOCK_EDIT, None, act_compose, None),
	("Reply", 'mail-reply-sender', None, (act_reply, 'one'), None),
	("Reply To All", 'mail-reply-all', None, (act_reply, 'all'), None),
	("Forward", 'mail-forward', None, (act_reply, ''), None),
	(None, None, None, 'separator', None),
	("Report Spam", 'mail-mark-junk', None, act_mark_spam, None),
	(None, None, None, 'space', None),
	(None, gtk.STOCK_QUIT, None, act_quit, None),
]
load_toolitems(toolbar, toolbuttons)
setup_treeview__icon_label(panel_parts)

def ToolItemDeclaration_wrap(tv):
	return ("Wrap", gtk.STOCK_JUSTIFY_LEFT, "Soft / Hard / No Wrap\nRight click: No / Soft / Hard Wrap", (act_wrap, tv), (act_wrap, tv, -1))
def ToolItemDeclaration_font(tv):
	return (None, gtk.STOCK_SELECT_FONT, "Change Font\nRight click: monospace", (act_font, tv), (act_font_switch, tv))

toolbuttons = [
	(None, None, None, 'space', None),
	(None, gtk.STOCK_OPEN, None, act_open, None),
	(None, gtk.STOCK_SAVE, None, act_save, None),
	(None, None, None, 'separator', None),
	("Unfilter", menubutton_filters, "Filter / Unfilter", act_view_source, None),
	ToolItemDeclaration_wrap(panel_content),
	ToolItemDeclaration_font(panel_content),
]
load_toolitems(tb_controls, toolbuttons)
for tbi in tb_controls.get_children():
	s = tbi.get_data('stock')
	if s == gtk.STOCK_OPEN:
		btn_open2 = tbi
	elif s == gtk.STOCK_SAVE:
		btn_save2 = tbi


### Build Composer GUI ###

win_comp = gtk.Window()
win_comp.set_default_size(*win_main.get_default_size())
win_comp.connect('delete-event', lambda a,b: act_close_edit())
add_key_binding(win_comp, '<Control>'+('q' if args.compose else 'w'), lambda a,b,c,d: act_close_edit())
add_key_binding(win_comp, '<Control>s', lambda a,b,c,d: act_save_edit())
add_key_binding(win_comp, '<Control><Shift>s', lambda a,b,c,d: act_save_edit(True))
add_key_binding(win_comp, 'F4', lambda a,b,c,d: act_edit_external())

box_compose = gtk.VBox()
tb_compose = gtk.Toolbar()
panel_compose = gtk.VPaned()
panel_upper = gtk.HPaned()
spanel_comp_hdr = gtk.ScrolledWindow()
menu_add_header = gtk.Menu()
panel_comp_hdr = gtk.VBox(False, 0)
UnionHeadersStore = gtk.ListStore(str)
spanel_attachments = gtk.ScrolledWindow()
Attachments = gtk.ListStore(gobject.TYPE_PYOBJECT, str, str, gtk.gdk.Pixbuf)
panel_attachments = gtk.TreeView(Attachments)
panel_edit = gtk.VBox()
panel_subject = gtk.HBox(False, 5)
panel_subject.set_border_width(4)
entry_subject = gtk.Entry()
frame_edit = gtk.Frame()
spanel_edit_message = gtk.ScrolledWindow()
panel_edit_message = gtk.TextView()
tb_comp_controls = gtk.Toolbar()

win_comp.add(box_compose)
box_compose.pack_start(tb_compose, False, True)
box_compose.pack_start(panel_compose, True, True)
panel_compose.pack1(panel_upper, True, True)
panel_upper.pack1(spanel_comp_hdr, True, True)
spanel_comp_hdr.add_with_viewport(panel_comp_hdr)
panel_upper.pack2(spanel_attachments, False, True)
spanel_attachments.add_with_viewport(panel_attachments)
panel_attachments.set_headers_visible(False)
panel_compose.pack2(panel_edit, True, True)
panel_edit.pack_start(panel_subject, False, True)
panel_subject.pack_start(gtk.Label(_("Subject")), False, True)
panel_subject.pack_start(entry_subject, True, True)
panel_edit.pack_start(frame_edit, True, True)
frame_edit.add(spanel_edit_message)
spanel_edit_message.add(panel_edit_message)
box_compose.pack_start(tb_comp_controls, False, True)

win_comp.set_icon_name('mail-message-new')
tb_compose.set_style(gtk.TOOLBAR_BOTH)
panel_upper.set_position(win_comp.get_default_size()[0]-150)
spanel_comp_hdr.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
spanel_comp_hdr.connect('button-press-event', open_comp_hdr_menu)
panel_comp_hdr.set_border_width(4)
spanel_attachments.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
panel_attachments.drag_dest_set(0, [], 0)
panel_attachments.connect('drag-motion', drop_attachment_motion)
panel_attachments.connect('drag-drop', drop_attachment_accept)
panel_attachments.connect('drag-data-received', drop_attachment)
panel_attachments.connect('focus-out-event', lambda w, e: w.get_selection().unselect_all())
panel_attachments.connect('key-press-event', on_keypress_attachments)
panel_compose.set_position(125)
spanel_edit_message.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
panel_edit_message.get_buffer().connect('modified-changed', on_edit_message)
frame_edit.set_shadow_type(gtk.SHADOW_IN)
tb_comp_controls.set_icon_size(gtk.ICON_SIZE_MENU)
tb_comp_controls.set_style(gtk.TOOLBAR_ICONS)

for name in SenderHeaders:
	mi = gtk.CheckMenuItem(_("Specify %s") % (_(name)))
	mi.set_data('chname', name)
	mi.connect('toggled', act_comp_hdr_menuitem)
	menu_add_header.append(mi)
mi = gtk.MenuItem(_("Specify Recipient"))
mi.connect('activate', act_comp_hdr_menuitem, 'To')
menu_add_header.append(mi)
menu_add_header.append(gtk.SeparatorMenuItem())
mi = gtk.MenuItem(_("Add Custom Header"))
mi.connect('activate', act_comp_hdr_menuitem, '')
menu_add_header.append(mi)
menu_add_header.show_all()

toolbuttons = [
	("Send", 'mail-send', None, act_send, None),
	(None, gtk.STOCK_SAVE, _("Save\nRight click: Save As..."), act_save_edit, (act_save_edit, True)),
	("Addressbook", 'x-office-address-book', None, None, None), # TODO
	("Attach File", 'mail-attachment', None, act_attach, None),
	(None, None, None, 'space', None),
	(None, gtk.STOCK_QUIT if args.compose else gtk.STOCK_CLOSE, None, act_close_edit, None),
]
load_toolitems(tb_compose, toolbuttons)
setup_treeview__icon_label(panel_attachments, label_edit_cb=rename_attachment)

for h in SenderHeaders + RecipientHeaders + PopularHeaders + AdvancedHeaders:
	UnionHeadersStore.append([h])

toolbuttons = [
	(None, None, None, 'space', None),
	(None, 'mail-mark-important', "Non-Important", None, None), # TODO
	(None, 'mail-mark-important', "Important", None, None), # TODO
	(None, None, None, 'separator', None),
	(None, gtk.STOCK_EDIT, "Edit with External Program", act_edit_external, None),
	ToolItemDeclaration_wrap(panel_edit_message),
	ToolItemDeclaration_font(panel_edit_message),
]
load_toolitems(tb_comp_controls, toolbuttons)


gettext.bindtextdomain('gemlv')
Magic.load()
if args.compose:
	open_composer()
	if args.FILE:
		# TODO load email
		win_comp.set_data('saved-to-file', args.FILE)
	if getattr(args, 'from'):
		set_composer_headers('From', [getattr(args, 'from')])
	if args.to:
		set_composer_headers('To', args.to)
	if args.subject:
		set_composer_subject(args.subject)
	if args.message:
		set_composer_text(args.message)
	if args.attach:
		for path in args.attach:
			attach_path(path)
	on_after_save_draft()
else:
	win_main.show_all()
	panel_btnbox.hide()
gtk.main()
